
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>corrfitter - Least-Squares Fit to Correlators &#8212; corrfitter 6.0.2 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '6.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Annotated Example: Two-Point Correlator" href="example-etas.html" />
    <link rel="prev" title="corrfitter Documentation" href="index.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="example-etas.html" title="Annotated Example: Two-Point Correlator"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="corrfitter Documentation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">corrfitter 6.0.2 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-corrfitter">
<span id="corrfitter-least-squares-fit-to-correlators"></span><h1><a class="reference internal" href="#module-corrfitter" title="corrfitter: Least-Squares Fit to Correlators."><code class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></code></a> - Least-Squares Fit to Correlators<a class="headerlink" href="#module-corrfitter" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This module contains tools that facilitate least-squares fits, as functions
of time <code class="docutils literal"><span class="pre">t</span></code>, of simulation (or other statistical) data for 2-point and
3-point correlators of the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Gab</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>    <span class="o">=</span>  <span class="o">&lt;</span><span class="n">b</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span>
<span class="n">Gavb</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">T</span><span class="p">)</span> <span class="o">=</span>  <span class="o">&lt;</span><span class="n">b</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">V</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">t</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. Each correlator is modeled using <a class="reference internal" href="#corrfitter.Corr2" title="corrfitter.Corr2"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr2</span></code></a> for 2-point
correlators, or <a class="reference internal" href="#corrfitter.Corr3" title="corrfitter.Corr3"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr3</span></code></a> for 3-point correlators in terms of amplitudes for
each source <code class="docutils literal"><span class="pre">a</span></code>, sink <code class="docutils literal"><span class="pre">b</span></code>, and vertex <code class="docutils literal"><span class="pre">V</span></code>, and the energies
associated with each intermediate state. The amplitudes and energies are
adjusted in the least-squares fit to reproduce the data; they are defined
in a shared prior (typically a dictionary).</p>
<p>An object of type <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> describes a collection of correlators and is
used to fit multiple models to data simultaneously. Fitting multiple
correlators simultaneously is important if there are statistical
correlations between the correlators. Any number of correlators may be
described and fit by a single <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> object.</p>
<p>We now review the basic features of <a class="reference internal" href="#module-corrfitter" title="corrfitter: Least-Squares Fit to Correlators."><code class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></code></a>. These features are also
illustrated for real applications in a series of annotated
examples following this section. Impatient readers may wish to jump
directly to these examples.</p>
<p><em>About Printing:</em> The examples in this tutorial use the <code class="docutils literal"><span class="pre">print</span></code> function
as it is used in Python 3. Drop the outermost parenthesis in each <code class="docutils literal"><span class="pre">print</span></code>
statement if using Python 2; or add</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
</pre></div>
</div>
<p>at the start of your file.</p>
</div>
<div class="section" id="basic-fits">
<span id="id1"></span><h2>Basic Fits<a class="headerlink" href="#basic-fits" title="Permalink to this headline">¶</a></h2>
<p>To illustrate, consider data for two 2-point correlators: <code class="docutils literal"><span class="pre">Gaa</span></code> with the
same source and sink (<code class="docutils literal"><span class="pre">a</span></code>), and <code class="docutils literal"><span class="pre">Gab</span></code> which has source <code class="docutils literal"><span class="pre">a</span></code> and
(different) sink <code class="docutils literal"><span class="pre">b</span></code>. The data are contained in a dictionary <code class="docutils literal"><span class="pre">data</span></code>,
where <code class="docutils literal"><span class="pre">data['Gaa']</span></code> and <code class="docutils literal"><span class="pre">data['Gab']</span></code> are one-dimensional arrays
containing values for <code class="docutils literal"><span class="pre">Gaa(t)</span></code> and <code class="docutils literal"><span class="pre">Gab(t)</span></code>, respectively, with
<code class="docutils literal"><span class="pre">t=0,1,2...63</span></code>. Each array element in <code class="docutils literal"><span class="pre">data['Gaa']</span></code> and <code class="docutils literal"><span class="pre">data['Gab']</span></code>
is a Gaussian random variable of type <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>, and specifies the mean and
standard deviation for the corresponding data point:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;Gaa&#39;</span><span class="p">])</span>
<span class="go">[0.1597910(41) 0.0542088(31) ... ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;Gab&#39;</span><span class="p">])</span>
<span class="go">[0.156145(18) 0.102335(15) ... ]</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s also capture statistical correlations between different
pieces of data, if they exist.</p>
<p>We want to fit this data to the following formulas:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Gaa</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">N</span><span class="p">)</span> <span class="o">=</span> <span class="n">sum_i</span><span class="o">=</span><span class="mf">0.</span><span class="o">.</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">Gab</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">N</span><span class="p">)</span> <span class="o">=</span> <span class="n">sum_i</span><span class="o">=</span><span class="mf">0.</span><span class="o">.</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>  <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Our goal is to find values for the amplitudes, <code class="docutils literal"><span class="pre">a[i]</span></code> and <code class="docutils literal"><span class="pre">b[i]</span></code>, and the
energies, <code class="docutils literal"><span class="pre">E[i]</span></code>, so that these formulas reproduce the average values for
<code class="docutils literal"><span class="pre">Gaa(t,N)</span></code> and <code class="docutils literal"><span class="pre">Gab(t,N)</span></code> that come from the data, to within the data’s
statistical errors. We use the same <code class="docutils literal"><span class="pre">a[i]</span></code>s and <code class="docutils literal"><span class="pre">E[i]</span></code>s in both
formulas. The fit parameters used by the fitter are the <code class="docutils literal"><span class="pre">a[i]</span></code>s and
<code class="docutils literal"><span class="pre">b[i]</span></code>s, as well as the differences <code class="docutils literal"><span class="pre">dE[i]=E[i]-E[i-1]</span></code> for <code class="docutils literal"><span class="pre">i&gt;0</span></code> and
<code class="docutils literal"><span class="pre">dE[0]=E[0]</span></code>. The energy differences are usually positive by construction
(see below) and are easily converted back to energies using:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_j</span><span class="o">=</span><span class="mf">0.</span><span class="o">.</span><span class="n">i</span> <span class="n">dE</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>A typical code has the following structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">corrfitter</span> <span class="k">as</span> <span class="nn">cf</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">)</span>          <span class="c"># user-supplied routine</span>
    <span class="n">models</span> <span class="o">=</span> <span class="n">make_models</span><span class="p">()</span>              <span class="c"># user-supplied routine</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>                               <span class="c"># number of terms in fit functions</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>               <span class="c"># user-supplied routine</span>
    <span class="n">fitter</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">)</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>  <span class="c"># do the fit</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
    <span class="n">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>     <span class="c"># user-supplied routine</span>

<span class="o">...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>We discuss each user-supplied routine in turn.</p>
<div class="section" id="a-make-data">
<h3>a) make_data<a class="headerlink" href="#a-make-data" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">make_data('mcfile')</span></code> creates the dictionary containing the data that is to
be fit. Typically such data comes from a Monte Carlo simulation. Exactly
how the data are assembled depends upon how Monte Carlo results are stored.</p>
<p>Imagine, for example, that
the simulation creates a file called <code class="docutils literal"><span class="pre">'mcfile'</span></code> with layout</p>
<div class="highlight-default"><div class="highlight"><pre><span class="c"># first correlator: each line has Gaa(t) for t=0,1,2...63</span>
<span class="n">Gaa</span>  <span class="mf">0.159774739530e+00</span> <span class="mf">0.541793561501e-01</span> <span class="o">...</span>
<span class="n">Gaa</span>  <span class="mf">0.159751906801e+00</span> <span class="mf">0.542054488624e-01</span> <span class="o">...</span>
<span class="n">Gaa</span>  <span class="o">...</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="c"># second correlator: each line has Gab(t) for t=0,1,2...63</span>
<span class="n">Gab</span>  <span class="mf">0.155764170032e+00</span> <span class="mf">0.102268808986e+00</span> <span class="o">...</span>
<span class="n">Gab</span>  <span class="mf">0.156248435021e+00</span> <span class="mf">0.102341455176e+00</span> <span class="o">...</span>
<span class="n">Gab</span>  <span class="o">...</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
</pre></div>
</div>
<p>where each line is one Monte Carlo measurement for one or the other
correlator, as indicated by the tags at the start of the line. (Lines for
<code class="docutils literal"><span class="pre">Gab</span></code> may be interspersed with lines for <code class="docutils literal"><span class="pre">Gaa</span></code> since every line has a
tag.) A data file in this format can be analyzed using:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">corrfitter</span> <span class="k">as</span> <span class="nn">cf</span>

<span class="k">def</span> <span class="nf">make_data</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read_dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>
</pre></div>
</div>
<p>This reads the data from the file into a dataset,
which is a dictionary whose values
are two-dimenional arrays where the first index labels the Monte Carlo
sample, and the second index labels time: for example,</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dset</span><span class="p">[</span><span class="s">&#39;Gaa&#39;</span><span class="p">])</span>
<span class="go">[ [0.159774739530e+00 0.541793561501e-01 ... ],</span>
<span class="go">  [0.159751906801e+00 0.542054488624e-01 ... ],</span>
<span class="go">  ...]</span>
</pre></div>
</div>
<p>Function <code class="xref py py-func docutils literal"><span class="pre">gvar.dataset.avg_data()</span></code> then
averages over the Monte Carlo samples. Thus
<code class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">make_data('mcfile')</span></code> creates a dictionary where
<code class="docutils literal"><span class="pre">data['Gaa']</span></code> is a one-dimensional array of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s, indexed by time,
obtained by averaging over the
<code class="docutils literal"><span class="pre">Gaa</span></code> data in the <code class="docutils literal"><span class="pre">'mcfile'</span></code>, and <code class="docutils literal"><span class="pre">data['Gab']</span></code> is a similar array
for the <code class="docutils literal"><span class="pre">Gab</span></code> correlator. The correlator values for different
<code class="docutils literal"><span class="pre">t</span></code>s are typically correlated with each other.</p>
<p>Other data formats are readily adapted to this purpose.
For example, the same Monte Carlo data might
be stored in an hdf5 file:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="k">def</span> <span class="nf">make_data</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">h5file</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">Gaa</span><span class="o">=</span><span class="n">h5file</span><span class="p">[</span><span class="s">&#39;/run5/Gaa&#39;</span><span class="p">],</span> <span class="n">Gab</span><span class="o">=</span><span class="n">hfile</span><span class="p">[</span><span class="s">&#39;/run5/Gab&#39;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we assume <code class="docutils literal"><span class="pre">h5file['/run5/Gaa']</span></code> and <code class="docutils literal"><span class="pre">hfile['/run5/Gab']</span></code>
are hdf5 datasets that
have been configured, again, as two-dimensional numpy arrays, where the
first index is the Monte Carlo sample (configuration) index, and the second
index is time.</p>
<p>Function <code class="xref py py-func docutils literal"><span class="pre">corrfitter.read_dataset()</span></code> can read hdf5 files, so this
last example could also be handled by</p>
<div class="highlight-default"><div class="highlight"><pre><span class="k">def</span> <span class="nf">make_data</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read_dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">h5group</span><span class="o">=</span><span class="s">&#39;/run5&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>
</pre></div>
</div>
<p>provided <code class="docutils literal"><span class="pre">filename</span></code> ends in <code class="docutils literal"><span class="pre">'.h5'</span></code>. This
reads in all hdf5 datasets in group <code class="docutils literal"><span class="pre">/run5</span></code>.</p>
</div>
<div class="section" id="b-make-models">
<h3>b) make_models<a class="headerlink" href="#b-make-models" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">make_models()</span></code> identifies which correlators in the fit data are to be fit,
and specifies theoretical models (that is, fit functions) for these
correlators:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">corrfitter</span> <span class="k">as</span> <span class="nn">cf</span>

<span class="k">def</span> <span class="nf">make_models</span><span class="p">():</span>
    <span class="n">tdata</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
    <span class="n">tfit</span> <span class="o">=</span> <span class="n">tdata</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">cf</span><span class="o">.</span><span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gaa&#39;</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="n">tdata</span><span class="p">,</span> <span class="n">tfit</span><span class="o">=</span><span class="n">tfit</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">),</span>
        <span class="n">cf</span><span class="o">.</span><span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gab&#39;</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="n">tdata</span><span class="p">,</span> <span class="n">tfit</span><span class="o">=</span><span class="n">tfit</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">models</span>
</pre></div>
</div>
<p>For each correlator, we specify: the key used in the input data dictionary
<code class="docutils literal"><span class="pre">data</span></code> for that correlator (<code class="docutils literal"><span class="pre">datatag</span></code>); the <code class="docutils literal"><span class="pre">t</span></code> values,
<code class="docutils literal"><span class="pre">tdata=[0,1,2...63]</span></code>, associated with each element of the fit data
for the correlator; the subset
of <code class="docutils literal"><span class="pre">tdata</span></code> values, <code class="docutils literal"><span class="pre">tfit=[2,3,4...63]</span></code>, to be used in the fit;
and fit-parameter labels for the source (<code class="docutils literal"><span class="pre">a</span></code>) and
sink (<code class="docutils literal"><span class="pre">b</span></code>) amplitudes, and for the intermediate energy-differences
(<code class="docutils literal"><span class="pre">dE</span></code>). Fit-parameter labels identify the parts of the prior,
discussed below, corresponding to the actual fit parameters (the labels are
dictionary keys). Here the two models, for <code class="docutils literal"><span class="pre">Gaa</span></code> and <code class="docutils literal"><span class="pre">Gab</span></code>, are
identical except for the data tags and the sinks. <code class="docutils literal"><span class="pre">make_models()</span></code> returns
a list of models; the only parts of the input fit data that are fit are
those for which a model is specified in <code class="docutils literal"><span class="pre">make_models()</span></code>.</p>
<p>Note that if there is data for <code class="docutils literal"><span class="pre">Gba(t,N)</span></code> in addition to <code class="docutils literal"><span class="pre">Gab(t,N)</span></code>, and
<code class="docutils literal"><span class="pre">Gba</span> <span class="pre">=</span> <span class="pre">Gab</span></code>, then the (weighted) average of the two data sets will be
fit if <code class="docutils literal"><span class="pre">models[1]</span></code> is replace by:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">cf</span><span class="o">.</span><span class="n">Corr2</span><span class="p">(</span>
    <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gab&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">63</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">,</span>
    <span class="n">otherdata</span><span class="o">=</span><span class="s">&#39;Gba&#39;</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Alternatively one could add a third <code class="docutils literal"><span class="pre">Corr2</span></code> to <code class="docutils literal"><span class="pre">models</span></code> for <code class="docutils literal"><span class="pre">Gba</span></code>,
but it is more efficient to combine it with <code class="docutils literal"><span class="pre">Gab</span></code>, before the fit,
if they are
equivalent.</p>
<p>The arrays <code class="docutils literal"><span class="pre">tdata</span></code> and <code class="docutils literal"><span class="pre">tfit</span></code> provide more flexibility than is often
needed. Here, because there is data for all <code class="docutils literal"><span class="pre">t</span></code> values starting with 0,
we could have defined the correlator objects more simply, in terms
of the minimum and maximum <code class="docutils literal"><span class="pre">t</span></code> values used in the fit: for example,</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">cf</span><span class="o">.</span><span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gaa&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">63</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#corrfitter.Corr2" title="corrfitter.Corr2"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr2</span></code></a> creates the obvious choices for
<code class="docutils literal"><span class="pre">tdata</span></code> and <code class="docutils literal"><span class="pre">tfit</span></code> from the information given.</p>
</div>
<div class="section" id="c-make-prior">
<h3>c) make_prior<a class="headerlink" href="#c-make-prior" title="Permalink to this headline">¶</a></h3>
<p>This routine defines the fit parameters that correspond to each fit-parameter
label used in <code class="docutils literal"><span class="pre">make_models()</span></code> above. It also assigns <em>a priori</em> values to
each parameter, expressed in terms of Gaussian random variables (<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s),
with a mean and standard deviation. The prior is built using a Python
dictionary (we use <code class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></code> but others would work):</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="k">def</span> <span class="nf">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.1(5)&#39;</span><span class="p">])</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;1(5)&#39;</span><span class="p">])</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;dE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.25(25)&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">prior</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">make_prior(N)</span></code> associates  arrays of <code class="docutils literal"><span class="pre">N</span></code> Gaussian random variables
(<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s) with each fit-parameter label, enough for <code class="docutils literal"><span class="pre">N</span></code> terms in the fit
function. These  are the <em>a priori</em> values for the fit parameters, and they
can be retrieved using the label: setting <code class="docutils literal"><span class="pre">prior=make_prior(N)</span></code>, for
example, implies  that <code class="docutils literal"><span class="pre">prior['a'][i]</span></code>, <code class="docutils literal"><span class="pre">prior['b'][i]</span></code> and
<code class="docutils literal"><span class="pre">prior['dE'][i]</span></code> are the <em>a priori</em> values for <code class="docutils literal"><span class="pre">a[i]</span></code>, <code class="docutils literal"><span class="pre">b[i]</span></code> and
<code class="docutils literal"><span class="pre">dE[i]</span></code> in the fit functions (see above). The <em>a priori</em> value for each
<code class="docutils literal"><span class="pre">a[i]</span></code> here is set to <code class="docutils literal"><span class="pre">0.1±0.5</span></code>, while that for each <code class="docutils literal"><span class="pre">b[i]</span></code> is
<code class="docutils literal"><span class="pre">1±5</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">prior</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">])</span>
<span class="go">[0.10(50) 0.10(50) 0.10(50) 0.10(50)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">prior</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">])</span>
<span class="go">[1.0(5.0) 1.0(5.0) 1.0(5.0) 1.0(5.0)]</span>
</pre></div>
</div>
<p>Similarly the <em>a priori</em> value for each energy difference is <code class="docutils literal"><span class="pre">0.25±0.25</span></code>.
(See the <code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code> documentation for further information on priors.)</p>
</div>
<div class="section" id="d-print-results">
<h3>d) print_results<a class="headerlink" href="#d-print-results" title="Permalink to this headline">¶</a></h3>
<p>The actual fit is done by <code class="docutils literal"><span class="pre">fit=fitter.lsqfit(...)</span></code>, and <code class="docutils literal"><span class="pre">print(fit)</span></code>
right afterwards prints a summary of the fit results.
Further results are reported by <code class="docutils literal"><span class="pre">print_results(fit,</span> <span class="pre">prior,</span> <span class="pre">data)</span></code>: for
example,</p>
<div class="highlight-default"><div class="highlight"><pre><span class="k">def</span> <span class="nf">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>                              <span class="c"># array of a[i]s</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span>                              <span class="c"># array of b[i]s</span>
    <span class="n">dE</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;dE&#39;</span><span class="p">]</span>                            <span class="c"># array of dE[i]s</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dE</span><span class="p">)</span>                           <span class="c"># array of E[i]s</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;Best fit values:)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;     a[0] =&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;     b[0] =&#39;</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;     E[0] =&#39;</span><span class="p">,</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;b[0]/a[0] =&#39;</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;E0&#39;</span><span class="p">:</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;a0&#39;</span><span class="p">:</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;b0&#39;</span><span class="p">:</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;b0/a0&#39;</span><span class="p">:</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;a&#39;</span><span class="o">=</span><span class="n">prior</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">],</span> <span class="s">&#39;b&#39;</span><span class="o">=</span><span class="n">prior</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">],</span> <span class="s">&#39;dE&#39;</span><span class="o">=</span><span class="n">prior</span><span class="p">[</span><span class="s">&#39;dE&#39;</span><span class="p">],</span>
              <span class="s">&#39;data&#39;</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">fmt_errorbudget</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span>
</pre></div>
</div>
<p>The best-fit values from the fit are contained in <code class="docutils literal"><span class="pre">fit.p</span></code> and are accessed
using the labels defined in the prior and the <a class="reference internal" href="#corrfitter.Corr2" title="corrfitter.Corr2"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr2</span></code></a> models. Variables like
<code class="docutils literal"><span class="pre">a[0]</span></code> and <code class="docutils literal"><span class="pre">E[0]</span></code> are <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code> objects that contain means and standard
deviations, as well as information about any correlations that might exist
between different variables (which is relevant for computing functions of the
parameters, like <code class="docutils literal"><span class="pre">b[0]/a[0]</span></code> in this example).</p>
<p>The last line of <code class="docutils literal"><span class="pre">print_results(fit,prior,data)</span></code> prints an error budget for
each of the best-fit results for <code class="docutils literal"><span class="pre">a[0]</span></code>, <code class="docutils literal"><span class="pre">b[0]</span></code>, <code class="docutils literal"><span class="pre">E[0]</span></code> and
<code class="docutils literal"><span class="pre">b[0]/a[0]</span></code>, which are identified in the print output by the labels
<code class="docutils literal"><span class="pre">'a0'</span></code>, <code class="docutils literal"><span class="pre">'b0'</span></code>, <code class="docutils literal"><span class="pre">'E0'</span></code> and <code class="docutils literal"><span class="pre">'b0/a0'</span></code>, respectively. The error for any
fit result comes from uncertainties in the inputs — in particular, from the
fit data and the priors. The error budget breaks the total error for a
result down into the components coming from each source. Here the sources are
the <em>a priori</em> errors in the priors for the <code class="docutils literal"><span class="pre">'a'</span></code> amplitudes, the <code class="docutils literal"><span class="pre">'b'</span></code>
amplitudes, and the <code class="docutils literal"><span class="pre">'dE'</span></code> energy differences, as well as the errors in
the fit data <code class="docutils literal"><span class="pre">data</span></code>. These sources are labeled in the print output by
<code class="docutils literal"><span class="pre">'a'</span></code>, <code class="docutils literal"><span class="pre">'b'</span></code>, <code class="docutils literal"><span class="pre">'dE'</span></code>, and <code class="docutils literal"><span class="pre">'data'</span></code>, respectively. (See the
<code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code>/<code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code> tutorial for further details on partial standard
deviations and <code class="xref py py-func docutils literal"><span class="pre">gvar.fmt_errorbudget()</span></code>.)</p>
<p>Plots of the fit data divided by the fit function, for each correlator, are
displayed by calling <code class="docutils literal"><span class="pre">fit.show_plots()</span></code> provided the <code class="xref py py-mod docutils literal"><span class="pre">matplotlib</span></code>
module is present.</p>
</div>
</div>
<div class="section" id="faster-fits">
<span id="id2"></span><h2>Faster Fits<a class="headerlink" href="#faster-fits" title="Permalink to this headline">¶</a></h2>
<p>Good fits often require fit functions with several exponentials and many
parameters. Such fits can be costly. One strategy that can speed things up is
to use fits with fewer terms to generate estimates for the most important
parameters. These estimates are then used as starting values for the full
fit. The smaller fit is usually faster, because it has fewer parameters, but
the fit is not adequate (because there are too few parameters). Fitting the
full fit function is usually faster given reasonable starting estimates, from
the smaller fit, for the most important parameters. Continuing with the
example from the previous section, the code</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">)</span>
<span class="n">fitter</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">make_models</span><span class="p">())</span>
<span class="n">p0</span> <span class="o">=</span> <span class="k">None</span>
<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]:</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>
    <span class="n">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">pmean</span>
</pre></div>
</div>
<p>does fits using fit functions with <code class="docutils literal"><span class="pre">N=1...8</span></code> terms. Parameter mean-values
<code class="docutils literal"><span class="pre">fit.pmean</span></code> from the fit with <code class="docutils literal"><span class="pre">N</span></code> exponentials are used as starting values
<code class="docutils literal"><span class="pre">p0</span></code> for the fit with <code class="docutils literal"><span class="pre">N+1</span></code> exponentials, hopefully reducing the time
required to find the best fit for <code class="docutils literal"><span class="pre">N+1</span></code>.</p>
</div>
<div class="section" id="faster-fits-postive-parameters">
<span id="positive-parameters"></span><h2>Faster Fits — Postive Parameters<a class="headerlink" href="#faster-fits-postive-parameters" title="Permalink to this headline">¶</a></h2>
<p>Priors used in <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> assign an <em>a priori</em> Gaussian/normal distribution
to each parameter. It is possible instead to assign a log-normal distribution,
which forces the corresponding parameter to be positive.  Consider, for
example, energy parameters labeled by <code class="docutils literal"><span class="pre">'dE'</span></code> in the definition of a model
(<em>e.g.</em>, <code class="docutils literal"><span class="pre">Corr2(dE='dE',...)</span></code>). To assign log-normal distributions to these
parameters, include their logarithms in the prior and label the logarithms
with <code class="docutils literal"><span class="pre">'log(dE)'</span></code>: for
example, in <code class="docutils literal"><span class="pre">make_prior(N)</span></code> use</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(dE)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.25(25)&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p>instead of <code class="docutils literal"><span class="pre">prior['dE']</span> <span class="pre">=</span> <span class="pre">gv.gvar(N</span> <span class="pre">*</span> <span class="pre">['0.25(25)'])</span></code>. The
fitter then uses the logarithms as the fit parameters. The original  <code class="docutils literal"><span class="pre">'dE'</span></code>
parameters are recovered (automatically) inside the fit function from
exponentials of the <code class="docutils literal"><span class="pre">'log(dE)'</span></code> fit parameters.</p>
<p>Using log-normal distributions where possible can significantly improve the
stability of a fit. This is because otherwise the fit function typically has
many symmetries that lead to large numbers of equivalent but different best
fits. For example, the fit functions <code class="docutils literal"><span class="pre">Gaa(t,N)</span></code> and <code class="docutils literal"><span class="pre">Gab(t,N)</span></code> above are
unchanged by exchanging <code class="docutils literal"><span class="pre">a[i]</span></code>, <code class="docutils literal"><span class="pre">b[i]</span></code> and <code class="docutils literal"><span class="pre">E[i]</span></code> with <code class="docutils literal"><span class="pre">a[j]</span></code>,
<code class="docutils literal"><span class="pre">b[j]</span></code> and <code class="docutils literal"><span class="pre">E[j]</span></code> for any <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">j</span></code>. We can remove this degeneracy
by using a log-normal distribution for the <code class="docutils literal"><span class="pre">dE[i]</span></code>s since this guarantees
that all <code class="docutils literal"><span class="pre">dE[i]</span></code>s are positive, and therefore that <code class="docutils literal"><span class="pre">E[0],E[1],E[2]...</span></code>
are ordered (in decreasing order of importance to the fit at large <code class="docutils literal"><span class="pre">t</span></code>).</p>
<p>Another symmetry of <code class="docutils literal"><span class="pre">Gaa</span></code> and <code class="docutils literal"><span class="pre">Gab</span></code>, which leaves both fit functions
unchanged, is replacing <code class="docutils literal"><span class="pre">a[i],b[i]</span></code> by <code class="docutils literal"><span class="pre">-a[i],-b[i]</span></code>. Yet another is to
add a new term to the fit functions with <code class="docutils literal"><span class="pre">a[k],b[k],dE[k]</span></code> where <code class="docutils literal"><span class="pre">a[k]=0</span></code>
and the other two have arbitrary values. Both of these symmetries can be
removed by using a log-normal distribution for the <code class="docutils literal"><span class="pre">a[i]</span></code> priors, thereby
forcing all <code class="docutils literal"><span class="pre">a[i]&gt;0</span></code>.</p>
<p>The log-normal distributions for the <code class="docutils literal"><span class="pre">a[i]</span></code> and <code class="docutils literal"><span class="pre">dE[i]</span></code> are introduced
into the code example above by changing the corresponding labels in
<code class="docutils literal"><span class="pre">make_prior(N)</span></code>,  and taking logarithms of the corresponding prior values:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">corrfitter</span> <span class="k">as</span> <span class="nn">cf</span>

<span class="k">def</span> <span class="nf">make_models</span><span class="p">():</span>                          <span class="c"># same as before</span>
    <span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">cf</span><span class="o">.</span><span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gaa&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">63</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">),</span>
        <span class="n">cf</span><span class="o">.</span><span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gab&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">63</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">models</span>

<span class="k">def</span> <span class="nf">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(a)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.1(5)&#39;</span><span class="p">]))</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;1(5)&#39;</span><span class="p">])</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(dE)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.25(25)&#39;</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">prior</span>
</pre></div>
</div>
<p>This replaces the original fit parameters, <code class="docutils literal"><span class="pre">a[i]</span></code> and <code class="docutils literal"><span class="pre">dE[i]</span></code>, by new fit
parameters, <code class="docutils literal"><span class="pre">log(a)[i]</span></code> and <code class="docutils literal"><span class="pre">log(dE)[i]</span></code>. The <em>a priori</em> distributions for
the logarithms are Gaussian/normal, with priors of <code class="docutils literal"><span class="pre">log(0.1±0.5)</span></code> and
<code class="docutils literal"><span class="pre">log(0.25±0.25)</span></code> for the <code class="docutils literal"><span class="pre">log(a)</span></code>s and <code class="docutils literal"><span class="pre">log(dE)</span></code>s respectively.</p>
<p>Note that the labels are unchanged here in <code class="docutils literal"><span class="pre">make_models()</span></code>. It is
unnecessary to change labels in the models; <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> will automatically
connect the  modified terms in the prior with the appropriate terms in the
models. This allows one to switch back and forth between log-normal and normal
distributions without changing the models (or any other code) — only the
names in the prior need be changed. <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> also supports “sqrt-normal”
distributions, and other distributions, as discussed in the <code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code>
documentation.</p>
<p>Finally note that another option for stabilizings fits involving many
sources and sinks is to generate priors for the
fit amplitudes and energies using <a class="reference internal" href="#corrfitter.EigenBasis" title="corrfitter.EigenBasis"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.EigenBasis</span></code></a>.</p>
</div>
<div class="section" id="faster-fits-marginalization">
<span id="marginalized-fits"></span><h2>Faster Fits — Marginalization<a class="headerlink" href="#faster-fits-marginalization" title="Permalink to this headline">¶</a></h2>
<p>Often we care only about parameters in the leading term of the fit function,
or just a few of the leading terms. The non-leading terms are needed for a
good fit, but we are uninterested in the values of their parameters. In such
cases the non-leading terms can be absorbed into the fit data, leaving behind
only the leading terms to be fit (to the modified fit data) — non-leading
parameters are, in effect, integrated out of the analysis, or <em>marginalized</em>.
The errors in the modified data are adjusted to account for uncertainties in
the marginalized terms, as specified by their priors. The resulting fit
function has many fewer parameters, and so the fit can be much faster.</p>
<p>Continuing with the example in <a class="reference internal" href="#faster-fits"><span class="std std-ref">Faster Fits</span></a>, imagine that <code class="docutils literal"><span class="pre">Nmax=8</span></code>
terms are needed to get a good fit, but we only care about parameter values
for the first couple of terms. The code from that section can be modified to
fit only the leading <code class="docutils literal"><span class="pre">N</span></code> terms where <code class="docutils literal"><span class="pre">N&lt;Nmax</span></code>, while incorporating
(marginalizing) the remaining, non-leading terms as corrections to the data:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Nmax</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">)</span>
<span class="n">models</span> <span class="o">=</span> <span class="n">make_models</span><span class="p">()</span>
<span class="n">fitter</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">make_models</span><span class="p">())</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">Nmax</span><span class="p">)</span>        <span class="c"># build priors for Nmax terms</span>
<span class="n">p0</span> <span class="o">=</span> <span class="k">None</span>
<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>               <span class="c"># fit N terms</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">nterm</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
    <span class="n">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">pmean</span>
</pre></div>
</div>
<p>Here the <code class="docutils literal"><span class="pre">nterm</span></code> parameter in <code class="docutils literal"><span class="pre">fitter.lsqfit</span></code> specifies how many terms are
used in the fit functions. The prior specifies <code class="docutils literal"><span class="pre">Nmax</span></code> terms in all, but only
parameters in <code class="docutils literal"><span class="pre">nterm=N</span></code> terms are varied in the fit. The remaining terms
specified by the prior are automatically incorporated into the fit data by
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a>.</p>
<p>Remarkably this method is usually as accurate with <code class="docutils literal"><span class="pre">N=1</span></code> or <code class="docutils literal"><span class="pre">2</span></code> as a full
<code class="docutils literal"><span class="pre">Nmax</span></code>-term fit with the original fit data; but it is much faster. If this
is not the case, check for singular priors, where the mean is much smaller
than the standard deviation. These can lead to singularities in the covariance
matrix for the corrected fit data. Such priors are easily fixed: for example,
use <code class="docutils literal"><span class="pre">gvar.gvar('0.1(1.0)')</span></code> rather than <code class="docutils literal"><span class="pre">gvar.gvar('0(1)')</span></code>.
In some situations an SVD cut (see below) can also
help.</p>
</div>
<div class="section" id="faster-fits-chained-fits">
<span id="chained-fits"></span><h2>Faster Fits — Chained Fits<a class="headerlink" href="#faster-fits-chained-fits" title="Permalink to this headline">¶</a></h2>
<p>Large complicated fits, where lots of models and data are fit simultaneously,
can  take a very long time. This is especially true if there are strong
correlations in the data. Such correlations can also cause  problems from
numerical roundoff errors when the inverse of the data’s covariance matrix is
computed for the <img class="math" src="_images/math/c3009dc638909a74a78a7f5fee27f154c33da1eb.png" alt="\chi^2" style="vertical-align: -4px"/> function, requiring large SVD cuts which can
degrade precision (see below). An alternative approach is to use <em>chained</em>
fits.  In a chained fit, each model is fit by itself in sequence, but with the
best-fit parameters from each fit serving as priors for fit parameters in  the
next fit. All parameters from one fit become fit parameters in the next,
including those parameters that are  not explicitly needed by the next fit
(since they may be correlated with the input data for the next fit or with its
priors). Statistical  correlations between data/priors from different models
are preserved  throughout (approximately).</p>
<p>The results from a chained fit are identical to a standard simultaneous fit in
the limit of large statistics (that is, in the Gaussian limit), but a  chained
fit usually involves fitting only a single correlator at a time.
Single-correlator fits are typically much faster than simultaneous
multi-correlator
fits, and roundoff errors (and therefore SVD cuts) are much less of a
problem.</p>
<p>Converting to chained fits is trivial: simply replace <code class="docutils literal"><span class="pre">fit</span> <span class="pre">=</span> <span class="pre">fitter.lsqfit(...)</span></code>
by <code class="docutils literal"><span class="pre">fit</span> <span class="pre">=</span> <span class="pre">fitter.chained_lsqfit(...)</span></code>. The output from this function
comes from the last fit in the chain, whose fit results represent the
cummulative results of the entire chain of fits.
Results from the different links in
the chain — that is, from the fits for individual models — are
displayed using <code class="docutils literal"><span class="pre">print(fit.formatall())</span></code>.</p>
<p>There are various ways of chaining fits. For example, setting</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="p">(</span><span class="n">m3a</span><span class="p">,</span> <span class="n">m3b</span><span class="p">),</span> <span class="n">m4</span><span class="p">]</span>
</pre></div>
</div>
<p>causes models <code class="docutils literal"><span class="pre">m1</span></code>, <code class="docutils literal"><span class="pre">m2</span></code> and <code class="docutils literal"><span class="pre">m4</span></code> to be fit separately, but fits models
<code class="docutils literal"><span class="pre">m3a</span></code> and <code class="docutils literal"><span class="pre">m3b</span></code> together in a single simultaneous fit:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">m1</span> <span class="o">-&gt;</span> <span class="n">m2</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">simultaneous</span> <span class="n">fit</span> <span class="n">of</span> <span class="n">m3a</span><span class="p">,</span> <span class="n">m3b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m4</span>
</pre></div>
</div>
<p>Simultaneous fits make sense when there is lots of overlap between the
parameters for the different models.</p>
<p>Another option is</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="p">[</span><span class="n">m3a</span><span class="p">,</span><span class="n">m3b</span><span class="p">],</span> <span class="n">m4</span><span class="p">]</span>
</pre></div>
</div>
<p>in <code class="docutils literal"><span class="pre">fitter.chained_lsqfit</span></code> which causes
the following chain of fits:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">m1</span> <span class="o">-&gt;</span> <span class="n">m2</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">parallel</span> <span class="n">fit</span> <span class="n">of</span> <span class="n">m3a</span><span class="p">,</span> <span class="n">m3b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m4</span>
</pre></div>
</div>
<p>Here the output from <code class="docutils literal"><span class="pre">m1</span></code> is used in the prior for fit <code class="docutils literal"><span class="pre">m2</span></code>, and the
output from <code class="docutils literal"><span class="pre">m2</span></code> is used as the prior for a parallel fit of <code class="docutils literal"><span class="pre">m3a</span></code>
and <code class="docutils literal"><span class="pre">m3b</span></code> together — that is, <code class="docutils literal"><span class="pre">m3a</span></code> and <code class="docutils literal"><span class="pre">m3b</span></code> are not chained,
but rather are fit in parallel with each using a prior from fit <code class="docutils literal"><span class="pre">m2</span></code>. The
result of the parallel fit of <code class="docutils literal"><span class="pre">[m3a,m3b]</span></code> is used as the prior for <code class="docutils literal"><span class="pre">m4</span></code>.
Parallel fits make sense when there is little overlap between the parameters
used by the different fits.</p>
</div>
<div class="section" id="faster-fits-faster-fitters">
<h2>Faster Fits — Faster Fitters<a class="headerlink" href="#faster-fits-faster-fitters" title="Permalink to this headline">¶</a></h2>
<p>When fits take many iterations to converge (or converge to an obviously wrong
result), it is worthwhile trying a
different fitter. The <code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code> module, which is used by
<a class="reference internal" href="#module-corrfitter" title="corrfitter: Least-Squares Fit to Correlators."><code class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></code></a> for fitting, offers a variety of alternative
fitting algorithms that can sometimes be much faster (2 or 3 times
faster). These are deployed by adding extra directives for <code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code>
when constructing the fitter or when doing the fit: for example,</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">corrfitter</span> <span class="k">as</span> <span class="nn">cf</span>

<span class="n">fitter</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">CorrFitter</span><span class="p">(</span>
    <span class="n">models</span><span class="o">=</span><span class="n">make_models</span><span class="p">(),</span>
    <span class="n">fitter</span><span class="o">=</span><span class="s">&#39;gsl_multifit&#39;</span><span class="p">,</span> <span class="n">alg</span><span class="o">=</span><span class="s">&#39;subspace2D&#39;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s">&#39;cholesky&#39;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>uses the <code class="docutils literal"><span class="pre">subspace2D</span></code> algorithm for subsequent fits with <code class="docutils literal"><span class="pre">fitter</span></code>. It
is also possible to reset the default algorithms for all fits:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">lsqfit</span>

<span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
    <span class="n">fitter</span><span class="o">=</span><span class="s">&#39;gsl_multifit&#39;</span><span class="p">,</span> <span class="n">alg</span><span class="o">=</span><span class="s">&#39;subspace2D&#39;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s">&#39;cholesky&#39;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>The documentation for <code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code> describes many more options.</p>
</div>
<div class="section" id="faster-fits-processed-datasets">
<span id="processed-datasets"></span><h2>Faster Fits — Processed Datasets<a class="headerlink" href="#faster-fits-processed-datasets" title="Permalink to this headline">¶</a></h2>
<p>When fitting very large data sets, it is usually worthwhile to pare the data
down to the smallest subset that is needed for the fit. Ideally this is done
before the Monte Carlo data are averaged, to keep the size of the covariance
matrix down. One way to do this is to process the Monte Carlo data with the
models, just before averaging it, by using</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">corrfitter</span> <span class="k">as</span> <span class="nn">cf</span>

<span class="k">def</span> <span class="nf">make_pdata</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">models</span><span class="p">):</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read_dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cf</span><span class="o">.</span><span class="n">process_dataset</span><span class="p">(</span><span class="n">dset</span><span class="p">,</span> <span class="n">models</span><span class="p">)</span>
</pre></div>
</div>
<p>in place of <code class="docutils literal"><span class="pre">make_data(filename)</span></code>. Here <code class="docutils literal"><span class="pre">models</span></code> is the list
of models used by the fitter (<code class="docutils literal"><span class="pre">fitter.models</span></code>). Function <code class="docutils literal"><span class="pre">make_pdata</span></code>
returns processed data which is passed to <code class="docutils literal"><span class="pre">fitter.lsqfit</span></code> using
the <code class="docutils literal"><span class="pre">pdata</span></code> keyword:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">corrfitter</span> <span class="k">as</span> <span class="nn">cf</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">models</span> <span class="o">=</span> <span class="n">make_models</span><span class="p">()</span>
    <span class="n">pdata</span> <span class="o">=</span> <span class="n">make_pdata</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">,</span> <span class="n">models</span><span class="p">)</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">fitter</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">)</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">pdata</span><span class="o">=</span><span class="n">pdata</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
    <span class="n">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">pdata</span><span class="p">)</span>

<span class="o">...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>Processed data can only be used with the models that created it, so
parameters in those models should not be changed after the data is
processed.</p>
</div>
<div class="section" id="accurate-fits-svd-cuts">
<span id="svd-cuts"></span><h2>Accurate Fits — SVD Cuts<a class="headerlink" href="#accurate-fits-svd-cuts" title="Permalink to this headline">¶</a></h2>
<p>A key feature of <a class="reference internal" href="#module-corrfitter" title="corrfitter: Least-Squares Fit to Correlators."><code class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></code></a> is its ability to fit multiple correlators
simultaneously, taking account of the statistical correlations between
correlators at different times and between
different correlators. Information about the correlations typically comes from
Monte Carlo samples of the correlators. Problems arise, however, when the
number <img class="math" src="_images/math/9ba7b5bdc8a670f44aae1154ae53f027ad35781c.png" alt="N_s" style="vertical-align: -3px"/> of samples is not much larger than
the number <img class="math" src="_images/math/0ecdb5b3af198a718e6efdf57f4c369fb3df2777.png" alt="N_d" style="vertical-align: -3px"/> of data points being fit. Specifically the smallest
eigenvalues of the correlation matrix can be substantially underestimated if
<img class="math" src="_images/math/9ba7b5bdc8a670f44aae1154ae53f027ad35781c.png" alt="N_s" style="vertical-align: -3px"/> is not sufficiently large (10 or 100 times larger than <img class="math" src="_images/math/0ecdb5b3af198a718e6efdf57f4c369fb3df2777.png" alt="N_d" style="vertical-align: -3px"/>).
Indeed there must be <img class="math" src="_images/math/5b24b9f1b117f884a7316994385cf289bb50bffb.png" alt="N_d-N_s" style="vertical-align: -3px"/> zero eigenvalues
when <img class="math" src="_images/math/aa1947375ad5bad072c448cc8ed9e33eadc8e0ac.png" alt="N_s\le N_d" style="vertical-align: -3px"/>. The underestimated
(or zero) eigenvalues lead to incorrect and large (or infinite) contributions
to the fit’s <img class="math" src="_images/math/c3009dc638909a74a78a7f5fee27f154c33da1eb.png" alt="\chi^2" style="vertical-align: -4px"/> function, invalidating the fit results.</p>
<p>These problems tend show up as an unexpectedly large <img class="math" src="_images/math/c3009dc638909a74a78a7f5fee27f154c33da1eb.png" alt="\chi^2" style="vertical-align: -4px"/>s,
for example, in fits where the <img class="math" src="_images/math/c3009dc638909a74a78a7f5fee27f154c33da1eb.png" alt="\chi^2" style="vertical-align: -4px"/> per degree of freedom remains
substantially larger than one no matter how many fit terms are
employed. Such situations are usually improved by introducing an
SVD cut:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">svdcut</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>This replaces the smallest eigenvalues of the correlation matrix as needed
so that no eigenvalue is smaller than <code class="docutils literal"><span class="pre">svdcut</span></code> times the largest eigenvalue.
Introducing an SVD cut increases the effective errors and so is a
conservative move.</p>
<p>The method <code class="xref py py-meth docutils literal"><span class="pre">gvar.dataset.svd_diagnoisis()</span></code> in module <code class="xref py py-mod docutils literal"><span class="pre">gvar</span></code> is
useful for assessing whether an SVD cut is needed, and for setting
its value. One way to use it is in the <code class="docutils literal"><span class="pre">make_pdata</span></code>
routine when creating processed data (see <a class="reference internal" href="#processed-datasets"><span class="std std-ref">Faster Fits — Processed Datasets</span></a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">corrfitter</span> <span class="k">as</span> <span class="nn">cf</span>

<span class="n">GENERATE_SVD</span> <span class="o">=</span> <span class="k">True</span>

<span class="k">def</span> <span class="nf">make_pdata</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">models</span><span class="p">):</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">read_dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">pdata</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">process_dataset</span><span class="p">(</span><span class="n">dset</span><span class="p">,</span> <span class="n">models</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">GENERATE_SVD</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">svd_diagnosis</span><span class="p">(</span><span class="n">dset</span><span class="p">,</span> <span class="n">models</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;suggested svdcut =&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">svdcut</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">plot_ratio</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
        <span class="n">svdcut</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">svdcut</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">svdcut</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">return</span> <span class="n">gv</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">svdcut</span><span class="o">=</span><span class="n">svdcut</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">gv.dataset.svd_diagnosis(dset,</span> <span class="pre">models)</span></code> uses a bootstrap
simulation (see <a class="reference internal" href="#bootstrap-analyses"><span class="std std-ref">Bootstrap Analyses</span></a>) to test the reliability
of the eigenvalues determined from the
Monte Carlo data in <code class="docutils literal"><span class="pre">dset</span></code>. It places the SVD cut at the point
where the bootstrapped eigenvalues fall well below the actual values.
A plot showing the ratio of bootstrapped to actual eigenvalues is
displayed by <code class="docutils literal"><span class="pre">s.plot_ratio(show=True)</span></code>. The following are
sample plots from two
otherwise identical simulations of 3 correlators (66 data points in all),
one with 100 configurations and the
other with 10,000 configurations:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img alt="_images/svd-bootstrap-1e2.png" class="first last" src="_images/svd-bootstrap-1e2.png" />
</td>
<td><img alt="_images/svd-bootstrap-1e4.png" class="first last" src="_images/svd-bootstrap-1e4.png" />
</td>
</tr>
</tbody>
</table>
<p>With only 100 configurations, three quarters of the eigenvalues are too
small in the bootstrap simulation, and therefore also
likely too small for the real data. Simulated and actual eigenvalues come into
agreement around 0.1 (red dashed line),
which is the suggested value for <code class="docutils literal"><span class="pre">svdcut</span></code>. With 10,000 configurations,
all of the eigenvalues are robust and no SVD cut is needed. Both data
sets produce good fits (using the appropriate <code class="docutils literal"><span class="pre">svdcut</span></code> for each). The
fits agree with each other, with uncertainties from the high-statistics
case that are 10 times smaller, as expected.</p>
<p>In <code class="docutils literal"><span class="pre">make_pdata()</span></code> above, the SVD cut is applied directly to the
data (<code class="docutils literal"><span class="pre">gv.svd(pdata,</span> <span class="pre">svdcut=svdcut)</span></code>) before it is fit,
and so need not be supplied to the fitter. This is convenient when
using processed data because both the Monte Carlo data (<code class="docutils literal"><span class="pre">dset</span></code>) and
the <a class="reference internal" href="#module-corrfitter" title="corrfitter: Least-Squares Fit to Correlators."><code class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></code></a> models are available.
Another option is to do the SVD diagnosis just before fitting and pass the
value of <code class="docutils literal"><span class="pre">svdcut</span></code> to <a class="reference internal" href="#module-corrfitter" title="corrfitter: Least-Squares Fit to Correlators."><code class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></code></a>.</p>
</div>
<div class="section" id="variations">
<h2>Variations<a class="headerlink" href="#variations" title="Permalink to this headline">¶</a></h2>
<p>A 2-point correlator is turned into a periodic function of <code class="docutils literal"><span class="pre">t</span></code> by
specifying the period through parameter <code class="docutils literal"><span class="pre">tp</span></code>. Doing so causes the
replacement (for <code class="docutils literal"><span class="pre">tp&gt;0</span></code>)</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>   <span class="o">-&gt;</span>   <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">tp</span><span class="o">-</span><span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>in the fit function. If <code class="docutils literal"><span class="pre">tp</span></code> is negative, the function is replaced by
an anti-periodic function with period <code class="docutils literal"><span class="pre">abs(tp)</span></code> and (for <code class="docutils literal"><span class="pre">tp&lt;0</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>   <span class="o">-&gt;</span>   <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span><span class="o">-</span><span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>Also (or alternatively) oscillating terms can be added to the fit by
modifying parameter <code class="docutils literal"><span class="pre">s</span></code> and by specifying sources, sinks and energies for
the oscillating pieces. For example, one might want to replace the sum of
exponentials with two sums</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">sum_i</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">sum_i</span> <span class="n">ao</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">t</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Eo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>in a (nonperiodic) fit function. Then an appropriate model
would be, for example,</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Corr2</span><span class="p">(</span>
    <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gaa&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">63</span><span class="p">,</span>
    <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dE</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span><span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">ao</span></code> and <code class="docutils literal"><span class="pre">dEo</span></code> refer to additional fit parameters describing
the oscillating component. In general parameters for amplitudes and
energies can be tuples with two components: the first describing normal
states, and the second describing oscillating states. To omit one or the
other, put <code class="docutils literal"><span class="pre">None</span></code> in place of a label. Parameter <code class="docutils literal"><span class="pre">s[0]</span></code> is an overall
factor multiplying the non-oscillating terms, and <code class="docutils literal"><span class="pre">s[1]</span></code> is the
corresponding factor for the oscillating terms.</p>
</div>
<div class="section" id="very-fast-but-limited-fits">
<span id="very-fast-fits"></span><h2>Very Fast (But Limited) Fits<a class="headerlink" href="#very-fast-but-limited-fits" title="Permalink to this headline">¶</a></h2>
<p>At large <code class="docutils literal"><span class="pre">t</span></code>, two-point correlators are dominated by the term with the
smallest <code class="docutils literal"><span class="pre">E</span></code>, and often it is only the parameters in that leading term that
are needed. In such cases there is a very fast analysis that is often almost
as accurate as a full fit. Assuming a non-periodic correlator, for example,
we want to calculate energy <code class="docutils literal"><span class="pre">E[0]</span></code> and amplitude <code class="docutils literal"><span class="pre">A[0]</span></code> where:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">G</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">sum_i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>This is done using the following code</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">corrfitter</span> <span class="k">import</span> <span class="n">fastfit</span>

<span class="c"># Gdata = array containing G(t) for t=0,1,2...</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fastfit</span><span class="p">(</span><span class="n">Gdata</span><span class="p">,</span> <span class="n">ampl</span><span class="o">=</span><span class="s">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;0.5(5)&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">&#39;E[0] =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">E</span><span class="p">)</span>                  <span class="c"># E[0]</span>
<span class="nb">print</span><span class="p">(</span><span class="s">&#39;A[0] =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">ampl</span><span class="p">)</span>               <span class="c"># A[0]</span>
<span class="nb">print</span><span class="p">(</span><span class="s">&#39;chi2/dof =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">chi2</span><span class="o">/</span><span class="n">fit</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span> <span class="c"># good fit if of order 1 or less</span>
<span class="nb">print</span><span class="p">(</span><span class="s">&#39;Q =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span>                   <span class="c"># good fit if Q &gt; 0.05-0.1</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">G</span></code> is an array containing a two-point correlator, <code class="docutils literal"><span class="pre">ampl</span></code> is
a prior for the amplitudes <code class="docutils literal"><span class="pre">A[i]</span></code>, <code class="docutils literal"><span class="pre">dE</span></code> is a prior for energy
differences <code class="docutils literal"><span class="pre">E[i]-E[i-1]</span></code>, and <code class="docutils literal"><span class="pre">tmin</span></code> is the minimum time used in
the analysis.</p>
<p><a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><code class="xref py py-class docutils literal"><span class="pre">fastfit</span></code></a> is fast because it does not attempt to determine any
parameters in <code class="docutils literal"><span class="pre">G(t)</span></code> other than <code class="docutils literal"><span class="pre">E[0]</span></code> and <code class="docutils literal"><span class="pre">A[0]</span></code>. It does this
by using the priors for the amplitudes and energy differences
to remove (<em>marginalize</em>) all terms from the correlator other than the
<code class="docutils literal"><span class="pre">E[0]</span></code> term: so the data <code class="docutils literal"><span class="pre">Gdata(t)</span></code> for the correlator are replaced by</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Gdata</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">sum_i</span><span class="o">=</span><span class="mf">1.</span><span class="o">.</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>  <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">A[i]</span></code> and <code class="docutils literal"><span class="pre">E[i]</span></code> for <code class="docutils literal"><span class="pre">i&gt;0</span></code> are replaced by priors given by
<code class="docutils literal"><span class="pre">ampl</span></code> and <code class="docutils literal"><span class="pre">(i+1)</span> <span class="pre">*</span> <span class="pre">dE</span></code>, respectively. The modified correlator is then fit
by a single term, <code class="docutils literal"><span class="pre">A[0]</span> <span class="pre">*</span> <span class="pre">exp(-E[0]*t)</span></code>, which means that a fit is  not
actually necessary since the functional form is so simple.  <a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><code class="xref py py-class docutils literal"><span class="pre">fastfit</span></code></a>
averages estimates for <code class="docutils literal"><span class="pre">E[0]</span></code> and <code class="docutils literal"><span class="pre">A[0]</span></code> from all <code class="docutils literal"><span class="pre">t</span></code>s larger than
<code class="docutils literal"><span class="pre">tmin</span></code>. It is important to verify that these estimates agree  with each
other, by checking the <img class="math" src="_images/math/c3009dc638909a74a78a7f5fee27f154c33da1eb.png" alt="\chi^2" style="vertical-align: -4px"/> of the average. Try increasing <code class="docutils literal"><span class="pre">tmin</span></code> if
the <img class="math" src="_images/math/c3009dc638909a74a78a7f5fee27f154c33da1eb.png" alt="\chi^2" style="vertical-align: -4px"/> is too large; or introduce an SVD cut.</p>
<p>The energies from <a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><code class="xref py py-class docutils literal"><span class="pre">fastfit</span></code></a> are closely related to standard <em>effective
masses</em>. The key difference is <a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><code class="xref py py-class docutils literal"><span class="pre">fastfit</span></code></a>’s marginalization of terms
from excited states (<code class="docutils literal"><span class="pre">i&gt;0</span></code> above). This allows <a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><code class="xref py py-class docutils literal"><span class="pre">fastfit</span></code></a> to use
information from much smaller <code class="docutils literal"><span class="pre">t</span></code>s than otherwise, increasing precision. It
also quantifies the uncertainty caused by the existence of excited states,
and gives a simple criterion for how small <code class="docutils literal"><span class="pre">tmin</span></code> can be (the <img class="math" src="_images/math/c3009dc638909a74a78a7f5fee27f154c33da1eb.png" alt="\chi^2" style="vertical-align: -4px"/>).
Results are typically as accurate as results obtained from a full
multi-exponential fit that uses the same priors for <code class="docutils literal"><span class="pre">A[i]</span></code> and <code class="docutils literal"><span class="pre">E[i]</span></code>,
and the same <code class="docutils literal"><span class="pre">tmin</span></code>. <a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><code class="xref py py-class docutils literal"><span class="pre">fastfit</span></code></a> can also be used for periodic and
anti-periodic correlators, as well as for correlators that contain terms that
oscillate in sign from  one <code class="docutils literal"><span class="pre">t</span></code> to the next.</p>
<p><a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><code class="xref py py-class docutils literal"><span class="pre">fastfit</span></code></a>  is a special
case of the more general marginalization strategy discussed in
<a class="reference internal" href="#faster-fits"><span class="std std-ref">Faster Fits</span></a>, above.</p>
</div>
<div class="section" id="point-correlators">
<h2>3-Point Correlators<a class="headerlink" href="#point-correlators" title="Permalink to this headline">¶</a></h2>
<p>Correlators <code class="docutils literal"><span class="pre">Gavb(t,T)</span> <span class="pre">=</span> <span class="pre">&lt;b(T)</span> <span class="pre">V(t)</span> <span class="pre">a(0)&gt;</span></code> can also be included in fits
as functions of <code class="docutils literal"><span class="pre">t</span></code>. In the illustration above, for example, we might
consider additional Monte Carlo data describing a form factor with the
same intermediate states before and after <code class="docutils literal"><span class="pre">V(t)</span></code>. Assuming the data is
tagged by <code class="docutils literal"><span class="pre">aVbT15</span></code> and describes <code class="docutils literal"><span class="pre">T=15</span></code>, the corresponding entry in the
collection of models might then be:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Corr3</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;aVbT15&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
    <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span>                <span class="c"># parameters for V</span>
    <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">dEa</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">,</span>          <span class="c"># parameters for a-&gt;V</span>
    <span class="n">b</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">dEb</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">,</span>          <span class="c"># parameters for V-&gt;b</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>This models the Monte Carlo data for the 3-point function using the
following formula:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">sum_i</span><span class="p">,</span><span class="n">j</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Ea</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">Vnn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">Eb</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>where the <code class="docutils literal"><span class="pre">Vnn[i,j]</span></code>s are new fit parameters related to <code class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></code> form
factors. Obviously multiple values of <code class="docutils literal"><span class="pre">T</span></code> can be studied by including
multiple <a class="reference internal" href="#corrfitter.Corr3" title="corrfitter.Corr3"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr3</span></code></a> models, one for each value of <code class="docutils literal"><span class="pre">T</span></code>. Either or both of the
initial and final states can have oscillating components (include <code class="docutils literal"><span class="pre">sa</span></code>
and/or <code class="docutils literal"><span class="pre">sb</span></code>). If
there are oscillating states then additional <code class="docutils literal"><span class="pre">V</span></code>s must be specified:
<code class="docutils literal"><span class="pre">Vno</span></code> connecting a normal state to an oscillating state, <code class="docutils literal"><span class="pre">Von</span></code>
connecting oscillating to normal states, and <code class="docutils literal"><span class="pre">Voo</span></code> connecting oscillating
to oscillating states.</p>
<p>Keywords <code class="docutils literal"><span class="pre">tdata</span></code> and <code class="docutils literal"><span class="pre">tfit</span></code> need not be specified when
there is data for every <code class="docutils literal"><span class="pre">t=0,1...T</span></code>: for example,</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Corr3</span><span class="p">(</span>
    <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;aVbT15&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">dEa</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">dEb</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>is equivalent to the definition above.</p>
<p>There are two cases that require special treatment. One is when
simultaneous fits are made to <code class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></code> and <code class="docutils literal"><span class="pre">b-&gt;V-&gt;a</span></code>. Then the
<code class="docutils literal"><span class="pre">Vnn</span></code>, <code class="docutils literal"><span class="pre">Vno</span></code>, <em>etc.</em> for <code class="docutils literal"><span class="pre">b-&gt;V-&gt;a</span></code> are the (matrix) transposes of
the the same matrices for <code class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></code>. In this case the models for the two
would look something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">...</span>
    <span class="n">Corr3</span><span class="p">(</span>
        <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;aVbT15&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span><span class="p">,</span> <span class="n">Von</span><span class="o">=</span><span class="s">&#39;Von&#39;</span><span class="p">,</span> <span class="n">Voo</span><span class="o">=</span><span class="s">&#39;Voo&#39;</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEa</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span><span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sa</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="c"># a-&gt;V</span>
        <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;bo&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span><span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sb</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># V-&gt;b</span>
        <span class="p">),</span>
    <span class="n">Corr3</span><span class="p">(</span>
        <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;bVaT15&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="k">True</span><span class="p">,</span>
        <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span><span class="p">,</span> <span class="n">Von</span><span class="o">=</span><span class="s">&#39;Von&#39;</span><span class="p">,</span> <span class="n">Voo</span><span class="o">=</span><span class="s">&#39;Voo&#39;</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEa</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span><span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sa</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="c"># a-&gt;V</span>
        <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;bo&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span><span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sb</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># V-&gt;b</span>
        <span class="p">),</span>
    <span class="o">...</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>The second <code class="docutils literal"><span class="pre">Corr3</span></code> is identical to the first except for the
datatag (<code class="docutils literal"><span class="pre">'bVaT15'</span></code>), and the keyword <code class="docutils literal"><span class="pre">reverse=True</span></code>, which
instructs the model to time-reverse its data, interchanging
<code class="docutils literal"><span class="pre">t=0</span></code> with <code class="docutils literal"><span class="pre">t=T</span></code>, before fitting. Time-reversing in
effect turns <code class="docutils literal"><span class="pre">b-&gt;V-&gt;a</span></code> into <code class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></code>.</p>
<p>Another way to handle this last situation is to average the data
from <code class="docutils literal"><span class="pre">b-&gt;V-&gt;a</span></code> with that from <code class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></code> for a single fit. This
is done using one <code class="docutils literal"><span class="pre">Corr3</span></code> but with the keyword <code class="docutils literal"><span class="pre">reverseddata</span></code>
to indicate the data to be time-reversed and then averaged with the
<code class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></code> data:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">...</span>
    <span class="n">Corr3</span><span class="p">(</span>
        <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;aVbT15&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">reverseddata</span><span class="o">=</span><span class="s">&#39;bVaT15&#39;</span><span class="p">,</span>
        <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span><span class="p">,</span> <span class="n">Von</span><span class="o">=</span><span class="s">&#39;Von&#39;</span><span class="p">,</span> <span class="n">Voo</span><span class="o">=</span><span class="s">&#39;Voo&#39;</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEa</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span><span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sa</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="c"># a-&gt;V</span>
        <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;bo&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span><span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sb</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># V-&gt;b</span>
        <span class="p">),</span>
    <span class="o">...</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>The second special case is for fits to <code class="docutils literal"><span class="pre">a-&gt;V-&gt;a</span></code> where the initial and final
particles are the same (with the same momentum). In that case, <code class="docutils literal"><span class="pre">Vnn</span></code> and
<code class="docutils literal"><span class="pre">Voo</span></code> are symmetric matrices, and <code class="docutils literal"><span class="pre">Von</span></code> is the transpose of <code class="docutils literal"><span class="pre">Vno</span></code>. The
model for such a case would look like, for example:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Corr3</span><span class="p">(</span>
    <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;aVbT15&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span><span class="p">,</span> <span class="n">Voo</span><span class="o">=</span><span class="s">&#39;Voo&#39;</span><span class="p">,</span> <span class="n">symmetric_V</span><span class="o">=</span><span class="k">True</span><span class="p">,</span>
    <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEa</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sa</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="c"># a-&gt;V</span>
    <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sb</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># V-&gt;a</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Here only <code class="docutils literal"><span class="pre">Vno</span></code> is specified, since <code class="docutils literal"><span class="pre">Von</span></code> is its transpose.
Furthermore <code class="docutils literal"><span class="pre">Vnn</span></code> and <code class="docutils literal"><span class="pre">Voo</span></code> are (square) symmetric matrices when
<code class="docutils literal"><span class="pre">symmetric_V==True</span></code> and so only the upper part of each matrix is needed.
In this case <code class="docutils literal"><span class="pre">Vnn</span></code> and <code class="docutils literal"><span class="pre">Voo</span></code> are treated as one-dimensional arrays with
<code class="docutils literal"><span class="pre">N(N+1)/2</span></code> elements corresponding to the upper parts of each matrix,
where <code class="docutils literal"><span class="pre">N</span></code> is the number of exponentials (that is, the number of
<code class="docutils literal"><span class="pre">a[i]</span></code>s).</p>
</div>
<div class="section" id="testing-fits-with-simulated-data">
<h2>Testing Fits with Simulated Data<a class="headerlink" href="#testing-fits-with-simulated-data" title="Permalink to this headline">¶</a></h2>
<p>Large fits are complicated and often involve nontrivial choices about
algorithms (<em>e.g.</em>, chained fits versus regular fits), priors, and
SVD cuts — choices that affect the values and errors for the fit
parameters. In such situations it is often a good idea to test the
fit protocol that has been selected. This can be done by fitting simulated
data. Simulated data looks almost identical to the original fit
data but has means that have been adjusted to correspond to fluctuations
around a correlator with known (before the fit) parameter values: <code class="docutils literal"><span class="pre">p=pexact</span></code>.
The <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> iterator <code class="docutils literal"><span class="pre">simulated_pdata_iter</span></code> creates any number of
different simulated data sets of this kind. Fitting any of these with
a particular fit protocol tests the reliability of that protocol since
the fit results should agree with <code class="docutils literal"><span class="pre">pexact</span></code>
to within the (simulated) fit’s errors. One or two fit simulations of this
sort are usually enough to establish the validity of a protocol. It is also
easy to compare the performance of different fit options by applying these in
fits of simulated data, again because we know the correct answers (<code class="docutils literal"><span class="pre">pexact</span></code>)
ahead of time.</p>
<p>Typically one obtains reasonable values for <code class="docutils literal"><span class="pre">pexact</span></code> from a fit to the
real data. Assuming these have been dumped into a file named <code class="docutils literal"><span class="pre">&quot;pexact_file&quot;</span></code>
(using, for example, <code class="docutils literal"><span class="pre">fit.dump_pmean(&quot;pexact_file&quot;)</span></code>), a testing script
might look something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">lsqfit</span>
<span class="kn">import</span> <span class="nn">corrfitter</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>       <span class="c"># from original fit code</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">fitter</span> <span class="o">=</span> <span class="n">corrfitter</span><span class="o">.</span><span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span> <span class="o">=</span> <span class="n">make_models</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>                                   <span class="c"># number of simulations</span>
    <span class="n">pexact</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="o">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="s">&quot;pexact_file&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">spdata</span> <span class="ow">in</span> <span class="n">fitter</span><span class="o">.</span><span class="n">simulated_pdata_iter</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">pexact</span><span class="o">=</span><span class="n">pexact</span><span class="p">):</span>
        <span class="c"># sfit = fit to the simulated data sdata</span>
        <span class="n">sfit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">pdata</span><span class="o">=</span><span class="n">spdata</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">pexact</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="o">...</span><span class="p">)</span>
        <span class="o">...</span> <span class="n">check</span> <span class="n">that</span> <span class="n">sfit</span><span class="o">.</span><span class="n">p</span> <span class="n">values</span> <span class="n">agree</span> <span class="k">with</span> <span class="n">pexact</span> <span class="n">to</span> <span class="n">within</span> <span class="n">sfit</span><span class="o">.</span><span class="n">psdev</span> <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="bootstrap-analyses">
<span id="id3"></span><h2>Bootstrap Analyses<a class="headerlink" href="#bootstrap-analyses" title="Permalink to this headline">¶</a></h2>
<p>A <em>bootstrap analysis</em> gives more robust error estimates for fit parameters
and functions of fit parameters than the conventional fit when errors are
large, or fluctuations are non-Gaussian. A typical code looks something like:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">gvar.dataset</span> <span class="k">as</span> <span class="nn">ds</span>
<span class="kn">from</span> <span class="nn">corrfitter</span> <span class="k">import</span> <span class="n">CorrFitter</span>
<span class="c"># fit</span>
<span class="n">dset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>            <span class="c"># create fit data</span>
<span class="n">fitter</span> <span class="o">=</span> <span class="n">Corrfitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">make_models</span><span class="p">())</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>                               <span class="c"># number of terms in fit function</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>  <span class="c"># do standard fit</span>
<span class="nb">print</span> <span class="s">&#39;Fit results:&#39;</span>
<span class="nb">print</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>               <span class="c"># fit results for &#39;a&#39; amplitudes</span>
<span class="nb">print</span> <span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;dE&#39;</span><span class="p">]</span>             <span class="c"># fit results for &#39;dE&#39; energies</span>
<span class="o">...</span>
<span class="o">...</span>
<span class="c"># bootstrap analysis</span>
<span class="nb">print</span> <span class="s">&#39;Bootstrap fit results:&#39;</span>
<span class="n">nbootstrap</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c"># number of bootstrap iterations</span>
<span class="n">bs_datalist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">bootstrap_iter</span><span class="p">(</span><span class="n">dset</span><span class="p">,</span> <span class="n">nbootstrap</span><span class="p">))</span>
<span class="n">bs</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>                   <span class="c"># bootstrap output stored in bs</span>
<span class="k">for</span> <span class="n">bs_fit</span> <span class="ow">in</span> <span class="n">fitter</span><span class="o">.</span><span class="n">bootstrap_iter</span><span class="p">(</span><span class="n">bs_datalist</span><span class="p">):</span> <span class="c"># bs_fit = lsqfit output</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">bs_fit</span><span class="o">.</span><span class="n">pmean</span>    <span class="c"># best fit values for current bootstrap iteration</span>
    <span class="n">bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]))</span>         <span class="c"># collect bootstrap results for a[i]</span>
    <span class="n">bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="s">&#39;dE&#39;</span><span class="p">])</span>        <span class="c"># collect results for dE[i]</span>
    <span class="o">...</span>                             <span class="c"># include other functions of p</span>
    <span class="o">...</span>
<span class="n">bs</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">bstrap</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>   <span class="c"># medians + error estimate</span>
<span class="nb">print</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">bs</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>                  <span class="c"># bootstrap result for &#39;a&#39; amplitudes</span>
<span class="nb">print</span> <span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="n">bs</span><span class="p">[</span><span class="s">&#39;dE&#39;</span><span class="p">]</span>                <span class="c"># bootstrap result for &#39;dE&#39; energies</span>
<span class="o">....</span>
</pre></div>
</div>
<p>This code first prints out the standard fit results for the <code class="docutils literal"><span class="pre">'a'</span></code> amplitudes
and <code class="docutils literal"><span class="pre">'dE'</span></code> energies. It then makes <code class="docutils literal"><span class="pre">10</span></code> bootstrap copies of the original
input data, and fits each using the best-fit parameters from the original fit
as the starting point for the bootstrap fit. The variation in the best-fit
parameters from fit to fit is an indication of the uncertainty in those
parameters. This example uses a <code class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></code> object <code class="docutils literal"><span class="pre">bs</span></code> to
accumulate the results from each bootstrap fit, which are computed using the
best-fit values of the parameters (ignoring their standard deviations). Other
functions of the fit parameters could be included as well. At the end
<code class="docutils literal"><span class="pre">avg_data(bs,</span> <span class="pre">bstrap=True)</span></code> finds median values for each quantity in
<code class="docutils literal"><span class="pre">bs</span></code>, as well as a robust estimate of the uncertainty (to within 30% since
<code class="docutils literal"><span class="pre">nbootstrap</span></code> is only <code class="docutils literal"><span class="pre">10</span></code>).</p>
<p>The list of bootstrap data sets <code class="docutils literal"><span class="pre">bs_datalist</span></code> can be omitted in this example
in situations where the input data has high statistics. Then the bootstrap
copies are generated internally by <code class="xref py py-func docutils literal"><span class="pre">fitter.bootstrap_iter()</span></code> from the
means and covariance matrix of the input data (assuming Gaussian statistics).</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>Background information on the some of the fitting strategies used by
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> can be found by doing a web searches for “hep-lat/0110175”,
“arXiv:1111.1363”, and “:arXiv:1406.2279” (appendix). These are papers by
G.P. Lepage and collaborators whose published versions are: G.P. Lepage et al,
Nucl.Phys.Proc.Suppl. 106 (2002) 12-20; K. Hornbostel et al,
Phys.Rev. D85 (2012) 031504; and
C. Bouchard et al, Phys.Rev. D90 (2014) 054506.</p>
</div>
<div class="section" id="correlator-model-objects">
<h2>Correlator Model Objects<a class="headerlink" href="#correlator-model-objects" title="Permalink to this headline">¶</a></h2>
<p>Correlator objects describe theoretical models that are fit to
correlator data by varying the models’ parameters.</p>
<p>A model object’s parameters are specified through priors for the fit. A
model assigns labels to each of its parameters (or arrays of related
parameters), and these labels are used to identify the corresponding
parameters in the prior. Parameters can be shared by more than one model
object.</p>
<p>A model object also specifies the data that it is to model. The data is
identified by the data tag that labels it in the input file or <code class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></code>.</p>
<dl class="class">
<dt id="corrfitter.Corr2">
<em class="property">class </em><code class="descclassname">corrfitter.</code><code class="descname">Corr2</code><span class="sig-paren">(</span><em>datatag</em>, <em>a</em>, <em>b</em>, <em>dE</em>, <em>s=1.0</em>, <em>tp=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>tdata=None</em>, <em>tfit=None</em>, <em>reverse=False</em>, <em>reverseddata=[]</em>, <em>otherdata=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.Corr2" title="Permalink to this definition">¶</a></dt>
<dd><p>Two-point correlators <code class="docutils literal"><span class="pre">Gab(t)</span> <span class="pre">=</span> <span class="pre">&lt;b(t)</span> <span class="pre">a(0)&gt;</span></code>.</p>
<p><a class="reference internal" href="#corrfitter.Corr2" title="corrfitter.Corr2"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr2</span></code></a> models the <code class="docutils literal"><span class="pre">t</span></code> dependence of a 2-point correlator <code class="docutils literal"><span class="pre">Gab(t)</span></code>
using</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Gab</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">sn</span> <span class="o">*</span> <span class="n">sum_i</span> <span class="n">an</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">bn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fn</span><span class="p">(</span><span class="n">En</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
       <span class="o">+</span> <span class="n">so</span> <span class="o">*</span> <span class="n">sum_i</span> <span class="n">ao</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">bo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fo</span><span class="p">(</span><span class="n">Eo</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">sn</span></code> and <code class="docutils literal"><span class="pre">so</span></code> are typically <code class="docutils literal"><span class="pre">-1</span></code>, <code class="docutils literal"><span class="pre">0</span></code>, or <code class="docutils literal"><span class="pre">1</span></code> and</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">fn</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span>  <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="p">(</span><span class="n">tp</span><span class="o">-</span><span class="n">t</span><span class="p">))</span> <span class="c"># tp&gt;0 -- periodic</span>
       <span class="ow">or</span>   <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">tp</span><span class="o">-</span><span class="n">t</span><span class="p">))</span><span class="c"># tp&lt;0 -- anti-periodic</span>
       <span class="ow">or</span>   <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>                  <span class="c"># if tp is None (nonperiodic)</span>

<span class="n">fo</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">t</span> <span class="o">*</span> <span class="n">fn</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>The fit parameters for the non-oscillating piece of <code class="docutils literal"><span class="pre">Gab</span></code> (first term)
are <code class="docutils literal"><span class="pre">an[i]</span></code>, <code class="docutils literal"><span class="pre">bn[i]</span></code>, and <code class="docutils literal"><span class="pre">dEn[i]</span></code> where:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">dEn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">En</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dEn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">En</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">En</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>     <span class="p">(</span><span class="k">for</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>and therefore <code class="docutils literal"><span class="pre">En[i]</span> <span class="pre">=</span> <span class="pre">sum_j=0..i</span> <span class="pre">dEn[j]</span></code>. The fit parameters for
the oscillating piece are defined analogously: <code class="docutils literal"><span class="pre">ao[i]</span></code>, <code class="docutils literal"><span class="pre">bo[i]</span></code>,
and <code class="docutils literal"><span class="pre">dEo[i]</span></code>.</p>
<p>The fit parameters are specified by the keys corresponding to these
parameters in a dictionary of priors supplied to <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a>. The keys
are strings and are also used to access fit results. A log-normal
prior can be specified for a parameter by including an entry for
<code class="docutils literal"><span class="pre">log(c)</span></code> in the prior, rather than for <code class="docutils literal"><span class="pre">c</span></code> itself. See the
<code class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></code> documentation for information about other distributions
that are available. Values for both <code class="docutils literal"><span class="pre">log(c)</span></code> and <code class="docutils literal"><span class="pre">c</span></code> are
included in the parameter dictionary. Log-normal distributions
are  useful for forcing <code class="docutils literal"><span class="pre">an</span></code>, <code class="docutils literal"><span class="pre">bn</span></code> and/or <code class="docutils literal"><span class="pre">dE</span></code> to be positive.</p>
<p>When <code class="docutils literal"><span class="pre">tp</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code> and positive, the correlator is assumed to be
symmetrical about <code class="docutils literal"><span class="pre">tp/2</span></code>, with <code class="docutils literal"><span class="pre">Gab(t)=Gab(tp-t)</span></code>. Data from
<code class="docutils literal"><span class="pre">t&gt;tp/2</span></code> is averaged with the corresponding data from <code class="docutils literal"><span class="pre">t&lt;tp/2</span></code>
before fitting. When <code class="docutils literal"><span class="pre">tp</span></code> is negative, the correlator is assumed to
be anti-symetrical about <code class="docutils literal"><span class="pre">-tp/2</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datatag</strong> (<em>str</em>) – Key used to access correlator data in the input data
dictionary (see <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a>): <code class="docutils literal"><span class="pre">data[self.datatag]</span></code> is a (1-d)
array containing the correlator values (<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s).</li>
<li><strong>a</strong> (<em>str</em><em> or </em><em>tuple</em>) – Key identifying the fit parameters for the source
amplitudes <code class="docutils literal"><span class="pre">an</span></code> in the dictionary of priors provided to
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a>; or a two-tuple of keys for the source amplitudes
<code class="docutils literal"><span class="pre">(an,</span> <span class="pre">ao)</span></code>. The corresponding values in the dictionary of priors
are (1-d) arrays of prior values with one term for each <code class="docutils literal"><span class="pre">an[i]</span></code>
or <code class="docutils literal"><span class="pre">ao[i]</span></code>. Replacing either key by <code class="docutils literal"><span class="pre">None</span></code> causes the
corresponding term to be dropped from the fit function. These keys
are used to label  the corresponding parameter arrays in the fit
results as well as  in the prior.</li>
<li><strong>b</strong> (<em>str</em><em> or </em><em>tuple</em>) – Same as <code class="docutils literal"><span class="pre">self.a</span></code> but for the sinks <code class="docutils literal"><span class="pre">(bn,</span> <span class="pre">bo)</span></code>
instead of the sources <code class="docutils literal"><span class="pre">(an,</span> <span class="pre">ao)</span></code>.</li>
<li><strong>dE</strong> (<em>str</em>) – Key identifying the fit parameters for the energy
differences <code class="docutils literal"><span class="pre">dEn</span></code> in the dictionary of priors provided by
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a>; or a two-tuple of keys for the energy differences
<code class="docutils literal"><span class="pre">(dEn,</span> <span class="pre">dEo)</span></code>. The corresponding values in the dictionary of
priors are (1-d) arrays of prior values with one term for each
<code class="docutils literal"><span class="pre">dEn[i]</span></code> or <code class="docutils literal"><span class="pre">dEo[i]</span></code>. Replacing either key by <code class="docutils literal"><span class="pre">None</span></code> causes
the corresponding term to be dropped from the fit function. These
keys are used to label the corresponding parameter arrays in the
fit results as well as in the prior.</li>
<li><strong>s</strong> (<em>float</em><em> or </em><em>tuple</em>) – Overall factor <code class="docutils literal"><span class="pre">sn</span></code> for non-oscillating part
of fit function, or two-tuple of overall factors <code class="docutils literal"><span class="pre">(sn,</span> <span class="pre">so)</span></code>
for both pieces.</li>
<li><strong>tdata</strong> (<em>list of ints</em>) – The <code class="docutils literal"><span class="pre">t</span></code>s corresponding to data
entries in the input data. Note that <code class="docutils literal"><span class="pre">len(self.tdata)</span></code>
should equal <code class="docutils literal"><span class="pre">len(data[self.datatag])</span></code>. If <code class="docutils literal"><span class="pre">tdata</span></code> is
omitted, <code class="docutils literal"><span class="pre">tdata=numpy.arange(tp)</span></code> is assumed, or
<code class="docutils literal"><span class="pre">tdata=numpy.arange(tmax)</span></code> if <code class="docutils literal"><span class="pre">tp</span></code> is not specified.</li>
<li><strong>tfit</strong> (<em>list of ints</em>) – List of <code class="docutils literal"><span class="pre">t</span></code>s to use in the fit. Only data
with these <code class="docutils literal"><span class="pre">t</span></code>s (all of which should be in <code class="docutils literal"><span class="pre">tdata</span></code>) is  used
in the fit. If <code class="docutils literal"><span class="pre">tfit</span></code> is omitted, it is assumed to be all <code class="docutils literal"><span class="pre">t</span></code>
values from <code class="docutils literal"><span class="pre">tdata</span></code> that are larger than or equal to <code class="docutils literal"><span class="pre">tmin</span></code>
(if specified) and smaller than or equal to <code class="docutils literal"><span class="pre">tmax</span></code> (if
specified).</li>
<li><strong>tp</strong> (int or <code class="docutils literal"><span class="pre">None</span></code>) – If <code class="docutils literal"><span class="pre">tp</span></code> is positive, the correlator
is assumed to be periodic with <code class="docutils literal"><span class="pre">Gab(t)=Gab(tp-t)</span></code>.
If negative, the correlator is assumed to be anti-periodic
with <code class="docutils literal"><span class="pre">Gab(t)=-Gab(-tp-t)</span></code>. Setting <code class="docutils literal"><span class="pre">tp=None</span></code> implies that
the correlator is not periodic, but rather continues
to fall exponentially as <code class="docutils literal"><span class="pre">t</span></code> is increased indefinitely.</li>
<li><strong>tmin</strong> (int or <code class="docutils literal"><span class="pre">None</span></code>) – If <code class="docutils literal"><span class="pre">tfit</span></code> is omitted, it is assumed
to be all <code class="docutils literal"><span class="pre">t</span></code> values from <code class="docutils literal"><span class="pre">tdata</span></code> that are larger than or
equal to <code class="docutils literal"><span class="pre">tmin</span></code> and smaller than or equal to <code class="docutils literal"><span class="pre">tmax</span></code>
(if specified). <code class="docutils literal"><span class="pre">tmin</span></code> is ignored if <code class="docutils literal"><span class="pre">tfit</span></code> is specified.</li>
<li><strong>tmax</strong> (int or <code class="docutils literal"><span class="pre">None</span></code>) – If <code class="docutils literal"><span class="pre">tfit</span></code> is omitted, it is assumed
to be all <code class="docutils literal"><span class="pre">t</span></code> values from <code class="docutils literal"><span class="pre">tdata</span></code> that are larger than or
equal to <code class="docutils literal"><span class="pre">tmin</span></code> (if specified) and smaller than or
equal to <code class="docutils literal"><span class="pre">tmax</span></code>. <code class="docutils literal"><span class="pre">tmin</span></code> is ignored if <code class="docutils literal"><span class="pre">tfit</span></code> and <code class="docutils literal"><span class="pre">tdata</span></code>
are specified.</li>
<li><strong>ncg</strong> (<em>int</em>) – Width of bins used to coarse-grain the correlator before
fitting. Each bin of <code class="docutils literal"><span class="pre">ncg</span></code> correlator values is replaced by
its average. Default is <code class="docutils literal"><span class="pre">ncg=1</span></code> (ie, no coarse-graining).</li>
<li><strong>reverse</strong> (<em>bool</em>) – If <code class="docutils literal"><span class="pre">True</span></code>, the data associated with <code class="docutils literal"><span class="pre">self.datatag</span></code>
is time-reversed (<code class="docutils literal"><span class="pre">data</span> <span class="pre">-&gt;</span> <span class="pre">[data[0],</span> <span class="pre">data[-1],</span> <span class="pre">data[-2]...data[1]]</span></code>).
Ignored otherwise.</li>
<li><strong>otherdata</strong> (str or list or <code class="docutils literal"><span class="pre">None</span></code>) – Data tag or list of data tags for
additional data that are averaged with the <code class="docutils literal"><span class="pre">self.datatag</span></code>
data before fitting. This is useful including data
from correlators with the source and sink interchanged.
Default is <code class="docutils literal"><span class="pre">None</span></code>.</li>
<li><strong>reverseddata</strong> (str or list or <code class="docutils literal"><span class="pre">None</span></code>) – Data tag or list of data tags
for data that is time-reversed and then averaged with
the <code class="docutils literal"><span class="pre">self.datatag</span></code> data before fitting. Default is <code class="docutils literal"><span class="pre">None</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="corrfitter.Corr2.builddata">
<code class="descname">builddata</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.Corr2.builddata" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble fit data from dictionary <code class="docutils literal"><span class="pre">data</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.Corr2.builddataset">
<code class="descname">builddataset</code><span class="sig-paren">(</span><em>dataset</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.Corr2.builddataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble fit data from data set dictionary <code class="docutils literal"><span class="pre">dataset</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.Corr2.buildprior">
<code class="descname">buildprior</code><span class="sig-paren">(</span><em>prior</em>, <em>nterm=None</em>, <em>mopt=None</em>, <em>extend=None</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.Corr2.buildprior" title="Permalink to this definition">¶</a></dt>
<dd><p>Create fit prior by extracting relevant pieces from <code class="docutils literal"><span class="pre">prior</span></code>.</p>
<p>This routine selects the entries in dictionary <code class="docutils literal"><span class="pre">prior</span></code>
corresponding to the model’s fit parameters. If <code class="docutils literal"><span class="pre">nterm</span></code> is
not <code class="docutils literal"><span class="pre">None</span></code>, it also adjusts the number of terms that are
retained.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>prior</strong> (<em>dictionary</em>) – Dictionary containing priors for fit
parameters.</li>
<li><strong>nterm</strong> (<code class="docutils literal"><span class="pre">None</span></code> or int or two-tuple) – Setting <code class="docutils literal"><span class="pre">nterm=(n,no)</span></code>
restricts the number of terms to <code class="docutils literal"><span class="pre">n</span></code> in the
non-oscillating part and <code class="docutils literal"><span class="pre">no</span></code> in the oscillating part
of the fit function. Replacing either or both by
<code class="docutils literal"><span class="pre">None</span></code> keeps all terms, as does setting <code class="docutils literal"><span class="pre">nterm=None</span></code>.
This optional argument is used to implement
marginalization.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="corrfitter.Corr2.fitfcn">
<code class="descname">fitfcn</code><span class="sig-paren">(</span><em>p</em>, <em>t=None</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.Corr2.fitfcn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fit function for parameters <code class="docutils literal"><span class="pre">p</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="corrfitter.Corr3">
<em class="property">class </em><code class="descclassname">corrfitter.</code><code class="descname">Corr3</code><span class="sig-paren">(</span><em>datatag</em>, <em>T</em>, <em>Vnn</em>, <em>a</em>, <em>b</em>, <em>dEa</em>, <em>dEb</em>, <em>sa=1.0</em>, <em>sb=1.0</em>, <em>Vno=None</em>, <em>Von=None</em>, <em>Voo=None</em>, <em>tdata=None</em>, <em>tfit=None</em>, <em>tmin=None. reverse=False</em>, <em>symmetric_V=False</em>, <em>reverseddata=[]</em>, <em>otherdata=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.Corr3" title="Permalink to this definition">¶</a></dt>
<dd><p>Three-point correlators <code class="docutils literal"><span class="pre">Gavb(t,</span> <span class="pre">T)</span> <span class="pre">=</span> <span class="pre">&lt;b(T)</span> <span class="pre">V(t)</span> <span class="pre">a(0)&gt;</span></code>.</p>
<p><a class="reference internal" href="#corrfitter.Corr3" title="corrfitter.Corr3"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr3</span></code></a> models the <code class="docutils literal"><span class="pre">t</span></code> dependence of a 3-point correlator
<code class="docutils literal"><span class="pre">Gavb(t,</span> <span class="pre">T)</span></code> using</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Gavb</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">=</span>
 <span class="n">sum_i</span><span class="p">,</span><span class="n">j</span> <span class="n">san</span> <span class="o">*</span> <span class="n">an</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fn</span><span class="p">(</span><span class="n">Ean</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">Vnn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">sbn</span> <span class="o">*</span> <span class="n">bn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">fn</span><span class="p">(</span><span class="n">Ebn</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">T</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
<span class="o">+</span><span class="n">sum_i</span><span class="p">,</span><span class="n">j</span> <span class="n">san</span> <span class="o">*</span> <span class="n">an</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fn</span><span class="p">(</span><span class="n">Ean</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">Vno</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">sbo</span> <span class="o">*</span> <span class="n">bo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">fo</span><span class="p">(</span><span class="n">Ebo</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">T</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
<span class="o">+</span><span class="n">sum_i</span><span class="p">,</span><span class="n">j</span> <span class="n">sao</span> <span class="o">*</span> <span class="n">ao</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fo</span><span class="p">(</span><span class="n">Eao</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">Von</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">sbn</span> <span class="o">*</span> <span class="n">bn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">fn</span><span class="p">(</span><span class="n">Ebn</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">T</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
<span class="o">+</span><span class="n">sum_i</span><span class="p">,</span><span class="n">j</span> <span class="n">sao</span> <span class="o">*</span> <span class="n">ao</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fo</span><span class="p">(</span><span class="n">Eao</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">Voo</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">sbo</span> <span class="o">*</span> <span class="n">bo</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">fo</span><span class="p">(</span><span class="n">Ebo</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">T</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">fn</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span>  <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">fo</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">t</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>The fit parameters for the non-oscillating piece of <code class="docutils literal"><span class="pre">Gavb</span></code> (first term)
are <code class="docutils literal"><span class="pre">Vnn[i,j]</span></code>, <code class="docutils literal"><span class="pre">an[i]</span></code>, <code class="docutils literal"><span class="pre">bn[j]</span></code>, <code class="docutils literal"><span class="pre">dEan[i]</span></code> and <code class="docutils literal"><span class="pre">dEbn[j]</span></code> where,
for example:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">dEan</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ean</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dEan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Ean</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>     <span class="p">(</span><span class="k">for</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>and therefore <code class="docutils literal"><span class="pre">Ean[i]</span> <span class="pre">=</span> <span class="pre">sum_j=0..i</span> <span class="pre">dEan[j]</span></code>. The parameters for the
other terms are similarly defined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datatag</strong> (<em>str</em>) – Tag used to label correlator in the input data.</li>
<li><strong>a</strong> (<em>str</em><em> or </em><em>tuple</em>) – Key identifying the fit parameters for the source
amplitudes <code class="docutils literal"><span class="pre">an</span></code>, for <code class="docutils literal"><span class="pre">a-&gt;V</span></code>, in the dictionary of priors
provided to <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a>; or a two-tuple of keys for the source
amplitudes <code class="docutils literal"><span class="pre">(an,</span> <span class="pre">ao)</span></code>. The corresponding values in the
dictionary of priors are (1-d) arrays of prior values with one
term for each <code class="docutils literal"><span class="pre">an[i]</span></code> or <code class="docutils literal"><span class="pre">ao[i]</span></code>. Replacing either key by
<code class="docutils literal"><span class="pre">None</span></code> causes the corresponding term to be dropped from the fit
function. These keys are used to label the corresponding parameter
arrays in the fit results as well as in the prior.</li>
<li><strong>b</strong> (<em>str</em><em> or </em><em>tuple</em>) – Same as <code class="docutils literal"><span class="pre">self.a</span></code> but  for the <code class="docutils literal"><span class="pre">V-&gt;b</span></code> sink
amplitudes <code class="docutils literal"><span class="pre">(bn,</span> <span class="pre">bo)</span></code>.</li>
<li><strong>dEa</strong> (<em>str</em><em> or </em><em>tuple</em>) – Fit-parameter label for <code class="docutils literal"><span class="pre">a-&gt;V</span></code>
intermediate-state energy differences <code class="docutils literal"><span class="pre">dEan</span></code>, or two-tuple of
labels for the differences <code class="docutils literal"><span class="pre">(dEan,</span> <span class="pre">dEao)</span></code>. Each label represents
an array of energy differences. Replacing either label by <code class="docutils literal"><span class="pre">None</span></code>
causes the corresponding term in the correlator function to be
dropped. These keys are used to label the corresponding parameter
arrays in the fit results as well as in the prior.</li>
<li><strong>dEb</strong> (<em>str</em><em> or </em><em>tuple</em>) – Same as <code class="docutils literal"><span class="pre">self.dEa</span></code> but for <code class="docutils literal"><span class="pre">V-&gt;b</span></code> sink
energies <code class="docutils literal"><span class="pre">(dEbn,</span> <span class="pre">dEbo)</span></code>.</li>
<li><strong>sa</strong> (<em>float</em><em> or </em><em>tuple</em>) – Overall factor <code class="docutils literal"><span class="pre">san</span></code> for the non-oscillating
<code class="docutils literal"><span class="pre">a-&gt;V</span></code> terms in the correlator, or two-tuple containing
the overall factors <code class="docutils literal"><span class="pre">(san,</span> <span class="pre">sao)</span></code> for the non-oscillating and
oscillating terms. Default is <code class="docutils literal"><span class="pre">(1,-1)</span></code>.</li>
<li><strong>sb</strong> (<em>float</em><em> or </em><em>tuple</em>) – Same as <code class="docutils literal"><span class="pre">self.sa</span></code> but for <code class="docutils literal"><span class="pre">V-&gt;b</span></code> sink
overall factors <code class="docutils literal"><span class="pre">(sbn,</span> <span class="pre">sbo)</span></code>.</li>
<li><strong>Vnn</strong> (str or <code class="docutils literal"><span class="pre">None</span></code>) – <p>Fit-parameter label for the matrix of current
matrix elements <code class="docutils literal"><span class="pre">Vnn[i,j]</span></code> connecting non-oscillating states.
The matrix must be square and symmetric if <code class="docutils literal"><span class="pre">symmetric_V=True</span></code>,
and only the elements <code class="docutils literal"><span class="pre">V[i,j]</span></code> for <code class="docutils literal"><span class="pre">j&gt;=i</span></code> are specified, using
a 1-d array <code class="docutils literal"><span class="pre">V_sym</span></code> with the following layout:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="p">[</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">...</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">],</span>
        <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">...</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">],</span>
               <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">...</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">N</span><span class="p">],</span>
                     <span class="o">.</span>
                      <span class="o">.</span>
                       <span class="o">.</span>
                        <span class="n">V</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]]</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">V[i,j]</span> <span class="pre">=</span> <span class="pre">V_symm[i*N</span> <span class="pre">+</span> <span class="pre">j</span> <span class="pre">-</span> <span class="pre">i</span> <span class="pre">*</span> <span class="pre">(i+1)</span> <span class="pre">/</span> <span class="pre">2]</span></code> for
<code class="docutils literal"><span class="pre">j&gt;=i</span></code>. Set <code class="docutils literal"><span class="pre">Vnn=None</span></code> to omit it.</p>
</li>
<li><strong>Vno</strong> (str or <code class="docutils literal"><span class="pre">None</span></code>) – Fit-parameter label for the matrix of current
matrix elements <code class="docutils literal"><span class="pre">Vno[i,j]</span></code> connecting non-oscillating to
oscillating states. Only one of <code class="docutils literal"><span class="pre">Von</span></code> and <code class="docutils literal"><span class="pre">Vno</span></code> can be
specified if <code class="docutils literal"><span class="pre">symmetric_V=True</span></code>; the other is defined to be its
transform. Set <code class="docutils literal"><span class="pre">Vno=None</span></code> to omit it.</li>
<li><strong>Von</strong> (str or <code class="docutils literal"><span class="pre">None</span></code>) – Fit-parameter label for the matrix of current
matrix elements <code class="docutils literal"><span class="pre">Vno[i,j]</span></code> connecting oscillating to non-
oscillating states. Only one of <code class="docutils literal"><span class="pre">Von</span></code> and <code class="docutils literal"><span class="pre">Vno</span></code> can be
specified if <code class="docutils literal"><span class="pre">symmetric_V=True</span></code>; the other is defined to be its
transform. Set <code class="docutils literal"><span class="pre">Von=None</span></code> to omit it.</li>
<li><strong>Voo</strong> (str or <code class="docutils literal"><span class="pre">None</span></code>) – <p>Fit-parameter label for the matrix of current
matrix elements <code class="docutils literal"><span class="pre">Voo[i,j]</span></code> connecting oscillating states. The
matrix must be square and symmetric if <code class="docutils literal"><span class="pre">symmetric_V=True</span></code>, and
only the elements <code class="docutils literal"><span class="pre">V[i,j]</span></code> for <code class="docutils literal"><span class="pre">j&gt;=i</span></code> are specified, using a
1-d array <code class="docutils literal"><span class="pre">V_sym</span></code> with the following layout:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="p">[</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">...</span><span class="n">V</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">],</span>
        <span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">...</span><span class="n">V</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">],</span>
               <span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">...</span><span class="n">V</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">N</span><span class="p">],</span>
                     <span class="o">.</span>
                      <span class="o">.</span>
                       <span class="o">.</span>
                        <span class="n">V</span><span class="p">[</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">]]</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">V[i,j]</span> <span class="pre">=</span> <span class="pre">V_symm[i*N</span> <span class="pre">+</span> <span class="pre">j</span> <span class="pre">-</span> <span class="pre">i</span> <span class="pre">*</span> <span class="pre">(i+1)</span> <span class="pre">/</span> <span class="pre">2]</span></code> for
<code class="docutils literal"><span class="pre">j&gt;=i</span></code>. Set <code class="docutils literal"><span class="pre">Voo=None</span></code> to omit it.</p>
</li>
<li><strong>reverse</strong> (<em>bool</em>) – <p>If <code class="docutils literal"><span class="pre">True</span></code>, the data associated with <code class="docutils literal"><span class="pre">self.datatag</span></code>
is time-reversed before fitting (interchanging <code class="docutils literal"><span class="pre">t=0</span></code> with
<code class="docutils literal"><span class="pre">t=T</span></code>). This is useful for doing simultaneous fits to
<code class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></code> and <code class="docutils literal"><span class="pre">b-&gt;V-&gt;a</span></code>, where one is time-reversed relative
to the other: <em>e.g.</em>,</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">models</span> <span class="o">=</span> <span class="p">[</span> <span class="o">...</span>
    <span class="n">Corr3</span><span class="p">(</span>
        <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;a-&gt;V-&gt;b&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEa</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dEa&#39;</span><span class="p">,</span> <span class="s">&#39;dEao&#39;</span><span class="p">),</span>
        <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;bo&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dEb&#39;</span><span class="p">,</span> <span class="s">&#39;dEbo&#39;</span><span class="p">),</span>
        <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span><span class="p">,</span> <span class="n">Von</span><span class="o">=</span><span class="s">&#39;Von&#39;</span><span class="p">,</span> <span class="n">Voo</span><span class="o">=</span><span class="s">&#39;Voo&#39;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="n">Corr3</span><span class="p">(</span>
        <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;b-&gt;V-&gt;a&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEa</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dEa&#39;</span><span class="p">,</span> <span class="s">&#39;dEao&#39;</span><span class="p">),</span>
        <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;bo&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dEb&#39;</span><span class="p">,</span> <span class="s">&#39;dEbo&#39;</span><span class="p">),</span>
        <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span><span class="p">,</span> <span class="n">Von</span><span class="o">=</span><span class="s">&#39;Von&#39;</span><span class="p">,</span> <span class="n">Voo</span><span class="o">=</span><span class="s">&#39;Voo&#39;</span><span class="p">,</span>
        <span class="n">reverse</span><span class="o">=</span><span class="k">True</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="o">...</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Another (faster) strategy for such situations is to average
data from the second process with that from the  first, before
fitting, using keyword <code class="docutils literal"><span class="pre">reverseddata</span></code>. Default is <code class="docutils literal"><span class="pre">False</span></code>.</p>
</li>
<li><strong>symmetric_V</strong> (<em>bool</em>) – If <code class="docutils literal"><span class="pre">True</span></code>, the fit function for <code class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></code> is
unchanged (symmetrical) under the the interchange of <code class="docutils literal"><span class="pre">a</span></code> and
<code class="docutils literal"><span class="pre">b</span></code>. Then <code class="docutils literal"><span class="pre">Vnn</span></code> and <code class="docutils literal"><span class="pre">Voo</span></code> are square, symmetric matrices
and their priors are one-dimensional arrays containing only
elements <code class="docutils literal"><span class="pre">V[i,j]</span></code> with <code class="docutils literal"><span class="pre">j&gt;=i</span></code>, as discussed above.
Only one of <code class="docutils literal"><span class="pre">Von</span></code> and <code class="docutils literal"><span class="pre">Vno</span></code> can be specified if
<code class="docutils literal"><span class="pre">symmetric_V=True</span></code>; the other is defined to be its transform.</li>
<li><strong>T</strong> (<em>int</em>) – Separation between source and sink.</li>
<li><strong>tdata</strong> (<em>list of ints</em>) – The <code class="docutils literal"><span class="pre">t</span></code>s corresponding to data entries
in the input data. If omitted, is assumed equal to
<code class="docutils literal"><span class="pre">numpy.arange(T</span> <span class="pre">+</span> <span class="pre">1)</span></code>.</li>
<li><strong>tfit</strong> (<em>list of ints</em>) – List of <code class="docutils literal"><span class="pre">t</span></code>s to use in the fit. Only data
with these <code class="docutils literal"><span class="pre">t</span></code>s (all of which should be in <code class="docutils literal"><span class="pre">tdata</span></code>)
is used in the fit. If omitted, is assumed equal to
<code class="docutils literal"><span class="pre">numpy.arange(tmin,</span> <span class="pre">T</span> <span class="pre">-</span> <span class="pre">tmin</span> <span class="pre">+</span> <span class="pre">1)</span></code>.</li>
<li><strong>tmin</strong> (int or <code class="docutils literal"><span class="pre">None</span></code>) – If <code class="docutils literal"><span class="pre">tfit</span></code> is omitted, it is set equal
to <code class="docutils literal"><span class="pre">numpy.arange(tmin,</span> <span class="pre">T</span> <span class="pre">-</span> <span class="pre">tmin</span> <span class="pre">+</span> <span class="pre">1)</span></code>. <code class="docutils literal"><span class="pre">tmin</span></code> is ignored
if <code class="docutils literal"><span class="pre">tfit</span></code> is specified.</li>
<li><strong>ncg</strong> (<em>int</em>) – Width of bins used to coarse-grain the correlator before
fitting. Each bin of <code class="docutils literal"><span class="pre">ncg</span></code> correlator values is replaced by
its average. Default is <code class="docutils literal"><span class="pre">ncg=1</span></code> (ie, no coarse-graining).</li>
<li><strong>reverseddata</strong> (str or list or <code class="docutils literal"><span class="pre">None</span></code>) – <p>Data tag or list of data tags
for additional data that are time-reversed and then averaged with
the <code class="docutils literal"><span class="pre">self.datatag</span></code> data before fitting. This is useful for
folding data from <code class="docutils literal"><span class="pre">b-&gt;V-&gt;a</span></code> into a fit for <code class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></code>:
<em>e.g.</em>,</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Corr3</span><span class="p">(</span>
    <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;a-&gt;V-&gt;b&#39;</span><span class="p">,</span>
    <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEa</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dEa&#39;</span><span class="p">,</span> <span class="s">&#39;dEao&#39;</span><span class="p">),</span>
    <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;bo&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dEb&#39;</span><span class="p">,</span> <span class="s">&#39;dEbo&#39;</span><span class="p">),</span>
    <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span><span class="p">,</span> <span class="n">Von</span><span class="o">=</span><span class="s">&#39;Von&#39;</span><span class="p">,</span> <span class="n">Voo</span><span class="o">=</span><span class="s">&#39;Voo&#39;</span><span class="p">,</span>
    <span class="n">tmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">reverseddata</span><span class="o">=</span><span class="s">&#39;b-&gt;V-&gt;a&#39;</span>
    <span class="p">),</span>
</pre></div>
</div>
<p>This is faster than using a separate model with
<code class="docutils literal"><span class="pre">transpose_V=True</span></code>. Default is <code class="docutils literal"><span class="pre">None</span></code>.</p>
</li>
<li><strong>otherdata</strong> (str or list or <code class="docutils literal"><span class="pre">None</span></code>) – Data tag or list of data tags
for additional data that are averaged with the <code class="docutils literal"><span class="pre">self.datatag</span></code>
data before fitting. Default is <code class="docutils literal"><span class="pre">None</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="corrfitter-objects">
<h2><a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> Objects<a class="headerlink" href="#corrfitter-objects" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> objects are wrappers for <code class="xref py py-func docutils literal"><span class="pre">lsqfit.nonlinear_fit()</span></code> which
is used to fit a collection of models to a collection of Monte Carlo data.</p>
<dl class="class">
<dt id="corrfitter.CorrFitter">
<em class="property">class </em><code class="descclassname">corrfitter.</code><code class="descname">CorrFitter</code><span class="sig-paren">(</span><em>models</em>, <em>nterm=None</em>, <em>ratio=False</em>, <em>fast=True</em>, <em>**fitterargs</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.CorrFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Nonlinear least-squares fitter for a collection of correlator models.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>models</strong> – List of models, derived from <code class="xref py py-mod docutils literal"><span class="pre">lsqfit.MultiFitterModel</span></code>,
to be fit to the data. Individual models in the list can
be replaced by lists of models or tuples of models; see below.</li>
<li><strong>nterm</strong> (<em>tuple</em><em> or </em><em>int</em><em> or </em><em>None</em>) – Number of terms fit in the
non-oscillating part of fit functions; or a two-tuple of
numbers indicating how many terms to fit in each of the
non-oscillating and oscillating parts. Terms  omitted from the
fit are marginalized (<em>i.e.</em>, included as corrections to the
fit data). If set to <code class="docutils literal"><span class="pre">None</span></code>, all parameters in the
prior are fit, and none are marginalized.</li>
<li><strong>ratio</strong> (<em>bool</em>) – If <code class="docutils literal"><span class="pre">True</span></code>, implement marginalization using
ratios: <code class="docutils literal"><span class="pre">data_marg</span> <span class="pre">=</span> <span class="pre">data</span> <span class="pre">*</span> <span class="pre">fitfcn(prior_marg)</span> <span class="pre">/</span> <span class="pre">fitfcn(prior)</span></code>.
If <code class="docutils literal"><span class="pre">False</span></code> (default), implement using differences:
<code class="docutils literal"><span class="pre">data_marg</span> <span class="pre">=</span> <span class="pre">data</span> <span class="pre">+</span> <span class="pre">(fitfcn(prior_marg)</span> <span class="pre">-</span> <span class="pre">fitfcn(prior))</span></code>.</li>
<li><strong>fast</strong> (<em>bool</em>) – Setting <code class="docutils literal"><span class="pre">fast=True</span></code> (default) strips any variable
not required by the fit from the prior. This speeds
fits but loses information about correlations between
variables in the fit and those that are not. The
information can be restored using <code class="docutils literal"><span class="pre">lsqfit.wavg</span></code> after
the fit.</li>
<li><strong>fitterargs</strong> – Additional arguments for the <code class="xref py py-class docutils literal"><span class="pre">lsqfit.nonlinear_fit</span></code>,
such as <code class="docutils literal"><span class="pre">tol</span></code>, <code class="docutils literal"><span class="pre">maxit</span></code>, <code class="docutils literal"><span class="pre">svdcut</span></code>, <code class="docutils literal"><span class="pre">fitter</span></code>, etc., as needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="corrfitter.CorrFitter.bootstrap_fit_iter">
<code class="descname">bootstrap_fit_iter</code><span class="sig-paren">(</span><em>datalist=None</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.CorrFitter.bootstrap_fit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that creates bootstrap copies of a <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> fit using
bootstrap data from list <code class="docutils literal"><span class="pre">data_list</span></code>.</p>
<p>A bootstrap analysis is a robust technique for estimating means and
standard deviations of arbitrary functions of the fit parameters.
This method creates an interator that implements such an analysis
of list (or iterator) <code class="docutils literal"><span class="pre">datalist</span></code>, which contains bootstrap
copies of the original data set. Each <code class="docutils literal"><span class="pre">data_list[i]</span></code> is a different
<code class="docutils literal"><span class="pre">data</span></code> input for <code class="docutils literal"><span class="pre">self.lsqfit()</span></code> (that is, a dictionary containing
fit data). The iterator works its way through the data sets in
<code class="docutils literal"><span class="pre">data_list</span></code>, fitting the next data set on each iteration and
returning the resulting <code class="xref py py-class docutils literal"><span class="pre">lsqfit.LSQFit</span></code> fit object. Typical
usage, for an <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> object named <code class="docutils literal"><span class="pre">fitter</span></code>, would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="k">for</span> <span class="n">fit</span> <span class="ow">in</span> <span class="n">fitter</span><span class="o">.</span><span class="n">bootstrap_iter</span><span class="p">(</span><span class="n">datalist</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">analyze</span> <span class="n">fit</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span> <span class="o">...</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_list</strong> (sequence or iterator or <code class="docutils literal"><span class="pre">None</span></code>) – Collection of bootstrap <code class="docutils literal"><span class="pre">data</span></code> sets for fitter. If
<code class="docutils literal"><span class="pre">None</span></code>, the data_list is generated internally using the
means and standard deviations of the fit data (assuming
gaussian statistics).</li>
<li><strong>n</strong> (<em>integer</em>) – Maximum number of iterations if <code class="docutils literal"><span class="pre">n</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>;
otherwise there is no maximum.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Iterator that returns a <code class="xref py py-class docutils literal"><span class="pre">lsqfit.LSQFit</span></code> object
containing results from the fit to the next data set in
<code class="docutils literal"><span class="pre">data_list</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="corrfitter.CorrFitter.bootstrap_iter">
<code class="descname">bootstrap_iter</code><span class="sig-paren">(</span><em>datalist=None</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.CorrFitter.bootstrap_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that creates bootstrap copies of a <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> fit using
bootstrap data from list <code class="docutils literal"><span class="pre">data_list</span></code>.</p>
<p>A bootstrap analysis is a robust technique for estimating means and
standard deviations of arbitrary functions of the fit parameters.
This method creates an interator that implements such an analysis
of list (or iterator) <code class="docutils literal"><span class="pre">datalist</span></code>, which contains bootstrap
copies of the original data set. Each <code class="docutils literal"><span class="pre">data_list[i]</span></code> is a different
<code class="docutils literal"><span class="pre">data</span></code> input for <code class="docutils literal"><span class="pre">self.lsqfit()</span></code> (that is, a dictionary containing
fit data). The iterator works its way through the data sets in
<code class="docutils literal"><span class="pre">data_list</span></code>, fitting the next data set on each iteration and
returning the resulting <code class="xref py py-class docutils literal"><span class="pre">lsqfit.LSQFit</span></code> fit object. Typical
usage, for an <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> object named <code class="docutils literal"><span class="pre">fitter</span></code>, would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="k">for</span> <span class="n">fit</span> <span class="ow">in</span> <span class="n">fitter</span><span class="o">.</span><span class="n">bootstrap_iter</span><span class="p">(</span><span class="n">datalist</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">analyze</span> <span class="n">fit</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span> <span class="o">...</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_list</strong> (sequence or iterator or <code class="docutils literal"><span class="pre">None</span></code>) – Collection of bootstrap <code class="docutils literal"><span class="pre">data</span></code> sets for fitter. If
<code class="docutils literal"><span class="pre">None</span></code>, the data_list is generated internally using the
means and standard deviations of the fit data (assuming
gaussian statistics).</li>
<li><strong>n</strong> (<em>integer</em>) – Maximum number of iterations if <code class="docutils literal"><span class="pre">n</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>;
otherwise there is no maximum.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Iterator that returns a <code class="xref py py-class docutils literal"><span class="pre">lsqfit.LSQFit</span></code> object
containing results from the fit to the next data set in
<code class="docutils literal"><span class="pre">data_list</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="corrfitter.CorrFitter.read_dataset">
<em class="property">static </em><code class="descname">read_dataset</code><span class="sig-paren">(</span><em>inputfiles</em>, <em>grep=None</em>, <em>keys=None</em>, <em>h5group=’/’</em>, <em>binsize=1</em>, <em>tcol=0</em>, <em>Gcol=1</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.CorrFitter.read_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Read correlator Monte Carlo data from files into a <code class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></code>.</p>
<p>Three files formats are supported by <a class="reference internal" href="#corrfitter.CorrFitter.read_dataset" title="corrfitter.CorrFitter.read_dataset"><code class="xref py py-func docutils literal"><span class="pre">read_dataset()</span></code></a>, depending
upon <code class="docutils literal"><span class="pre">inputfiles</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">inputfiles</span></code> is a string ending in <code class="docutils literal"><span class="pre">'.h5'</span></code>, it is assumed to
be the name of a file in hpf5 format. The file is opened as
<code class="docutils literal"><span class="pre">h5file</span></code> and all hpf5 datasets in <code class="docutils literal"><span class="pre">h5file[h5group]</span></code> are
collected into a dictionary and returned.</p>
<p>The second file format is the text-file format supported by
<code class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></code>: each line consists of a  tag or key
identifying a correlator followed by data corresponding to  a single
Monte Carlo measurement of the correlator. This format is assumed if
<code class="docutils literal"><span class="pre">inputfiles</span></code> is a filename or a list of filenames. It allows a
single file to contain an arbitrary number of measurements for an
arbitrary number of different correlators. The data can also be spread
over multiple files. A typical file might look like</p>
<div class="highlight-default"><div class="highlight"><pre><span class="c"># this is a comment; it is ignored</span>
<span class="n">aa</span> <span class="mf">1.237</span> <span class="mf">0.912</span> <span class="mf">0.471</span>
<span class="n">bb</span> <span class="mf">3.214</span> <span class="mf">0.535</span> <span class="mf">0.125</span>
<span class="n">aa</span> <span class="mf">1.035</span> <span class="mf">0.851</span> <span class="mf">0.426</span>
<span class="n">bb</span> <span class="mf">2.951</span> <span class="mf">0.625</span> <span class="mf">0.091</span>
<span class="o">...</span>
</pre></div>
</div>
<p>which describes two correlators, <code class="docutils literal"><span class="pre">aa</span></code> and <code class="docutils literal"><span class="pre">bb</span></code>, each having
three different <code class="docutils literal"><span class="pre">t</span></code> values.</p>
<p>The third file format is assumed when <code class="docutils literal"><span class="pre">inputfiles</span></code> is a dictionary. The
dictionary’s keys and values identify the (one-dimensional) correlators
and the files containing their Monte Carlo data, respectively. So the
data for correlators <code class="docutils literal"><span class="pre">aa</span></code> and <code class="docutils literal"><span class="pre">bb</span></code> above are in separate files:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">fileinputs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">aa</span><span class="o">=</span><span class="s">&#39;aafile&#39;</span><span class="p">,</span> <span class="n">bb</span><span class="o">=</span><span class="s">&#39;bbfile&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Each line in these data files consists of an index <code class="docutils literal"><span class="pre">t</span></code> value followed by
the corresponding value for correlator <code class="docutils literal"><span class="pre">G(t)</span></code>.  The <code class="docutils literal"><span class="pre">t</span></code>s increase
from line to line up to their maximum value,  at which point they repeat.
The <code class="docutils literal"><span class="pre">aafile</span></code> file for correlator <code class="docutils literal"><span class="pre">aa</span></code> above  would look like:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="c"># this is a comment; it is ignored</span>
<span class="mi">1</span> <span class="mf">1.237</span>
<span class="mi">2</span> <span class="mf">0.912</span>
<span class="mi">3</span> <span class="mf">0.471</span>
<span class="mi">1</span> <span class="mf">1.035</span>
<span class="mi">2</span> <span class="mf">0.851</span>
<span class="mi">3</span> <span class="mf">0.426</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The columns in these files containing <code class="docutils literal"><span class="pre">t</span></code> and <code class="docutils literal"><span class="pre">G(t)</span></code> are
assumed to be columns 0 and 1, respectively. These can be changed
by setting arguments <code class="docutils literal"><span class="pre">tcol</span></code> and <code class="docutils literal"><span class="pre">Gcol</span></code>, respectively.</p>
<p><code class="docutils literal"><span class="pre">corrfitter.process_dataset</span></code> supports keywords <code class="docutils literal"><span class="pre">binsize</span></code>,
<code class="docutils literal"><span class="pre">grep</span></code> and <code class="docutils literal"><span class="pre">keys</span></code>. If <code class="docutils literal"><span class="pre">binsize</span></code> is greater than one,
random samples are binned with bins of size <code class="docutils literal"><span class="pre">binsize</span></code>.
If <code class="docutils literal"><span class="pre">grep</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>, only keys that match or partially
match regular expression <code class="docutils literal"><span class="pre">grep</span></code> are retained; others are ignored.
If <code class="docutils literal"><span class="pre">keys</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>, only keys that are in list <code class="docutils literal"><span class="pre">keys</span></code>
are retained; others are discarded.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.CorrFitter.simulated_pdata_iter">
<code class="descname">simulated_pdata_iter</code><span class="sig-paren">(</span><em>n</em>, <em>dataset</em>, <em>pexact=None</em>, <em>rescale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.CorrFitter.simulated_pdata_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create iterator that returns simulated fit pdata from <code class="docutils literal"><span class="pre">dataset</span></code>.</p>
<p>Simulated fit data has the same covariance matrix as
<code class="docutils literal"><span class="pre">pdata=self.process_dataset(dataset)</span></code>, but mean values that
fluctuate randomly, from copy to copy, around
the value of the fitter’s fit function evaluated at <code class="docutils literal"><span class="pre">p=pexact</span></code>.
The fluctuations are generated from bootstrap copies
of <code class="docutils literal"><span class="pre">dataset</span></code>.</p>
<p>The best-fit results from a fit to such simulated copies of <code class="docutils literal"><span class="pre">pdata</span></code>
should agree with the numbers in <code class="docutils literal"><span class="pre">pexact</span></code> to within the errors
specified by the fits (to the simulated data) — <code class="docutils literal"><span class="pre">pexact</span></code> gives the
“correct” values for the parameters. Knowing the correct value for
each fit parameter ahead of a fit allows us to test the reliability of
the fit’s error estimates and to explore the impact of various fit
options (<em>e.g.</em>, <code class="docutils literal"><span class="pre">fitter.chained_fit</span></code> versus <code class="docutils literal"><span class="pre">fitter.lsqfit</span></code>,
choice of SVD cuts, omission of select models, etc.)</p>
<p>Typically one need examine only a few simulated fits in order
to evaluate fit reliability, since we know the correct values
for the parameters ahead of time. Consequently this method is
much faster than traditional bootstrap analyses.</p>
<p><code class="docutils literal"><span class="pre">pexact</span></code> is usually taken from the last fit done by the fitter
(<code class="docutils literal"><span class="pre">self.fit.pmean</span></code>) unless overridden in the function call.
Typical usage is as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">dataset</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">spdata</span> <span class="ow">in</span> <span class="n">fitter</span><span class="o">.</span><span class="n">simulated_pdata_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
    <span class="c"># redo fit 4 times with different simulated data each time</span>
    <span class="c"># here pexact=fit.pmean is set implicitly</span>
    <span class="n">sfit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">pdata</span><span class="o">=</span><span class="n">spdata</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
    <span class="o">...</span> <span class="n">check</span> <span class="n">that</span> <span class="n">sfit</span><span class="o">.</span><span class="n">p</span> <span class="p">(</span><span class="ow">or</span> <span class="n">functions</span> <span class="n">of</span> <span class="n">it</span><span class="p">)</span> <span class="n">agrees</span> <span class="o">...</span>
    <span class="o">...</span> <span class="k">with</span> <span class="n">pexact</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">pmean</span> <span class="n">to</span> <span class="n">within</span> <span class="n">sfit</span><span class="o">.</span><span class="n">p</span><span class="s">&#39;s errors      ...</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> (<em>int</em>) – Maximum number of simulated data sets made by iterator.</li>
<li><strong>dataset</strong> (<em>dictionary</em>) – Dataset containing Monte Carlo copies of
the correlators. <code class="docutils literal"><span class="pre">dataset[datatag]</span></code> is a two-dimensional
array for the correlator corresponding to <code class="docutils literal"><span class="pre">datatag</span></code>,
where the first index labels the Monte Carlo copy
and the second index labels time.</li>
<li><strong>pexact</strong> (dictionary or <code class="docutils literal"><span class="pre">None</span></code>) – Correct parameter values for
fits to the simulated data — fit results should agree
with <code class="docutils literal"><span class="pre">pexact</span></code> to within errors. If <code class="docutils literal"><span class="pre">None</span></code>, uses
<code class="docutils literal"><span class="pre">self.fit.pmean</span></code> from the last fit.</li>
<li><strong>rescale</strong> (<em>float</em>) – Rescale errors in simulated data by <code class="docutils literal"><span class="pre">rescale</span></code>
(<em>i.e.</em>, multiply covariance matrix by <code class="docutils literal"><span class="pre">rescale</span> <span class="pre">**</span> <span class="pre">2</span></code>).
Default is one, which implies no rescaling.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="corrfitter-eigenbasis-objects">
<h2><a class="reference internal" href="#corrfitter.EigenBasis" title="corrfitter.EigenBasis"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.EigenBasis</span></code></a> Objects<a class="headerlink" href="#corrfitter-eigenbasis-objects" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#corrfitter.EigenBasis" title="corrfitter.EigenBasis"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.EigenBasis</span></code></a> objects are useful for analyzing two-point and
three-point correlators with multiplle sources and sinks.
The current interface for <a class="reference internal" href="#corrfitter.EigenBasis" title="corrfitter.EigenBasis"><code class="xref py py-class docutils literal"><span class="pre">EigenBasis</span></code></a> is experimental.
It may change in the near future, as experience
accumulates from its use.</p>
<dl class="class">
<dt id="corrfitter.EigenBasis">
<em class="property">class </em><code class="descclassname">corrfitter.</code><code class="descname">EigenBasis</code><span class="sig-paren">(</span><em>data</em>, <em>srcs</em>, <em>t</em>, <em>keyfmt=’{s1}.{s2}’</em>, <em>tdata=None</em>, <em>osc=False</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.EigenBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigen-basis of correlator sources/sinks.</p>
<p>Given <img class="math" src="_images/math/5bb69647d7bd1889219c5b6df1c84e698dc2e9cc.png" alt="N" style="vertical-align: 0px"/> sources/sinks and the <img class="math" src="_images/math/338323ed4f4fbb758300f93609944c4d9b9a1ace.png" alt="N \times N" style="vertical-align: 0px"/>
matrix <img class="math" src="_images/math/e4e6afd477915cbbb917f6465a282fc55b5899e2.png" alt="G_{ij}(t)" style="vertical-align: -6px"/> of 2-point correlators created from every
combination of source and sink, we can define a new basis
of sources that makes the matrix correlator approximately
diagonal. Each source in the new basis is associated with
an eigenvector <img class="math" src="_images/math/ea60b3633de4abcae6b43f16d0924e2b2c283449.png" alt="v^{(a)}" style="vertical-align: 0px"/> defined by the matrix equation</p>
<div class="math">
<p><img src="_images/math/ff2fd5fa7ae6b6695a45e0794e8f8cdb6e7aa4b7.png" alt="G(t_1) v^{(a)} = \lambda^{(a)}(t_1-t_0) G(t_0) v^{(a)},"/></p>
</div><p>for some <img class="math" src="_images/math/88db33fa1c91c63a2b58c16b751178f452c42995.png" alt="t_0, t_1" style="vertical-align: -3px"/>. As <img class="math" src="_images/math/88db33fa1c91c63a2b58c16b751178f452c42995.png" alt="t_0, t_1" style="vertical-align: -3px"/> increase, fewer
and fewer states couple to <img class="math" src="_images/math/c74d6a03908f9629e4454dddd23c951c47cfff14.png" alt="G(t)" style="vertical-align: -3px"/>. In the limit where
only <img class="math" src="_images/math/5bb69647d7bd1889219c5b6df1c84e698dc2e9cc.png" alt="N" style="vertical-align: 0px"/> states couple, the correlator</p>
<div class="math">
<p><img src="_images/math/00a4201b32966eaa3308b44dd3e76e8a5febb884.png" alt="\overline{G}_{ab}(t) \equiv v^{(a)T} G(t) v^{(b)}"/></p>
</div><p>becomes diagonal, and each diagonal element couples to
only a single state.</p>
<p>In practice, this condition is only approximate: that is,
<img class="math" src="_images/math/2cfdf4ab58a1cfaf6759938bd62a60821a6fb661.png" alt="\overline G(t)" style="vertical-align: -3px"/>  is approximately diagonal, with diagonal elements
that overlap strongly with the lowest lying states, but
somewhat with other states. These new sources are nevertheless useful
for fits because there is an obvious prior for their amplitudes: <code class="docutils literal"><span class="pre">prior[a][b]</span></code>
approximately equal to one when <code class="docutils literal"><span class="pre">b==a</span></code>, approximately zero
when <code class="docutils literal"><span class="pre">b!=a</span></code> and <code class="docutils literal"><span class="pre">b&lt;N</span></code>, and order one otherwise.</p>
<p>Such a prior can significantly enhance the stability of a multi-source fit,
making it easier to extract reliable results for excited states.
It encodes the fact that only a small number of states couple strongly
to <img class="math" src="_images/math/c74d6a03908f9629e4454dddd23c951c47cfff14.png" alt="G(t)" style="vertical-align: -3px"/> by time <img class="math" src="_images/math/31611d4c08a497f622d22c8132ae0b292f57958b.png" alt="t_0" style="vertical-align: -3px"/>, without being overly
prescriptive about what their energies are. We can easilty project our
correlator onto the new eigen-basis (using <a class="reference internal" href="#corrfitter.EigenBasis.apply" title="corrfitter.EigenBasis.apply"><code class="xref py py-func docutils literal"><span class="pre">EigenBasis.apply()</span></code></a>)
in order to use this prior, but this is unnecessary.
<a class="reference internal" href="#corrfitter.EigenBasis.make_prior" title="corrfitter.EigenBasis.make_prior"><code class="xref py py-func docutils literal"><span class="pre">EigenBasis.make_prior()</span></code></a> creates a prior of this type in the
eigen-basis and then transforms it back to the original basis, thereby
creating an equivalent prior for the amplitudes corresponding
to the original sources.</p>
<p>Typical usage is straightforward. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">basis</span> <span class="o">=</span> <span class="n">EigenBasis</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>                           <span class="c"># data dictionary</span>
    <span class="n">keyfmt</span><span class="o">=</span><span class="s">&#39;G.{s1}.{s2}&#39;</span><span class="p">,</span>           <span class="c"># key format for dictionary entries</span>
    <span class="n">srcs</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;local&#39;</span><span class="p">,</span> <span class="s">&#39;smeared&#39;</span><span class="p">],</span>      <span class="c"># names of sources/sinks</span>
    <span class="n">t</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>                       <span class="c"># t0, t1 used for diagonalization</span>
    <span class="p">)</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">make_prior</span><span class="p">(</span><span class="n">nterm</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">keyfmt</span><span class="o">=</span><span class="s">&#39;m.{s1}&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>creates an <em>eigen-prior</em> that is optimized for fitting the
2-by-2 matrix correlator given by</p>
<div class="highlight-default"><div class="highlight"><pre><span class="p">[[</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;G.local.local&#39;</span><span class="p">],</span>     <span class="n">data</span><span class="p">[</span><span class="s">&#39;G.local.smeared&#39;</span><span class="p">]]</span>
 <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;G.smeared.local&#39;</span><span class="p">],</span>   <span class="n">data</span><span class="p">[</span><span class="s">&#39;G.smeared.smeared&#39;</span><span class="p">]]]</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">data</span></code> is a dictionary containing all the correlators. Parameter
<code class="docutils literal"><span class="pre">t</span></code> specifies the times used for the diagonalization: <img class="math" src="_images/math/c0276319c9d5547dc4ede6ab06f2ef2c7d4128a5.png" alt="t_0=5" style="vertical-align: -3px"/>
and <img class="math" src="_images/math/412d89d8d0fe2ad6acdf8303ebe701c0a6530388.png" alt="t_1=7" style="vertical-align: -3px"/>. Parameter <code class="docutils literal"><span class="pre">nterm</span></code> specifies the number of terms
in the fit. <code class="docutils literal"><span class="pre">basis.make_prior(...)</span></code> creates priors
<code class="docutils literal"><span class="pre">prior['m.local']</span></code> and <code class="docutils literal"><span class="pre">prior['m.smeared']</span></code>
for the amplitudes corresponding to the local and smeared source,
and a prior <code class="docutils literal"><span class="pre">prior[log(m.dE)]</span></code> for the logarithm of the
energy differences between successive levels.</p>
<p>The amplitudes <code class="docutils literal"><span class="pre">prior['m.local']</span></code> and <code class="docutils literal"><span class="pre">prior['m.smeared']</span></code> are
complicated, with strong correlations between local and smeared entries
for the same state. Projecting the prior unto the eigen-basis,
however, reveals its underlying structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">p_eig</span> <span class="o">=</span> <span class="n">basis</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">prior</span><span class="p">)</span>
</pre></div>
</div>
<p>implies</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">p_eig</span><span class="p">[</span><span class="s">&#39;m.0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">p_eig</span><span class="p">[</span><span class="s">&#39;m.1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>where the different entries are now uncorrelated.  This structure
registers our  expectation that the <code class="docutils literal"><span class="pre">'m.0'</span></code> source in the eigen-basis
overlaps strongly with the  ground state, but almost not at all with the
first excited state; and vice versa for the <code class="docutils literal"><span class="pre">'m.1'</span></code> source.
Amplitude <code class="docutils literal"><span class="pre">p_eig</span></code> is noncommittal about  higher states. This structure
is built into <code class="docutils literal"><span class="pre">prior['m.local']</span></code> and <code class="docutils literal"><span class="pre">prior['smeared']</span></code>.</p>
<p>It is easy to check that fit results are  consistent with the underlying
prior. This can be done by projecting the  best-fit parameters unto the
eigen-basis using  <code class="docutils literal"><span class="pre">p_eig</span> <span class="pre">=</span> <span class="pre">basis.apply(fit.p)</span></code>. Alternatively, a
table listing the  amplitudes in the new eigen-basis, together with the
energies,  is printed by:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">keyfmt</span><span class="o">=</span><span class="s">&#39;m.{s1}&#39;</span><span class="p">,</span> <span class="n">eig_srcs</span><span class="o">=</span><span class="k">True</span><span class="p">))</span>
</pre></div>
</div>
<p>The prior can be adjusted, if needed, using the <code class="docutils literal"><span class="pre">dEfac</span></code>, <code class="docutils literal"><span class="pre">ampl</span></code>, and
<code class="docutils literal"><span class="pre">states</span></code> arguments in <a class="reference internal" href="#corrfitter.EigenBasis.make_prior" title="corrfitter.EigenBasis.make_prior"><code class="xref py py-func docutils literal"><span class="pre">EigenBasis.make_prior()</span></code></a>.</p>
<p><a class="reference internal" href="#corrfitter.EigenBasis.tabulate" title="corrfitter.EigenBasis.tabulate"><code class="xref py py-func docutils literal"><span class="pre">EigenBasis.tabulate()</span></code></a> is also useful for printing the amplitudes
for the original sources:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="nb">print</span><span class="p">(</span><span class="n">basis</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">keyfmt</span><span class="o">=</span><span class="s">&#39;m.{s1}&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p><a class="reference internal" href="#corrfitter.EigenBasis" title="corrfitter.EigenBasis"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.EigenBasis</span></code></a> requires the scipy library in Python.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> – Dictionary containing the matrix correlator
using the original basis of sources and sinks.</li>
<li><strong>keyfmt</strong> – Format string used to generate the keys
in dictionary <code class="docutils literal"><span class="pre">data</span></code> corresponding to different
components of the matrix of correlators. The
key for <img class="math" src="_images/math/73a91fae0f84c471244326900c17fe045aba0260.png" alt="G_{ij}" style="vertical-align: -6px"/> is assumed to be
<code class="docutils literal"><span class="pre">keyfmt.format(s1=i,</span> <span class="pre">s2=j)</span></code> where <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">j</span></code>
are drawn from the list of sources, <code class="docutils literal"><span class="pre">srcs</span></code>.</li>
<li><strong>srcs</strong> – List of source names used with <code class="docutils literal"><span class="pre">keyfmt</span></code>
to create the keys for finding correlator
components <img class="math" src="_images/math/73a91fae0f84c471244326900c17fe045aba0260.png" alt="G_{ij}" style="vertical-align: -6px"/> in the data dictionary.</li>
<li><strong>t</strong> – <code class="docutils literal"><span class="pre">t=(t0,</span> <span class="pre">t1)</span></code> specifies the <code class="docutils literal"><span class="pre">t</span></code> values
used to diagonalize the correlation function.
Larger <code class="docutils literal"><span class="pre">t</span></code> values are better than smaller ones,
but only if the statistics are adequate.
When fitting staggered-quark correlators, with oscillating
components, choose <code class="docutils literal"><span class="pre">t</span></code> values where
the oscillating pieces are positive (typically odd <code class="docutils literal"><span class="pre">t</span></code>).
If only one <code class="docutils literal"><span class="pre">t</span></code> is given, <code class="docutils literal"><span class="pre">t=t0</span></code>, then <code class="docutils literal"><span class="pre">t1=t0+2</span></code>
is used with it. Fits that use <a class="reference internal" href="#corrfitter.EigenBasis" title="corrfitter.EigenBasis"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.EigenBasis</span></code></a> typically
depend only weakly on the choice of <code class="docutils literal"><span class="pre">t</span></code>.</li>
<li><strong>tdata</strong> – Array containing the times for which there is
correlator data. <code class="docutils literal"><span class="pre">tdata</span></code> is set equal to
<code class="docutils literal"><span class="pre">numpy.arange(len(G_ij))</span></code> if it is not specified
(or equals <code class="docutils literal"><span class="pre">None</span></code>).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The interface for <a class="reference internal" href="#corrfitter.EigenBasis" title="corrfitter.EigenBasis"><code class="xref py py-class docutils literal"><span class="pre">EigenBasis</span></code></a> is experimental.
It may change in the near future, as experience
accumulates from its use.</p>
<p>In addition to <code class="docutils literal"><span class="pre">keyfmt</span></code>, <code class="docutils literal"><span class="pre">srcs</span></code>, <code class="docutils literal"><span class="pre">t</span></code> and <code class="docutils literal"><span class="pre">tdata</span></code> above,
the main attributes are:</p>
<dl class="attribute">
<dt id="corrfitter.EigenBasis.E">
<code class="descname">E</code><a class="headerlink" href="#corrfitter.EigenBasis.E" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of approximate energies obtained from the eigenanalysis.</p>
</dd></dl>

<dl class="attribute">
<dt id="corrfitter.EigenBasis.eig_srcs">
<code class="descname">eig_srcs</code><a class="headerlink" href="#corrfitter.EigenBasis.eig_srcs" title="Permalink to this definition">¶</a></dt>
<dd><p>List of labels for the sources in the eigen-basis: <code class="docutils literal"><span class="pre">'0'</span></code>, <code class="docutils literal"><span class="pre">'1'</span></code> …</p>
</dd></dl>

<dl class="attribute">
<dt id="corrfitter.EigenBasis.svdcorrection">
<code class="descname">svdcorrection</code><a class="headerlink" href="#corrfitter.EigenBasis.svdcorrection" title="Permalink to this definition">¶</a></dt>
<dd><p>The sum of the SVD corrections added to the data by the last call
to <a class="reference internal" href="#corrfitter.EigenBasis.svd" title="corrfitter.EigenBasis.svd"><code class="xref py py-func docutils literal"><span class="pre">EigenBasis.svd()</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="corrfitter.EigenBasis.svdn">
<code class="descname">svdn</code><a class="headerlink" href="#corrfitter.EigenBasis.svdn" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of degrees of freedom modified by the SVD correction
in the last call to <a class="reference internal" href="#corrfitter.EigenBasis.svd" title="corrfitter.EigenBasis.svd"><code class="xref py py-func docutils literal"><span class="pre">EigenBasis.svd()</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="corrfitter.EigenBasis.v">
<code class="descname">v</code><a class="headerlink" href="#corrfitter.EigenBasis.v" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">v[a]</span></code> is the eigenvector corresponding to source <code class="docutils literal"><span class="pre">a</span></code>
in the new basis, where <code class="docutils literal"><span class="pre">a=0,1...</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="corrfitter.EigenBasis.v_inv">
<code class="descname">v_inv</code><a class="headerlink" href="#corrfitter.EigenBasis.v_inv" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">v_inv[i]</span></code> is the inverse-eigenvector for transforming from the
new basis back to the original basis.</p>
</dd></dl>

<p>The main methods are:</p>
<dl class="method">
<dt id="corrfitter.EigenBasis.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>data</em>, <em>keyfmt=’{s1}’</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.EigenBasis.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform <code class="docutils literal"><span class="pre">data</span></code> to the eigen-basis.</p>
<p>The data to be transformed is <code class="docutils literal"><span class="pre">data[k]</span></code> where key <code class="docutils literal"><span class="pre">k</span></code>
equals <code class="docutils literal"><span class="pre">keyfmt.format(s1=s1)</span></code> for vector data,
or <code class="docutils literal"><span class="pre">keyfmt.format(s1=s1,</span> <span class="pre">s2=s2)</span></code> for matrix data with sources
<code class="docutils literal"><span class="pre">s1</span></code> and <code class="docutils literal"><span class="pre">s2</span></code> drawn from <code class="docutils literal"><span class="pre">self.srcs</span></code>.
A dictionary containing the transformed data is returned
using the same keys but with the sources replaced by <code class="docutils literal"><span class="pre">'0',</span>
<span class="pre">'1'</span> <span class="pre">...</span></code> (from <code class="docutils literal"><span class="pre">basis.eig_srcs</span></code>).</p>
<p>If <code class="docutils literal"><span class="pre">keyfmt</span></code> is an array of formats, the transformation is
applied for each format and a dictionary containing all of the
results is returned. This is useful when the same sources
and sinks are used for different types of correlators (e.g.,
in both two-point and three-point correlators).</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.EigenBasis.make_prior">
<code class="descname">make_prior</code><span class="sig-paren">(</span><em>nterm</em>, <em>keyfmt=’{s1}’</em>, <em>dEfac=‘1(1)’</em>, <em>ampl=(‘1.0(3)’</em>, <em>‘0.03(10)’</em>, <em>‘0.2(1.0)’)</em>, <em>states=None</em>, <em>eig_srcs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.EigenBasis.make_prior" title="Permalink to this definition">¶</a></dt>
<dd><p>Create prior from eigen-basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nterm</strong> (<em>int</em>) – Number of terms in fit function.</li>
<li><strong>keyfmt</strong> (<em>str</em>) – Format string usded to generate keys for
amplitudes and energies in the prior (a dictionary):
keys are obtained from <code class="docutils literal"><span class="pre">keyfmt.format(s1=a)</span></code> where
<code class="docutils literal"><span class="pre">a</span></code> is one of the original sources, <code class="docutils literal"><span class="pre">self.srcs</span></code>,
if <code class="docutils literal"><span class="pre">eig_srcs=False</span></code> (default), or one of the
eigen-sources, <code class="docutils literal"><span class="pre">self.eig_srcs</span></code>, if <code class="docutils literal"><span class="pre">eig_srcs=True</span></code>.
The key for the energy differences is generated by
<code class="docutils literal"><span class="pre">'log({})'.format(keyfmt.format(s1='dE'))</span></code>. The default
is <code class="docutils literal"><span class="pre">keyfmt={s1}</span></code>.</li>
<li><strong>dEfac</strong> (str or <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>) – A string or <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>
from which the priors for energy differences <code class="docutils literal"><span class="pre">dE[i]</span></code> are
constructed. The mean value for <code class="docutils literal"><span class="pre">dE[0]</span></code> is set equal to the
lowest energy obtained from the diagonalization. The mean
values for the other <code class="docutils literal"><span class="pre">dE[i]</span></code>s are set equal to the
difference between the lowest two energies from the
diagonalization (or to the lowest energy if there is only
one). These central values are then multiplied by
<code class="docutils literal"><span class="pre">gvar.gvar(dEfac)</span></code>. The default value, <cite>1(1)</cite>, sets the
width equal to the mean value. The prior is the logarithm of
the resulting values.</li>
<li><strong>ampl</strong> (<em>tuple</em>) – A 3-tuple of strings or <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s from
which priors are contructed for amplitudes corresponding to
the eigen-sources. <code class="docutils literal"><span class="pre">gvar.gvar(ampl[0])</span></code> is used for
for source components where the overlap with a particular
state is expected to be large; <code class="docutils literal"><span class="pre">1.0(3)</span></code> is the default value.
<code class="docutils literal"><span class="pre">gvar.gvar(ampl[1])</span></code> is used for states that are expected
to have little overlap with the source; <code class="docutils literal"><span class="pre">0.03(10)</span></code> is
the default value. <code class="docutils literal"><span class="pre">gvar.gvar(ampl[2])</span></code> is used where
there is nothing known about the overlap of a state with
the source; <code class="docutils literal"><span class="pre">0(1)</span></code> is the default value.</li>
<li><strong>states</strong> (<em>list</em>) – A list of the states in the correlator corresponding
to successive eigen-sources, where <code class="docutils literal"><span class="pre">states[i]</span></code> is the state
corresponding to <code class="docutils literal"><span class="pre">i</span></code>-th source. The correspondence between
sources and states is strong for the first sources, but
can decay for subsequent sources, depending upon the quality
of the data being used and the <code class="docutils literal"><span class="pre">t</span></code> values used in the
diagonalization. In such situations one might specify
fewer states than there are sources by making the length
of <code class="docutils literal"><span class="pre">states</span></code> smaller than the number of sources. Setting
<code class="docutils literal"><span class="pre">states=[]</span></code> assigns broad priors to the every component
of every source. Parameter <code class="docutils literal"><span class="pre">states</span></code> can also be
used to deal with situations where the order
of later sources is not aligned with that of the
actual states: for example, <code class="docutils literal"><span class="pre">states=[0,1,3]</span></code> connects the
eigen-sources with the first, second and fourth states in the
correlator. The default value, <code class="docutils literal"><span class="pre">states=[0,</span> <span class="pre">1</span> <span class="pre">...</span> <span class="pre">N-1]</span></code> where
<code class="docutils literal"><span class="pre">N</span></code> is the number of sources, assumes that sources
and states are aligned.</li>
<li><strong>eig_srcs</strong> (<em>bool</em>) – Amplitudes for the eigen-sources are
tabulated if <code class="docutils literal"><span class="pre">eig_srcs=True</span></code>; otherwise amplitudes
for the original basis of sources are tabulated (default).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="corrfitter.EigenBasis.svd">
<code class="descname">svd</code><span class="sig-paren">(</span><em>data</em>, <em>keyfmt=None</em>, <em>svdcut=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.EigenBasis.svd" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply SVD cut to data in the eigen-basis.</p>
<p>The SVD cut is applied to <code class="docutils literal"><span class="pre">data[k]</span></code> where key <code class="docutils literal"><span class="pre">k</span></code>
equals <code class="docutils literal"><span class="pre">keyfmt.format(s1=s1)</span></code> for vector data,
or <code class="docutils literal"><span class="pre">keyfmt.format(s1=s1,</span> <span class="pre">s2=s2)</span></code> for matrix data with sources
<code class="docutils literal"><span class="pre">s1</span></code> and <code class="docutils literal"><span class="pre">s2</span></code> drawn from <code class="docutils literal"><span class="pre">self.srcs</span></code>. The data
are transformed to the eigen-basis of sources/sinks before
the cut is applied and then transformed back to the
original basis of sources. Results are returned in
a dictionary containing the modified correlators.</p>
<p>If <code class="docutils literal"><span class="pre">keyfmt</span></code> is a list of formats, the SVD cut is
applied to the collection of data formed from each
format. The defaul value for <code class="docutils literal"><span class="pre">keyfmt</span></code> is
<code class="docutils literal"><span class="pre">self.keyfmt</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.EigenBasis.tabulate">
<code class="descname">tabulate</code><span class="sig-paren">(</span><em>p</em>, <em>keyfmt=’{s1}’</em>, <em>nterm=None</em>, <em>nsrcs=None</em>, <em>eig_srcs=False</em>, <em>indent=’    ‘</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.EigenBasis.tabulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create table containing energies and amplitudes for <code class="docutils literal"><span class="pre">nterm</span></code> states.</p>
<p>Given a correlator-fit result <code class="docutils literal"><span class="pre">fit</span></code> and a corresponding
<a class="reference internal" href="#corrfitter.EigenBasis" title="corrfitter.EigenBasis"><code class="xref py py-class docutils literal"><span class="pre">EigenBasis</span></code></a> object <code class="docutils literal"><span class="pre">basis</span></code>, a table listing the energies
and amplitudes for the first <code class="docutils literal"><span class="pre">N</span></code> states in correlators can be printed
using</p>
<div class="highlight-default"><div class="highlight"><pre><span class="nb">print</span> <span class="n">basis</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">N</span></code> is the number of sources and <code class="docutils literal"><span class="pre">basis</span></code> is an
<a class="reference internal" href="#corrfitter.EigenBasis" title="corrfitter.EigenBasis"><code class="xref py py-class docutils literal"><span class="pre">EigenBasis</span></code></a> object. The amplitudes are tabulated for the
original sources unless parameter <code class="docutils literal"><span class="pre">eig_srcs=True</span></code>, in which
case the amplitudes are projected onto the the eigen-basis
defined by <code class="docutils literal"><span class="pre">basis</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> – Dictionary containing parameters values.</li>
<li><strong>keyfmt</strong> – Parameters are <code class="docutils literal"><span class="pre">p[k]</span></code> where keys <code class="docutils literal"><span class="pre">k</span></code> are
obtained from <code class="docutils literal"><span class="pre">keyfmt.format(s1=s)</span></code> where <code class="docutils literal"><span class="pre">s</span></code> is one
of the original sources (<code class="docutils literal"><span class="pre">basis.srcs</span></code>) or one of the
eigen-sources (<code class="docutils literal"><span class="pre">basis.eig_srcs</span></code>). The
default definition is <code class="docutils literal"><span class="pre">'{s1}'</span></code>.</li>
<li><strong>nterm</strong> – The number of states from the fit  tabulated.
The default sets <code class="docutils literal"><span class="pre">nterm</span></code> equal to the number of
sources in the basis.</li>
<li><strong>nsrcs</strong> – The number of sources tabulated. The default
causes all sources to be tabulated.</li>
<li><strong>eig_srcs</strong> – Amplitudes for the eigen-sources are
tabulated if <code class="docutils literal"><span class="pre">eig_srcs=True</span></code>; otherwise amplitudes
for the original basis of sources are tabulated (default).</li>
<li><strong>indent</strong> – A string prepended to each line of the table.
Default is <code class="docutils literal"><span class="pre">4</span> <span class="pre">*</span> <span class="pre">'</span> <span class="pre">'</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="corrfitter.EigenBasis.unapply">
<code class="descname">unapply</code><span class="sig-paren">(</span><em>data</em>, <em>keyfmt=’{s1}’</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.EigenBasis.unapply" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform <code class="docutils literal"><span class="pre">data</span></code> from the eigen-basis to the original basis.</p>
<p>The data to be transformed is <code class="docutils literal"><span class="pre">data[k]</span></code> where key <code class="docutils literal"><span class="pre">k</span></code>
equals <code class="docutils literal"><span class="pre">keyfmt.format(s1=s1)</span></code> for vector data,
or <code class="docutils literal"><span class="pre">keyfmt.format(s1=s1,</span> <span class="pre">s2=s2)</span></code> for matrix data with sources
<code class="docutils literal"><span class="pre">s1</span></code> and <code class="docutils literal"><span class="pre">s2</span></code> drawn from <code class="docutils literal"><span class="pre">self.eig_srcs</span></code>. A dictionary
containing the transformed data is returned using the same keys but
with the original sources (from <code class="docutils literal"><span class="pre">self.srcs</span></code>).</p>
<p>If <code class="docutils literal"><span class="pre">keyfmt</span></code> is an array of formats, the transformation is
applied for each format and a dictionary containing all of the
results is returned. This is useful when the same sources
and sinks are used for different types of correlators (e.g.,
in both two-point and three-point correlators).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="fast-fit-objects">
<h2>Fast Fit Objects<a class="headerlink" href="#fast-fit-objects" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="corrfitter.fastfit">
<em class="property">class </em><code class="descclassname">corrfitter.</code><code class="descname">fastfit</code><span class="sig-paren">(</span><em>G</em>, <em>ampl=‘0(1)’</em>, <em>dE=‘1(1)’</em>, <em>E=None</em>, <em>s=(1</em>, <em>-1)</em>, <em>tp=None</em>, <em>tmin=6</em>, <em>svdcut=1e-06</em>, <em>osc=False</em>, <em>nterm=10</em><span class="sig-paren">)</span><a class="headerlink" href="#corrfitter.fastfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast fit of a two-point correlator.</p>
<p>This function class estimates <code class="docutils literal"><span class="pre">E=En[0]</span></code> and <code class="docutils literal"><span class="pre">ampl=an[0]*bn[0]</span></code>
for a two-point correlator modeled by</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Gab</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">sn</span> <span class="o">*</span> <span class="n">sum_i</span> <span class="n">an</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">bn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fn</span><span class="p">(</span><span class="n">En</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
       <span class="o">+</span> <span class="n">so</span> <span class="o">*</span> <span class="n">sum_i</span> <span class="n">ao</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">bo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fo</span><span class="p">(</span><span class="n">Eo</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">(sn,</span> <span class="pre">so)</span></code> is typically <code class="docutils literal"><span class="pre">(1,</span> <span class="pre">-1)</span></code> and</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">fn</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span>  <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="p">(</span><span class="n">tp</span><span class="o">-</span><span class="n">t</span><span class="p">))</span> <span class="c"># tp&gt;0 -- periodic</span>
       <span class="ow">or</span>   <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">tp</span><span class="o">-</span><span class="n">t</span><span class="p">))</span><span class="c"># tp&lt;0 -- anti-periodic</span>
       <span class="ow">or</span>   <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">E</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>                  <span class="c"># if tp is None (nonperiodic)</span>

<span class="n">fo</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">t</span> <span class="o">*</span> <span class="n">fn</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Prior estimates for the amplitudes and energies of excited states are
used to remove (that is, marginalize) their contributions to give
a <em>corrected</em> correlator <code class="docutils literal"><span class="pre">Gc(t)</span></code> that
includes uncertainties due to the terms removed. Estimates of <code class="docutils literal"><span class="pre">E</span></code>
are given by:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Eeff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">arccosh</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">Gc</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Gc</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">Gc</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
</pre></div>
</div>
<p>The final estimate is the weighted average <code class="docutils literal"><span class="pre">Eeff_avg</span></code> of the
<code class="docutils literal"><span class="pre">Eeff(t)</span></code>s for different <code class="docutils literal"><span class="pre">t</span></code>s. Similarly, an estimate for the
amplitude <code class="docutils literal"><span class="pre">ampl</span></code> is obtained from the weighted
average of</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">Aeff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">Gc</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">fn</span><span class="p">(</span><span class="n">Eeff_avg</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">osc=True</span></code>, an estimate is returned for <code class="docutils literal"><span class="pre">Eo[0]</span></code> rather
than <code class="docutils literal"><span class="pre">En[0]</span></code>, and <code class="docutils literal"><span class="pre">ao[0]*bo[0]</span></code> rather than <code class="docutils literal"><span class="pre">an[0]*bn[0]</span></code>.
These estimates are reliable when <code class="docutils literal"><span class="pre">Eo[0]</span></code> is smaller than
<code class="docutils literal"><span class="pre">En[0]</span></code> (and so dominates at large <code class="docutils literal"><span class="pre">t</span></code>), but probably not
otherwise.</p>
<p class="rubric">Examples</p>
<p>The following code examines a periodic correlator (period 64) at large
times (<code class="docutils literal"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">tmin</span></code>), where estimates for excited states
don’t matter much:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">corrfitter</span> <span class="k">as</span> <span class="nn">cf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">[0.305808(29) 0.079613(24) ... ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fit</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">fastfit</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">tp</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s">&#39;E =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="s">&#39; ampl =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">ampl</span><span class="p">)</span>
<span class="go">E = 0.41618(13)  ampl = 0.047686(95)</span>
</pre></div>
</div>
<p>Smaller <code class="docutils literal"><span class="pre">tmin</span></code> values can be used if (somewhat) realistic priors
are provided for the amplitudes and energy gaps:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fit</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">fastfit</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">ampl</span><span class="o">=</span><span class="s">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;0.5(5)&#39;</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">tp</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s">&#39;E =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="s">&#39; ampl =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">ampl</span><span class="p">)</span>
<span class="go">E = 0.41624(11)  ampl = 0.047704(71)</span>
</pre></div>
</div>
<p>The result here is roughly the same as from the larger <code class="docutils literal"><span class="pre">tmin</span></code>, but
this would not be true for a correlator whose signal to noise ratio
falls quickly with increasing time.</p>
<p><a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.fastfit</span></code></a> estimates the amplitude and energy at
all times larger than <code class="docutils literal"><span class="pre">tmin</span></code> and then averages to get its final
results. The chi-squared of the average (<em>e.g.</em>, <code class="docutils literal"><span class="pre">fit.E.chi2</span></code>)
gives an indication of the consistency of the estimates from different
times. The chi-squared per degree of freedom is printed out for both
the energy and the amplitude using</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
<span class="go">E: 0.41624(11) ampl: 0.047704(71) chi2/dof [dof]: 0.9 0.8 [57] Q: 0.8 0.9</span>
</pre></div>
</div>
<p>Large values for <code class="docutils literal"><span class="pre">chi2/dof</span></code> indicate an unreliable results. In
such cases the priors should be adjusted, and/or <code class="docutils literal"><span class="pre">tmin</span></code> increased,
and/or an SVD cut introduced. The averages in the example above
have good values for <code class="docutils literal"><span class="pre">chi2/dof</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>G</strong> – An array of <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>s containing the two-point correlator. <code class="docutils literal"><span class="pre">G[j]</span></code>
is assumed to correspond to time <code class="docutils literal"><span class="pre">t=j</span></code>, where <code class="docutils literal"><span class="pre">j=0...</span></code>.</li>
<li><strong>ampl</strong> – A <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code> or its string representation giving an estimate for
the amplitudes of the ground state and the excited states.  Use
<code class="docutils literal"><span class="pre">ampl=(ampln,</span> <span class="pre">amplo)</span></code> when the  correlator contains oscillating
states; <code class="docutils literal"><span class="pre">ampln</span></code> is the  estimate for non-oscillating states, and
<code class="docutils literal"><span class="pre">amplo</span></code> for  oscillating states; setting one or the other to
<code class="docutils literal"><span class="pre">None</span></code>  causes the corresponding terms to be dropped.  Default
value is <code class="docutils literal"><span class="pre">'0(1)'</span></code>.</li>
<li><strong>dE</strong> – A <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code> or its string representation giving an estimate for the
energy separation between successive states. This estimate is
also used to provide an estimate for the lowest energy
when parameter <code class="docutils literal"><span class="pre">E</span></code> is not specified. Use  <code class="docutils literal"><span class="pre">dE=(dEn,</span> <span class="pre">dEo)</span></code>
when the correlator contains oscillating states: <code class="docutils literal"><span class="pre">dEn</span></code> is the
estimate for non-oscillating states, and <code class="docutils literal"><span class="pre">dEo</span></code> for
oscillating states; setting one or the other to <code class="docutils literal"><span class="pre">None</span></code>
causes the corresponding terms to be dropped.
Default value is <code class="docutils literal"><span class="pre">'1(1)'</span></code>.</li>
<li><strong>E</strong> – A <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code> or its string representation giving an estimate for the
energy of the lowest-lying state. Use  <code class="docutils literal"><span class="pre">E=(En,</span> <span class="pre">Eo)</span></code>
when the correlator contains oscillating states: <code class="docutils literal"><span class="pre">En</span></code> is the
estimate for the lowest non-oscillating state, and <code class="docutils literal"><span class="pre">Eo</span></code> for
lowest oscillating state. Setting <code class="docutils literal"><span class="pre">E=None</span></code> causes
<code class="docutils literal"><span class="pre">E</span></code> to be set equal to <code class="docutils literal"><span class="pre">dE</span></code>. Default value is <code class="docutils literal"><span class="pre">None</span></code>.</li>
<li><strong>s</strong> – A tuple containing overall factors <code class="docutils literal"><span class="pre">(sn,</span> <span class="pre">so)</span></code> multiplying
contributions from the normal and oscillating states.
Default is <code class="docutils literal"><span class="pre">(1,-1)</span></code>.</li>
<li><strong>tp</strong> (<em>int</em><em> or </em><em>None</em>) – When not <code class="docutils literal"><span class="pre">None</span></code>, the correlator is periodic
with period <code class="docutils literal"><span class="pre">tp</span></code> when <code class="docutils literal"><span class="pre">tp&gt;0</span></code>, or anti-periodic with
period <code class="docutils literal"><span class="pre">-tp</span></code> when <code class="docutils literal"><span class="pre">tp&lt;0</span></code>. Setting <code class="docutils literal"><span class="pre">tp=None</span></code> implies
that the correlator is neither periodic nor anti-periodic.
Default is <code class="docutils literal"><span class="pre">None</span></code>.</li>
<li><strong>tmin</strong> (<em>int</em>) – Only <code class="docutils literal"><span class="pre">G(t)</span></code> with <code class="docutils literal"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">tmin</span></code> are used. Default
value is <code class="docutils literal"><span class="pre">6</span></code>.</li>
<li><strong>svdcut</strong> (<em>float</em><em> or </em><em>None</em>) – SVD cut used in the weighted average
of results from different times. (See the
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></code></a> documentation for a discussion
of SVD cuts.) Default is <code class="docutils literal"><span class="pre">1e-6</span></code>.</li>
<li><strong>osc</strong> (<em>bool</em>) – Set <code class="docutils literal"><span class="pre">osc=True</span></code> if the lowest-lying state is an
oscillating state. Default is <code class="docutils literal"><span class="pre">False</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note that specifying a single <code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code> <code class="docutils literal"><span class="pre">g</span></code> (as opposed to a tuple) for any
of parameters  <code class="docutils literal"><span class="pre">ampl</span></code>, <code class="docutils literal"><span class="pre">dE</span></code>, or <code class="docutils literal"><span class="pre">E</span></code> is equivalent to specifying the
tuple  <code class="docutils literal"><span class="pre">(g,</span> <span class="pre">None)</span></code> when <code class="docutils literal"><span class="pre">osc=False</span></code>, or the tuple <code class="docutils literal"><span class="pre">(None,</span> <span class="pre">g)</span></code> when
<code class="docutils literal"><span class="pre">osc=True</span></code>. A similar rule applies to parameter <code class="docutils literal"><span class="pre">s</span></code>.</p>
<p><a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><code class="xref py py-class docutils literal"><span class="pre">corrfitter.fastfit</span></code></a> objects have the following attributes:</p>
<dl class="attribute">
<dt id="corrfitter.fastfit.E">
<code class="descname">E</code><a class="headerlink" href="#corrfitter.fastfit.E" title="Permalink to this definition">¶</a></dt>
<dd><p>Energy of the lowest-lying state (<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>).</p>
</dd></dl>

<dl class="attribute">
<dt id="corrfitter.fastfit.ampl">
<code class="descname">ampl</code><a class="headerlink" href="#corrfitter.fastfit.ampl" title="Permalink to this definition">¶</a></dt>
<dd><p>Amplitude of the lowest-lying state (<code class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></code>).</p>
</dd></dl>

<p>Both <code class="docutils literal"><span class="pre">E</span></code> and <code class="docutils literal"><span class="pre">ampl</span></code> are obtained by averaging results calculated
for each time larger than <code class="docutils literal"><span class="pre">tmin</span></code>. These are averaged to produce
a final result. The consistency among results from different times
is measured by the chi-squared of the average. Each of <code class="docutils literal"><span class="pre">E</span></code> and <code class="docutils literal"><span class="pre">ampl</span></code>
has the following extra attributes:</p>
<dl class="attribute">
<dt id="corrfitter.fastfit.chi2">
<code class="descname">chi2</code><a class="headerlink" href="#corrfitter.fastfit.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p>chi-squared for the weighted average.</p>
</dd></dl>

<dl class="attribute">
<dt id="corrfitter.fastfit.dof">
<code class="descname">dof</code><a class="headerlink" href="#corrfitter.fastfit.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>The effective number of degrees of freedom in the weighted
average.</p>
</dd></dl>

<dl class="attribute">
<dt id="corrfitter.fastfit.Q">
<code class="descname">Q</code><a class="headerlink" href="#corrfitter.fastfit.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The probability that the chi-squared could have been larger,
by chance, assuming that the data are all Gaussain and consistent
with each other. Values smaller than 0.05 or 0.1 suggest
inconsistency. (Also called the <em>p-factor</em>.)</p>
</dd></dl>

<p>An easy way to inspect these attributes is to print the fit object <code class="docutils literal"><span class="pre">fit</span></code>
using <code class="docutils literal"><span class="pre">print(fit)</span></code>, which lists the values of the energy and amplitude,
the <code class="docutils literal"><span class="pre">chi2/dof</span></code> for each of these, the number of degrees of freedom,
and the <code class="docutils literal"><span class="pre">Q</span></code> for each.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">corrfitter</span></code> - Least-Squares Fit to Correlators</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#basic-fits">Basic Fits</a><ul>
<li><a class="reference internal" href="#a-make-data">a) make_data</a></li>
<li><a class="reference internal" href="#b-make-models">b) make_models</a></li>
<li><a class="reference internal" href="#c-make-prior">c) make_prior</a></li>
<li><a class="reference internal" href="#d-print-results">d) print_results</a></li>
</ul>
</li>
<li><a class="reference internal" href="#faster-fits">Faster Fits</a></li>
<li><a class="reference internal" href="#faster-fits-postive-parameters">Faster Fits — Postive Parameters</a></li>
<li><a class="reference internal" href="#faster-fits-marginalization">Faster Fits — Marginalization</a></li>
<li><a class="reference internal" href="#faster-fits-chained-fits">Faster Fits — Chained Fits</a></li>
<li><a class="reference internal" href="#faster-fits-faster-fitters">Faster Fits — Faster Fitters</a></li>
<li><a class="reference internal" href="#faster-fits-processed-datasets">Faster Fits — Processed Datasets</a></li>
<li><a class="reference internal" href="#accurate-fits-svd-cuts">Accurate Fits — SVD Cuts</a></li>
<li><a class="reference internal" href="#variations">Variations</a></li>
<li><a class="reference internal" href="#very-fast-but-limited-fits">Very Fast (But Limited) Fits</a></li>
<li><a class="reference internal" href="#point-correlators">3-Point Correlators</a></li>
<li><a class="reference internal" href="#testing-fits-with-simulated-data">Testing Fits with Simulated Data</a></li>
<li><a class="reference internal" href="#bootstrap-analyses">Bootstrap Analyses</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#correlator-model-objects">Correlator Model Objects</a></li>
<li><a class="reference internal" href="#corrfitter-objects"><code class="docutils literal"><span class="pre">corrfitter.CorrFitter</span></code> Objects</a></li>
<li><a class="reference internal" href="#corrfitter-eigenbasis-objects"><code class="docutils literal"><span class="pre">corrfitter.EigenBasis</span></code> Objects</a></li>
<li><a class="reference internal" href="#fast-fit-objects">Fast Fit Objects</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">corrfitter Documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="example-etas.html"
                        title="next chapter">Annotated Example: Two-Point Correlator</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="example-etas.html" title="Annotated Example: Two-Point Correlator"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="corrfitter Documentation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">corrfitter 6.0.2 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010-14, G.P. Lepage.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>