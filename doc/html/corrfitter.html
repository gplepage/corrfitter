
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>corrfitter - Least-Squares Fit to Correlators &mdash; corrfitter 3.4.1 documentation</title>
    
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.4.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="corrfitter 3.4.1 documentation" href="index.html" />
    <link rel="prev" title="corrfitter Documentation" href="index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="index.html" title="corrfitter Documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">corrfitter 3.4.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="corrfitter-least-squares-fit-to-correlators">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></tt> - Least-Squares Fit to Correlators<a class="headerlink" href="#corrfitter-least-squares-fit-to-correlators" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This module contains tools that facilitate least-squares fits, as functions
of time <tt class="docutils literal"><span class="pre">t</span></tt>, of simulation (or other statistical) data for 2-point and
3-point correlators of the form:</p>
<div class="highlight-python"><pre>Gab(t)    =  &lt;b(t) a(0)&gt;
Gavb(t,T) =  &lt;b(T) V(t) a(0)&gt;</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">T</span> <span class="pre">&gt;</span> <span class="pre">t</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>. Each correlator is modeled using <a class="reference internal" href="#corrfitter.Corr2" title="corrfitter.Corr2"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr2</span></tt></a> for 2-point
correlators, or <a class="reference internal" href="#corrfitter.Corr3" title="corrfitter.Corr3"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr3</span></tt></a> for 3-point correlators in terms of amplitudes for
each source <tt class="docutils literal"><span class="pre">a</span></tt>, sink <tt class="docutils literal"><span class="pre">b</span></tt>, and vertex <tt class="docutils literal"><span class="pre">V</span></tt>, and the energies
associated with each intermediate state. The amplitudes and energies are
adjusted in the least-squares fit to reproduce the data; they are defined
in a shared prior (typically a dictionary).</p>
<p>An object of type <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> describes a collection of correlators and is
used to fit multiple models to data simultaneously. Fitting multiple
correlators simultaneously is important if there are statistical
correlations between the correlators. Any number of correlators may be
described and fit by a single <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> object.</p>
<p>We now review the basic features of <tt class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></tt>. These features are also
illustrated in the context of a real application in an
<a class="reference internal" href="#annotated-example"><em>Annotated Example</em></a>, at the end.</p>
</div>
<div class="section" id="basic-fits">
<h2>Basic Fits<a class="headerlink" href="#basic-fits" title="Permalink to this headline">¶</a></h2>
<p>To illustrate, consider data for two 2-point correlators: <tt class="docutils literal"><span class="pre">Gaa</span></tt> with the
same source and sink (<tt class="docutils literal"><span class="pre">a</span></tt>), and <tt class="docutils literal"><span class="pre">Gab</span></tt> which has source <tt class="docutils literal"><span class="pre">a</span></tt> and
(different) sink <tt class="docutils literal"><span class="pre">b</span></tt>. The data are contained in a dictionary <tt class="docutils literal"><span class="pre">data</span></tt>,
where <tt class="docutils literal"><span class="pre">data['Gaa']</span></tt> and <tt class="docutils literal"><span class="pre">data['Gab']</span></tt> are one-dimensional arrays
containing values for <tt class="docutils literal"><span class="pre">Gaa(t)</span></tt> and <tt class="docutils literal"><span class="pre">Gab(t)</span></tt>, respectively, with
<tt class="docutils literal"><span class="pre">t=0,1,2...63</span></tt>. Each array element in <tt class="docutils literal"><span class="pre">data['Gaa']</span></tt> and <tt class="docutils literal"><span class="pre">data['Gab']</span></tt>
is a gaussian random variable of type <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>, and specifies the mean and
standard deviation for the corresponding data point:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Gaa&#39;</span><span class="p">]</span>
<span class="go">[0.159791 +- 4.13311e-06 0.0542088 +- 3.06973e-06 ... ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Gab&#39;</span><span class="p">]</span>
<span class="go">[0.156145 +- 1.83572e-05 0.102335 +- 1.5199e-05 ... ]</span>
</pre></div>
</div>
<p><tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s can also capture any statistical correlations between different
pieces of data.</p>
<p>We want to fit this data to the following formulas:</p>
<div class="highlight-python"><pre>Gaa(t,N) = sum_i=0..N-1  a[i]**2 * exp(-E[i]*t)
Gab(t,N) = sum_i=0..N-1  a[i]*b[i] * exp(-E[i]*t)</pre>
</div>
<p>Our goal is to find values for the amplitudes, <tt class="docutils literal"><span class="pre">a[i]</span></tt> and <tt class="docutils literal"><span class="pre">b[i]</span></tt>, and the
energies, <tt class="docutils literal"><span class="pre">E[i]</span></tt>, so that these formulas reproduce the average values for
<tt class="docutils literal"><span class="pre">Gaa(t,N)</span></tt> and <tt class="docutils literal"><span class="pre">Gab(t,N)</span></tt> that come from the data, to within the data&#8217;s
statistical errors. We use the same <tt class="docutils literal"><span class="pre">a[i]</span></tt>s and <tt class="docutils literal"><span class="pre">E[i]</span></tt>s in both
formulas. The fit parameters used by the fitter are the <tt class="docutils literal"><span class="pre">a[i]</span></tt>s and
<tt class="docutils literal"><span class="pre">b[i]</span></tt>s, as well as the differences <tt class="docutils literal"><span class="pre">dE[i]=E[i]-E[i-1]</span></tt> for <tt class="docutils literal"><span class="pre">i&gt;0</span></tt> and
<tt class="docutils literal"><span class="pre">dE[0]=E[0]</span></tt>. The energy differences are usually positive by construction
(see below) and are easily converted back to energies using:</p>
<div class="highlight-python"><pre>E[i] = sum_j=0..i dE[j]</pre>
</div>
<p>A typical code has the following structure:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">corrfitter</span> <span class="kn">import</span> <span class="n">CorrFitter</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">)</span>          <span class="c"># user-supplied routine</span>
<span class="n">models</span> <span class="o">=</span> <span class="n">make_models</span><span class="p">()</span>              <span class="c"># user-supplied routine</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>                               <span class="c"># number of terms in fit functions</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>               <span class="c"># user-supplied routine</span>
<span class="n">fitter</span> <span class="o">=</span> <span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>  <span class="c"># do the fit</span>
<span class="n">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>     <span class="c"># user-supplied routine</span>
</pre></div>
</div>
<p>We discuss each user-supplied routine in turn.</p>
<div class="section" id="a-make-data">
<h3>a) make_data<a class="headerlink" href="#a-make-data" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">make_data('mcfile')</span></tt> creates the dictionary containing the data that is to
be fit. Typically such data comes from a Monte Carlo simulation. Imagine that
the simulation creates a file called <tt class="docutils literal"><span class="pre">'mcfile'</span></tt> with layout</p>
<div class="highlight-python"><pre># first correlator: each line has Gaa(t) for t=0,1,2...63
Gaa  0.159774739530e+00 0.541793561501e-01 ...
Gaa  0.159751906801e+00 0.542054488624e-01 ...
Gaa  ...
.
.
.
# second correlator: each line has Gab(t) for t=0,1,2...63
Gab  0.155764170032e+00 0.102268808986e+00 ...
Gab  0.156248435021e+00 0.102341455176e+00 ...
Gab  ...
.
.
.</pre>
</div>
<p>where each line is one Monte Carlo measurement for one or the other
correlator, as indicated by the tags at the start of each line. (Lines for
<tt class="docutils literal"><span class="pre">Gab</span></tt> may be interspersed with lines for <tt class="docutils literal"><span class="pre">Gaa</span></tt> since every line has a
tag.) The data can be analyzed using the <tt class="xref py py-mod docutils literal"><span class="pre">gvar.dataset</span></tt> module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span>

<span class="k">def</span> <span class="nf">make_data</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gvar</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>
</pre></div>
</div>
<p>This reads the data from file into a dataset object (type
<tt class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></tt>) and then computes averages for each
correlator and <tt class="docutils literal"><span class="pre">t</span></tt>, together with a covariance matrix for the set of
averages. Thus <tt class="docutils literal"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">make_data('mcfile')</span></tt> creates a dictionary where
<tt class="docutils literal"><span class="pre">data['Gaa']</span></tt> is a 1-d array of <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s obtained by averaging over the
<tt class="docutils literal"><span class="pre">Gaa</span></tt> data in the <tt class="docutils literal"><span class="pre">'mcfile'</span></tt>, and <tt class="docutils literal"><span class="pre">data['Gab']</span></tt> is a similar array
for the <tt class="docutils literal"><span class="pre">Gab</span></tt> correlator.</p>
</div>
<div class="section" id="b-make-models">
<h3>b) make_models<a class="headerlink" href="#b-make-models" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">make_models()</span></tt> identifies which correlators in the fit data are to be fit,
and specifies theoretical models (that is, fit functions) for these
correlators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">corrfitter</span> <span class="kn">import</span> <span class="n">Corr2</span>

<span class="k">def</span> <span class="nf">make_models</span><span class="p">():</span>
    <span class="n">models</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gaa&#39;</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
                    <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">),</span>

               <span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gab&#39;</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
                    <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">)</span>
             <span class="p">]</span>
    <span class="k">return</span> <span class="n">models</span>
</pre></div>
</div>
<p>For each correlator, we specify: the key used in the input data dictionary
<tt class="docutils literal"><span class="pre">data</span></tt> for that correlator (<tt class="docutils literal"><span class="pre">datatag</span></tt>); the values of <tt class="docutils literal"><span class="pre">t</span></tt> for which
results are given in the input data (<tt class="docutils literal"><span class="pre">tdata</span></tt>); the values of <tt class="docutils literal"><span class="pre">t</span></tt> to
keep for fits (<tt class="docutils literal"><span class="pre">tfit</span></tt>, here the same as the range in the input data, but
could be any subset); and fit-parameter labels for the source (<tt class="docutils literal"><span class="pre">a</span></tt>) and
sink (<tt class="docutils literal"><span class="pre">b</span></tt>) amplitudes, and for the intermediate energy-differences
(<tt class="docutils literal"><span class="pre">dE</span></tt>). Fit-parameter labels identify the parts of the prior,
discussed below, corresponding to the actual fit parameters (the labels are
dictionary keys). Here the two models, for <tt class="docutils literal"><span class="pre">Gaa</span></tt> and <tt class="docutils literal"><span class="pre">Gab</span></tt>, are
identical except for the data tags and the sinks. <tt class="docutils literal"><span class="pre">make_models()</span></tt> returns
a list of models; the only parts of the input fit data that are fit are
those for which a model is specified in <tt class="docutils literal"><span class="pre">make_models()</span></tt>.</p>
<p>Note that if there is data for <tt class="docutils literal"><span class="pre">Gba(t,N)</span></tt> in addition to <tt class="docutils literal"><span class="pre">Gab(t,N)</span></tt>, and
<tt class="docutils literal"><span class="pre">Gba</span> <span class="pre">=</span> <span class="pre">Gab</span></tt>, then the (weighted) average of the two data sets will be
fit if <tt class="docutils literal"><span class="pre">models[1]</span></tt> is replace by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gab&#39;</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
     <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="n">dE</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
     <span class="n">othertags</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Gba&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The additional argument <tt class="docutils literal"><span class="pre">othertags</span></tt> lists other data tags that correspond
to the same physical quantity; the data for all equivalent data tags is
averaged before fitting (using <tt class="xref py py-func docutils literal"><span class="pre">lsqfit.wavg()</span></tt>). Alternatively (and
equivalently) one could add a third <tt class="docutils literal"><span class="pre">Corr2</span></tt> to <tt class="docutils literal"><span class="pre">models</span></tt> for <tt class="docutils literal"><span class="pre">Gba</span></tt>,
but it is more efficient to combine it with <tt class="docutils literal"><span class="pre">Gab</span></tt> in this way if they are
equivalent.</p>
</div>
<div class="section" id="c-make-prior">
<h3>c) make_prior<a class="headerlink" href="#c-make-prior" title="Permalink to this headline">¶</a></h3>
<p>This routine defines the fit parameters that correspond to each fit-parameter
label used in <tt class="docutils literal"><span class="pre">make_models()</span></tt> above. It also assigns <em>a priori</em> values to
each parameter, expressed in terms of gaussian random variables (<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s),
with a mean and standard deviation. The prior is built using class
<tt class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span>

<span class="k">def</span> <span class="nf">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>       <span class="c"># prior = {}  works too</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;dE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">prior</span>
</pre></div>
</div>
<p>(<tt class="xref py py-class docutils literal"><span class="pre">gvar.BufferDict</span></tt> can be replaced by an ordinary Python dictionary;
it is used here because it remembers the order in which the keys are added.)
<tt class="docutils literal"><span class="pre">make_prior(N)</span></tt> associates arrays of <tt class="docutils literal"><span class="pre">N</span></tt> gaussian random variables
(<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s) with each fit-parameter label, enough for <tt class="docutils literal"><span class="pre">N</span></tt> terms in the fit
function. These are the <em>a priori</em> values for the fit parameters, and they
can be retrieved using the label: setting <tt class="docutils literal"><span class="pre">prior=make_prior(N)</span></tt>, for
example, implies that <tt class="docutils literal"><span class="pre">prior['a'][i]</span></tt>, <tt class="docutils literal"><span class="pre">prior['b'][i]</span></tt> and
<tt class="docutils literal"><span class="pre">prior['dE'][i]</span></tt> are the <em>a priori</em> values for <tt class="docutils literal"><span class="pre">a[i]</span></tt>, <tt class="docutils literal"><span class="pre">b[i]</span></tt> and
<tt class="docutils literal"><span class="pre">dE[i]</span></tt> in the fit functions (see above). The <em>a priori</em> value for each
<tt class="docutils literal"><span class="pre">a[i]</span></tt> here is set to <tt class="docutils literal"><span class="pre">0.1+-0.5</span></tt>, while that for each <tt class="docutils literal"><span class="pre">b[i]</span></tt> is
<tt class="docutils literal"><span class="pre">1+-5</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">prior</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>
<span class="go">[0.1 +- 0.5 0.1 +- 0.5 0.1 +- 0.5 0.1 +- 0.5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">prior</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span>
<span class="go">[1 +- 5 1 +- 5 1 +- 5 1 +- 5]</span>
</pre></div>
</div>
<p>Similarly the <em>a priori</em> value for each energy difference is <tt class="docutils literal"><span class="pre">0.25+-0.25</span></tt>.
(See the <tt class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></tt> documentation for further information on priors.)</p>
</div>
<div class="section" id="d-print-results">
<h3>d) print_results<a class="headerlink" href="#d-print-results" title="Permalink to this headline">¶</a></h3>
<p>The actual fit is done by <tt class="docutils literal"><span class="pre">fit=fitter.lsqfit(...)</span></tt>, which also prints out
a summary of the fit results (this output can be suppressed if desired).
Further results are reported by <tt class="docutils literal"><span class="pre">print_results(fit,</span> <span class="pre">prior,</span> <span class="pre">data)</span></tt>: for
example,</p>
<div class="highlight-python"><pre>def print_results(fit, prior, data):
    a = fit.p['a']                              # array of a[i]s
    b = fit.p['b']                              # array of b[i]s
    dE = fit.p['dE']                            # array of dE[i]s
    E = [sum(dE[:i+1]) for i in range(len(dE))] # array of E[i]s
    print 'Best fit values:
    print '     a[0] =',a[0]
    print '     b[0] =',b[0]
    print '     E[0] =',E[0]
    print 'b[0]/a[0] =',b[0]/a[0]
    outputs = {'E0':E[0], 'a0':a[0], 'b0':b[0], 'b0/a0':b[0]/a[0]}
    inputs = {'a'=prior['a'], 'b'=prior['b'], 'dE'=prior['dE'],
              'data'=[data[k] for k in data])
    print fit.fmt_errorbudget(outputs, inputs)</pre>
</div>
<p>The best-fit values from the fit are contained in <tt class="docutils literal"><span class="pre">fit.p</span></tt> and are accessed
using the labels defined in the prior and the <a class="reference internal" href="#corrfitter.Corr2" title="corrfitter.Corr2"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr2</span></tt></a> models. Variables like
<tt class="docutils literal"><span class="pre">a[0]</span></tt> and <tt class="docutils literal"><span class="pre">E[0]</span></tt> are <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt> objects that contain means and standard
deviations, as well as information about any correlations that might exist
between different variables (which is relevant for computing functions of the
parameters, like <tt class="docutils literal"><span class="pre">b[0]/a[0]</span></tt> in this example).</p>
<p>The last line of <tt class="docutils literal"><span class="pre">print_results(fit,prior,data)</span></tt> prints an error budget for
each of the best-fit results for <tt class="docutils literal"><span class="pre">a[0]</span></tt>, <tt class="docutils literal"><span class="pre">b[0]</span></tt>, <tt class="docutils literal"><span class="pre">E[0]</span></tt> and
<tt class="docutils literal"><span class="pre">b[0]/a[0]</span></tt>, which are identified in the print output by the labels
<tt class="docutils literal"><span class="pre">'a0'</span></tt>, <tt class="docutils literal"><span class="pre">'b0'</span></tt>, <tt class="docutils literal"><span class="pre">'E0'</span></tt> and <tt class="docutils literal"><span class="pre">'b0/a0'</span></tt>, respectively. The error for any
fit result comes from uncertainties in the inputs &#8212; in particular, from the
fit data and the priors. The error budget breaks the total error for a
result down into the components coming from each source. Here the sources are
the <em>a priori</em> errors in the priors for the <tt class="docutils literal"><span class="pre">'a'</span></tt> amplitudes, the <tt class="docutils literal"><span class="pre">'b'</span></tt>
amplitudes, and the <tt class="docutils literal"><span class="pre">'dE'</span></tt> energy differences, as well as the errors in
the fit data <tt class="docutils literal"><span class="pre">data</span></tt>. These sources are labeled in the print output by
<tt class="docutils literal"><span class="pre">'a'</span></tt>, <tt class="docutils literal"><span class="pre">'b'</span></tt>, <tt class="docutils literal"><span class="pre">'dE'</span></tt>, and <tt class="docutils literal"><span class="pre">'data'</span></tt>, respectively. (See the
<tt class="xref py py-mod docutils literal"><span class="pre">gvar</span></tt>/<tt class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></tt> tutorial for further details on partial standard
deviations and <tt class="xref py py-func docutils literal"><span class="pre">gvar.fmt_errorbudget()</span></tt>.)</p>
<p>Plots of the fit data divided by the fit function, for each correlator, are
displayed by calling <tt class="docutils literal"><span class="pre">fitter.display_plots()</span></tt> provided the <tt class="xref py py-mod docutils literal"><span class="pre">matplotlib</span></tt>
module is present.</p>
</div>
</div>
<div class="section" id="faster-fits">
<span id="id1"></span><h2>Faster Fits<a class="headerlink" href="#faster-fits" title="Permalink to this headline">¶</a></h2>
<p>Good fits often require fit functions with several exponentials and many
parameters. Such fits can be costly. One strategy that can speed things up is
to use fits with fewer terms to generate estimates for the most important
parameters. These estimates are then used as starting values for the full
fit. The smaller fit is usually faster, because it has fewer parameters, but
the fit is not adequate (because there are too few parameters). Fitting the
full fit function is usually faster given reasonable starting estimates, from
the smaller fit, for the most important parameters. Continuing with the
example from the previous section, the code</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">)</span>
<span class="n">fitter</span> <span class="o">=</span> <span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">make_models</span><span class="p">())</span>
<span class="n">p0</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]:</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>
    <span class="n">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">pmean</span>
</pre></div>
</div>
<p>does fits using fit functions with <tt class="docutils literal"><span class="pre">N=1...8</span></tt> terms. Parameter mean-values
<tt class="docutils literal"><span class="pre">fit.pmean</span></tt> from the fit with <tt class="docutils literal"><span class="pre">N</span></tt> exponentials are used as starting values
<tt class="docutils literal"><span class="pre">p0</span></tt> for the fit with <tt class="docutils literal"><span class="pre">N+1</span></tt> exponentials, hopefully reducing the time
required to find the best fit for <tt class="docutils literal"><span class="pre">N+1</span></tt>.</p>
</div>
<div class="section" id="faster-fits-postive-parameters">
<span id="positive-parameters"></span><h2>Faster Fits &#8212; Postive Parameters<a class="headerlink" href="#faster-fits-postive-parameters" title="Permalink to this headline">¶</a></h2>
<p>Priors used in <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> assign an <em>a priori</em> gaussian/normal
distribution to each parameter. It is possible instead to assign a log-normal
distribution, which forces the corresponding parameter to be positive. This is
done by choosing a label in the prior that begins with &#8220;log&#8221;: for example,
<tt class="docutils literal"><span class="pre">'logdE'</span></tt> instead of <tt class="docutils literal"><span class="pre">'dE'</span></tt>. The fitter implements the log-normal
distribution by using the parameter&#8217;s logarithm, instead of the parameter
itself, as the new fit parameter; the logarithm has a gaussian/normal
distribution. The original parameter is recovered inside the fit function (and
elsewhere) by taking the  exponential of the new fit parameter.</p>
<p>Using log-normal distributions where possible can significantly improve the
stability of a fit. This is because otherwise the fit function typically has
many symmetries that lead to large numbers of equivalent but different best
fits. For example, the fit functions <tt class="docutils literal"><span class="pre">Gaa(t,N)</span></tt> and <tt class="docutils literal"><span class="pre">Gab(t,N)</span></tt> above are
unchanged by exchanging <tt class="docutils literal"><span class="pre">a[i]</span></tt>, <tt class="docutils literal"><span class="pre">b[i]</span></tt> and <tt class="docutils literal"><span class="pre">E[i]</span></tt> with <tt class="docutils literal"><span class="pre">a[j]</span></tt>,
<tt class="docutils literal"><span class="pre">b[j]</span></tt> and <tt class="docutils literal"><span class="pre">E[j]</span></tt> for any <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt>. We can remove this degeneracy
by using a log-normal distribution for the <tt class="docutils literal"><span class="pre">dE[i]</span></tt>s since this guarantees
that all <tt class="docutils literal"><span class="pre">dE[i]</span></tt>s are positive, and therefore that <tt class="docutils literal"><span class="pre">E[0],E[1],E[2]...</span></tt>
are ordered (in decreasing order of importance to the fit at large <tt class="docutils literal"><span class="pre">t</span></tt>).</p>
<p>Another symmetry of <tt class="docutils literal"><span class="pre">Gaa</span></tt> and <tt class="docutils literal"><span class="pre">Gab</span></tt>, which leaves both fit functions
unchanged, is replacing <tt class="docutils literal"><span class="pre">a[i],b[i]</span></tt> by <tt class="docutils literal"><span class="pre">-a[i],-b[i]</span></tt>. Yet another is to
add a new term to the fit functions with <tt class="docutils literal"><span class="pre">a[k],b[k],dE[k]</span></tt> where <tt class="docutils literal"><span class="pre">a[k]=0</span></tt>
and the other two have arbitrary values. Both of these symmetries can be
removed by using a log-normal distribution for the <tt class="docutils literal"><span class="pre">a[i]</span></tt> priors, thereby
forcing all <tt class="docutils literal"><span class="pre">a[i]&gt;0</span></tt>.</p>
<p>The log-normal distributions for the <tt class="docutils literal"><span class="pre">a[i]</span></tt> and <tt class="docutils literal"><span class="pre">dE[i]</span></tt> are introduced
into the code example above by changing the corresponding labels in
<tt class="docutils literal"><span class="pre">make_prior(N)</span></tt>,  and taking logarithms of the corresponding prior values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">gvar</span> <span class="kn">import</span> <span class="n">log</span>                        <span class="c"># numpy.log() works too</span>

<span class="k">def</span> <span class="nf">make_models</span><span class="p">():</span>                          <span class="c"># same as before</span>
    <span class="n">models</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gaa&#39;</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
                     <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">),</span>

               <span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gab&#39;</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
                     <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">dE</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">)</span>
             <span class="p">]</span>
    <span class="k">return</span> <span class="n">models</span>

<span class="k">def</span> <span class="nf">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>               <span class="c"># prior = {}  works too</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;loga&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;logdE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">prior</span>
</pre></div>
</div>
<p>This replaces the original fit parameters, <tt class="docutils literal"><span class="pre">a[i]</span></tt> and <tt class="docutils literal"><span class="pre">dE[i]</span></tt>, by new fit
parameters, <tt class="docutils literal"><span class="pre">log(a[i])</span></tt> and <tt class="docutils literal"><span class="pre">log(dE[i])</span></tt>. The <em>a priori</em> distributions for
the logarithms are gaussian/normal, with priors of <tt class="docutils literal"><span class="pre">log(0.1+-0.5)</span></tt> and
<tt class="docutils literal"><span class="pre">log(0.25+-0.25)</span></tt> for the <tt class="docutils literal"><span class="pre">log(a)</span></tt>s and <tt class="docutils literal"><span class="pre">log(dE)</span></tt>s respectively.</p>
<p>Note that the labels are unchanged here in <tt class="docutils literal"><span class="pre">make_models()</span></tt>. It is
unnecessary to change labels in the models; <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> will automatically
connect the  modified terms in the prior with the appropriate terms in the
models. This allows one to switch back and forth between log-normal and normal
distributions without changing the models &#8212; only the names in the prior
need be changed. <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> also supports &#8220;sqrt-normal&#8221; distributions,
which are indicated by <tt class="docutils literal"><span class="pre">'sqrt'</span></tt> at the start of a parameter-name in the
prior; the actual parameter in the fit function is the square of this fit-
parameter, and so is again positive.</p>
<p>Note also that only a few lines in <tt class="docutils literal"><span class="pre">print_results(fit,prior,data)</span></tt>, above,
would change had we used log-normal priors for <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">dE</span></tt>:</p>
<div class="highlight-python"><pre>from gvar import exp                        # numpy.exp() works too
...
a = fit.transformed_p['a'])                 # array of a[i]s
...
dE = fit.transformed_p['dE']                # array of dE[i]s
...
inputs = {'loga':prior['loga'], 'b':prior['b'], 'logdE':fit.prior['logdE'],
          'data':[data[k] for k in data]}
...</pre>
</div>
</div>
<div class="section" id="faster-fits-chained-fits">
<span id="chained-fits"></span><h2>Faster Fits &#8212; Chained Fits<a class="headerlink" href="#faster-fits-chained-fits" title="Permalink to this headline">¶</a></h2>
<p>Large complicated fits, where lots of models and data are fit simultaneously,
can  take a very long time. This is especially true if there are strong
correlations in the data. Such correlations can also cause  problems from
numerical roundoff errors when the inverse of the data&#8217;s covariance matrix is
computed for the <tt class="docutils literal"><span class="pre">chi**2</span></tt> function, requiring large <em>svd</em> cuts which can
degrade precision (see below). An alternative approach, that often leads to
more robust and faster fits, is to used <em>chained</em> fits.  In a chained fit,
each model is fit by itself in sequence, but with the best-fit parameters from
each fit serving as priors for fit parameters in  the next fit. All parameters
from one fit become fit parameters in the next, including those parameters
that are  not explicitly needed by the next fit (since they may be correlated
with the input data for the next fit or with its priors). Statistical
correlations between data/priors from different models are preserved
throughout (this is essential to the method).</p>
<p>The results from a chained fit are identical to a standard simultaneous fit in
the limit of large statistics (that is, in the gaussian limit), but a  chained
fit never involves fitting more than a single correlator at a time.
Single-correlator fits are usually much faster than simultaneous multi-correlator
fits, and roundoff errors (and therefore <em>svd</em> cuts) are much less of a
problem. Consequently chained fits can be more accurate in practice than
conventional simultaneous fits, especially for high-statistics data.</p>
<p>Converting to chained fits is trivial: simply replace <tt class="docutils literal"><span class="pre">fitter.lsqfit(...)</span></tt>
by <tt class="docutils literal"><span class="pre">fitter.chained_lsqfit(...)</span></tt>. The output from this function represents
the results for the entire chain of fits, and so can be used in exactly the
same way as the  output from <tt class="xref py py-func docutils literal"><span class="pre">fitter.lsqfit()</span></tt> (and is usually quite
similar, to within statistical errors). Results from the different links in
the chain &#8212; that is, from the fits for individual models &#8212; can be accessed
after the fit using <tt class="docutils literal"><span class="pre">fitter.chained_fits[datatag]</span></tt> where <tt class="docutils literal"><span class="pre">datatag</span></tt> is the
data tag for the model of interest.</p>
<p>It is sometimes useful to follow a chained fit with an ordinary fit,
but using the best-fit parameters from the chained fit as the prior for
the ordinary fit: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">chained_lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">svdcut</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have included a fairly large <em>svd</em> cut in the second fit
to avoid possible problems with roundoff errors. The second fit should,
in principle, have no effect on the results since it adds no new
information. In some cases, however, it polishes the results by making small
(compared to the errors) corrections that tighten up the overall fit. It is
generally fairly fast since the prior (<tt class="docutils literal"><span class="pre">fit.p</span></tt>) is relatively narrow.</p>
</div>
<div class="section" id="faster-fits-marginalization">
<span id="marginalized-fits"></span><h2>Faster Fits &#8212; Marginalization<a class="headerlink" href="#faster-fits-marginalization" title="Permalink to this headline">¶</a></h2>
<p>Often we care only about parameters in the leading term of the fit function,
or just a few of the leading terms. The non-leading terms are needed for a
good fit, but we are uninterested in the values of their parameters. In such
cases the non-leading terms can be absorbed into the fit data, leaving behind
only the leading terms to be fit (to the modified fit data) &#8212; non-leading
parameters are, in effect, integrated out of the analysis, or <em>marginalized</em>.
The errors in the modified data are adjusted to account for uncertainties in
the marginalized terms, as specified by their priors. The resulting fit
function has many fewer parameters, and so the fit can be much faster.</p>
<p>Continuing with the example in <a class="reference internal" href="#faster-fits"><em>Faster Fits</em></a>, imagine that <tt class="docutils literal"><span class="pre">Nmax=8</span></tt>
terms are needed to get a good fit, but we only care about parameter values
for the first couple of terms. The code from that section can be modified to
fit only the leading <tt class="docutils literal"><span class="pre">N</span></tt> terms where <tt class="docutils literal"><span class="pre">N&lt;Nmax</span></tt>, while incorporating
(marginalizing) the remaining, non-leading terms as corrections to the data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Nmax</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">)</span>
<span class="n">models</span> <span class="o">=</span> <span class="n">make_models</span><span class="p">()</span>
<span class="n">fitter</span> <span class="o">=</span> <span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">make_models</span><span class="p">())</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">Nmax</span><span class="p">)</span>        <span class="c"># build priors for Nmax terms</span>
<span class="n">p0</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">nterm</span><span class="o">=</span><span class="n">N</span><span class="p">)</span> <span class="c"># fit N terms</span>
    <span class="n">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">pmean</span>
</pre></div>
</div>
<p>Here the <tt class="docutils literal"><span class="pre">nterm</span></tt> parameter in <tt class="docutils literal"><span class="pre">fitter.lsqfit</span></tt> specifies how many terms are
used in the fit functions. The prior specifies <tt class="docutils literal"><span class="pre">Nmax</span></tt> terms in all, but only
parameters in <tt class="docutils literal"><span class="pre">nterm=N</span></tt> terms are varied in the fit. The remaining terms
specified by the prior are automatically incorporated into the fit data by
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>.</p>
<p>Remarkably this method is often as accurate with <tt class="docutils literal"><span class="pre">N=1</span></tt> or <tt class="docutils literal"><span class="pre">2</span></tt> as a full
<tt class="docutils literal"><span class="pre">Nmax</span></tt>-term fit with the original fit data; but it is much faster. If this
is not the case, check for singular priors, where the mean is much smaller
than the standard deviation. These can lead to singularities in the covariance
matrix for the corrected fit data. Such priors are easily fixed: for example,
use <tt class="docutils literal"><span class="pre">gvar.gvar(0.1,1.)</span></tt> rather than <tt class="docutils literal"><span class="pre">gvar.gvar(0.0,1.)</span></tt>.
In some situations an <em>svd</em> cut (see below) can also
help.</p>
</div>
<div class="section" id="variations">
<h2>Variations<a class="headerlink" href="#variations" title="Permalink to this headline">¶</a></h2>
<p>Any 2-point correlator can be turned into a periodic function of <tt class="docutils literal"><span class="pre">t</span></tt> by
specifying the period through parameter <tt class="docutils literal"><span class="pre">tp</span></tt>. Doing so causes the
replacement (for <tt class="docutils literal"><span class="pre">tp&gt;0</span></tt>)</p>
<div class="highlight-python"><pre>exp(-E[i]*t)   -&gt;   exp(-E[i]*t) + exp(-E[i]*(tp-t))</pre>
</div>
<p>in the fit function. If <tt class="docutils literal"><span class="pre">tp</span></tt> is negative, the function is replaced by
an anti-periodic function with period <tt class="docutils literal"><span class="pre">abs(tp)</span></tt> and (for <tt class="docutils literal"><span class="pre">tp&lt;0</span></tt>):</p>
<div class="highlight-python"><pre>exp(-E[i]*t)   -&gt;   exp(-E[i]*t) - exp(-E[i]*(abs(tp)-t))</pre>
</div>
<p>Also (or alternatively) oscillating terms can be added to the fit by
modifying parameter <tt class="docutils literal"><span class="pre">s</span></tt> and by specifying sources, sinks and energies for
the oscillating pieces. For example, one might want to replace the sum of
exponentials with two sums</p>
<div class="highlight-python"><pre>sum_i a[i]**2 * exp(-E[i]*t) - sum_i ao[i]**2 (-1)**t * exp(-Eo[i]*t)</pre>
</div>
<p>in a (nonperiodic) fit function. Then an appropriate model
would be, for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Corr2</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Gaa&#39;</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
      <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dE</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;logdE&#39;</span><span class="p">,</span><span class="s">&#39;logdEo&#39;</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">ao</span></tt> and <tt class="docutils literal"><span class="pre">dEo</span></tt> refer to additional fit parameters describing
the oscillating component. In general parameters for amplitudes and
energies can be tuples with two components: the first describing normal
states, and the second describing oscillating states. To omit one or the
other, put <tt class="docutils literal"><span class="pre">None</span></tt> in place of a label. Parameter <tt class="docutils literal"><span class="pre">s[0]</span></tt> is an overall
factor multiplying the non-oscillating terms, and <tt class="docutils literal"><span class="pre">s[1]</span></tt> is the
corresponding factor for the oscillating terms.</p>
<p>Highly correlated data can lead to problems from numerical roundoff errors,
particularly where the fit code inverts the covariance matrix when
constructing the <tt class="docutils literal"><span class="pre">chi**2</span></tt> function. Such problems show up as unexpectedly
large <tt class="docutils literal"><span class="pre">chi**2</span></tt> or fits that stall and appear never to converge. Such
situations are usually improved by introducing an <em>svd</em> cut: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">svdcut</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
</pre></div>
</div>
<p>Introducing an <em>svd</em> cut increases the effective errors and so is a
conservative move. For more information about <em>svd</em> cuts see the <tt class="xref py py-mod docutils literal"><span class="pre">lsqfit</span></tt>
tutorial and documentation. Parameters <tt class="docutils literal"><span class="pre">svdcut</span></tt> and <tt class="docutils literal"><span class="pre">svdnum</span></tt> are used to
specify an <em>svd</em> cut. (It is often useful to to set <tt class="docutils literal"><span class="pre">svdnum</span></tt> equal to the
number of measurements used to determine the covariance matrix for <tt class="docutils literal"><span class="pre">G(t)</span></tt>
since that is the largest number of eigenmodes possible in the covariance
matrix.)</p>
</div>
<div class="section" id="very-fast-but-limited-fits">
<h2>Very Fast (But Limited) Fits<a class="headerlink" href="#very-fast-but-limited-fits" title="Permalink to this headline">¶</a></h2>
<p>At large <tt class="docutils literal"><span class="pre">t</span></tt>, correlators are dominated by the term with the smallest
<tt class="docutils literal"><span class="pre">E</span></tt>, and often it is only the parameters in that leading term that are
needed. In such cases there is a very fast analysis that is often almost
as accurate as a full fit. An example is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">corrfitter</span> <span class="kn">import</span> <span class="n">fastfit</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">)</span>    <span class="c"># user-supplied routine - fit data</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>                        <span class="c"># number of terms in fit functions</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>         <span class="c"># user-supplied routine - fit prior</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Corr2</span><span class="p">(</span><span class="n">a</span><span class="o">=...</span><span class="p">,</span> <span class="n">b</span><span class="o">=...</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="c"># create model describing correlator</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fastfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;E[0] =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">E</span><span class="p">)</span>                  <span class="c"># E[0]</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;a[0]*b[0] =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">ampl</span><span class="p">)</span>          <span class="c"># a[0]*b[0]</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;chi2/dof =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">chi2</span><span class="o">/</span><span class="n">fit</span><span class="o">.</span><span class="n">dof</span><span class="p">)</span>   <span class="c"># good fit if of order 1 or less</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Q =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span>             <span class="c"># good fit if Q bigger than about 0.1</span>
</pre></div>
</div>
<p><tt class="xref py py-class docutils literal"><span class="pre">fastfit</span></tt> estimates <tt class="docutils literal"><span class="pre">E[0]</span></tt> by using the prior, in effect, to
remove (<em>marginalize</em>) all terms from the correlator other than the
<tt class="docutils literal"><span class="pre">E[0]</span></tt> term: so the data <tt class="docutils literal"><span class="pre">Gdata(t)</span></tt> for the correlator is replaced by,
for example,</p>
<div class="highlight-python"><pre>Gdata(t) - sum_i=1..N-1  a[i]*b[i] * exp(-E[i]*t)</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">a[i]</span></tt>, <tt class="docutils literal"><span class="pre">b[i]</span></tt>, and <tt class="docutils literal"><span class="pre">E[i]</span></tt> for <tt class="docutils literal"><span class="pre">i&gt;0</span></tt> are replaced by their
values in the prior. The modified prior is then fit by a single term,
<tt class="docutils literal"><span class="pre">a[0]</span> <span class="pre">*</span> <span class="pre">b[0]</span> <span class="pre">*</span> <span class="pre">exp(-E[0]*t)</span></tt>, which means that a fit is not necessary
(since the functional form is so simple). It is important to check the
<tt class="docutils literal"><span class="pre">chi**2</span></tt> of the fit, to make sure the fit is good. If it is not, try
restricting <tt class="docutils literal"><span class="pre">model.tfit</span></tt> to larger <tt class="docutils literal"><span class="pre">t</span></tt>s (<tt class="xref py py-class docutils literal"><span class="pre">fastfit</span></tt> averages
estimates from all <tt class="docutils literal"><span class="pre">t</span></tt>s in <tt class="docutils literal"><span class="pre">model.tfit</span></tt>).</p>
<p>The marginalization of terms with larger <tt class="docutils literal"><span class="pre">E</span></tt>s allows the code to use
information from much smaller <tt class="docutils literal"><span class="pre">t</span></tt>s than otherwise, increasing precision.
It also quantifies the uncertainty caused by the existence of these terms.
This simple analysis is a special case of the more general marginalization
strategy discussed in <a class="reference internal" href="#faster-fits"><em>Faster Fits</em></a>, above.</p>
</div>
<div class="section" id="point-correlators">
<h2>3-Point Correlators<a class="headerlink" href="#point-correlators" title="Permalink to this headline">¶</a></h2>
<p>Correlators <tt class="docutils literal"><span class="pre">Gavb(t,T)</span> <span class="pre">=</span> <span class="pre">&lt;b(T)</span> <span class="pre">V(t)</span> <span class="pre">a(0)&gt;</span></tt> can also be included in fits
as functions of <tt class="docutils literal"><span class="pre">t</span></tt>. In the illustration above, for example, we might
consider additional Monte Carlo data describing a form factor with the
same intermediate states before and after <tt class="docutils literal"><span class="pre">V(t)</span></tt>. Assuming the data is
tagged by <tt class="docutils literal"><span class="pre">aVbT15</span></tt> and describes <tt class="docutils literal"><span class="pre">T=15</span></tt>, the corresponding entry in the
collection of models might then be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Corr3</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;aVbT15&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
    <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span>                <span class="c"># parameters for V</span>
    <span class="n">a</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">dEa</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">,</span>          <span class="c"># parameters for a-&gt;V</span>
    <span class="n">b</span><span class="o">=</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">dEb</span><span class="o">=</span><span class="s">&#39;dE&#39;</span><span class="p">,</span>          <span class="c"># parameters for V-&gt;b</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>This models the Monte Carlo data for the 3-point function using the
following formula:</p>
<div class="highlight-python"><pre>sum_i,j a[i] * exp(-Ea[i]*t) * Vnn[i,j] * b[j] * exp(-Eb[j]*t)</pre>
</div>
<p>where the <tt class="docutils literal"><span class="pre">Vnn[i,j]</span></tt>s are new fit parameters related to <tt class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></tt> form
factors. Obviously multiple values of <tt class="docutils literal"><span class="pre">T</span></tt> can be studied by including
multiple <a class="reference internal" href="#corrfitter.Corr3" title="corrfitter.Corr3"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr3</span></tt></a> models, one for each value of <tt class="docutils literal"><span class="pre">T</span></tt>. Either or both of the
initial and final states can have oscillating components (include <tt class="docutils literal"><span class="pre">sa</span></tt>
and/or <tt class="docutils literal"><span class="pre">sb</span></tt>), or can be periodic (include <tt class="docutils literal"><span class="pre">tpa</span></tt> and/or <tt class="docutils literal"><span class="pre">tpb</span></tt>). If
there are oscillating states then additional <tt class="docutils literal"><span class="pre">V</span></tt>s must be specified:
<tt class="docutils literal"><span class="pre">Vno</span></tt> connecting a normal state to an oscillating state, <tt class="docutils literal"><span class="pre">Von</span></tt>
connecting oscillating to normal states, and <tt class="docutils literal"><span class="pre">Voo</span></tt> connecting oscillating
to oscillating states.</p>
<p>There are two cases that require special treatment. One is when
simultaneous fits are made to <tt class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></tt> and <tt class="docutils literal"><span class="pre">b-&gt;V-&gt;a</span></tt>. Then the
<tt class="docutils literal"><span class="pre">Vnn</span></tt>, <tt class="docutils literal"><span class="pre">Vno</span></tt>, <em>etc.</em> for <tt class="docutils literal"><span class="pre">b-&gt;V-&gt;a</span></tt> are the (matrix) transposes of
the the same matrices for <tt class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></tt>. In this case the models for the two
would look something like:</p>
<div class="highlight-python"><pre>models = [
    ...
    Corr3(datatag='aVbT15', T=15, tdata=range(16), tfit=range(16),
        Vnn='Vnn', Vno='Vno', Von='Von', Voo='Voo',
        a=('a','ao'), dEa=('dE','dEo'), sa=(1,-1), # a-&gt;V
        b=('b','bo'), dEb=('dE','dEo'), sb=(1,-1)  # V-&gt;b
        ),
    Corr3(datatag='bVaT15', T=15, tdata=range(16), tfit=range(16),
        Vnn='Vnn', Vno='Vno', Von='Von', Voo='Voo', transpose_V=True,
        a=('b','bo'), dEa=('dE','dEo'), sa=(1,-1), # b-&gt;V
        b=('a','ao'), dEb=('dE','dEo'), sb=(1,-1)  # V-&gt;a
        ),
    ...
]</pre>
</div>
<p>The same <tt class="docutils literal"><span class="pre">V</span></tt>s are specified for the second correlator, but setting
<tt class="docutils literal"><span class="pre">transpose_V=True</span></tt> means that the transpose of each matrix is used
in the fit for that correlator.</p>
<p>The second special case is for fits to <tt class="docutils literal"><span class="pre">a-&gt;V-&gt;a</span></tt> where source and sink
are the same. In that case, <tt class="docutils literal"><span class="pre">Vnn</span></tt> and <tt class="docutils literal"><span class="pre">Voo</span></tt> are symmetric matrices, and
<tt class="docutils literal"><span class="pre">Von</span></tt> is the transpose of <tt class="docutils literal"><span class="pre">Vno</span></tt>. The model for such a case would look
like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Corr3</span><span class="p">(</span><span class="n">datatag</span><span class="o">=</span><span class="s">&#39;aVbT15&#39;</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span>
    <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span><span class="p">,</span> <span class="n">Von</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span><span class="p">,</span> <span class="n">Voo</span><span class="o">=</span><span class="s">&#39;Voo&#39;</span><span class="p">,</span> <span class="n">symmetric_V</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEa</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sa</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="c"># a-&gt;V</span>
    <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;ao&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="s">&#39;dEo&#39;</span><span class="p">),</span> <span class="n">sb</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># V-&gt;a</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">Vno</span></tt> and <tt class="docutils literal"><span class="pre">Von</span></tt> are set equal to the same matrix, but specifying
<tt class="docutils literal"><span class="pre">symmetric_V=True</span></tt> implies that the transpose will be used for <tt class="docutils literal"><span class="pre">Von</span></tt>.
Furthermore <tt class="docutils literal"><span class="pre">Vnn</span></tt> and <tt class="docutils literal"><span class="pre">Voo</span></tt> are symmetric matrices when
<tt class="docutils literal"><span class="pre">symmetric_V==True</span></tt> and so only the upper part of each matrix is needed.
In this case <tt class="docutils literal"><span class="pre">Vnn</span></tt> and <tt class="docutils literal"><span class="pre">Voo</span></tt> are treated as one-dimensional arrays with
<tt class="docutils literal"><span class="pre">N(N+1)/2</span></tt> elements corresponding to the upper parts of each matrix,
where <tt class="docutils literal"><span class="pre">N</span></tt> is the number of exponentials (that is, the number of
<tt class="docutils literal"><span class="pre">a[i]</span></tt>s).</p>
</div>
<div class="section" id="bootstrap-analyses">
<h2>Bootstrap Analyses<a class="headerlink" href="#bootstrap-analyses" title="Permalink to this headline">¶</a></h2>
<p>A <em>bootstrap analysis</em> gives more robust error estimates for fit parameters
and functions of fit parameters than the conventional fit when errors are
large, or fluctuations are non-gaussian. A typical code looks something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">gvar.dataset</span> <span class="kn">as</span> <span class="nn">ds</span>
<span class="kn">from</span> <span class="nn">corrfitter</span> <span class="kn">import</span> <span class="n">CorrFitter</span>
<span class="c"># fit</span>
<span class="n">dset</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="s">&#39;mcfile&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dset</span><span class="p">)</span>            <span class="c"># create fit data</span>
<span class="n">fitter</span> <span class="o">=</span> <span class="n">Corrfitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">make_models</span><span class="p">())</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>                               <span class="c"># number of terms in fit function</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>  <span class="c"># do standard fit</span>
<span class="k">print</span> <span class="s">&#39;Fit results:&#39;</span>
<span class="k">print</span> <span class="s">&#39;a&#39;</span><span class="p">,</span><span class="n">exp</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;loga&#39;</span><span class="p">])</span>        <span class="c"># fit results for &#39;a&#39; amplitudes</span>
<span class="k">print</span> <span class="s">&#39;dE&#39;</span><span class="p">,</span><span class="n">exp</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;logdE&#39;</span><span class="p">])</span>      <span class="c"># fit results for &#39;dE&#39; energies</span>
<span class="o">...</span>
<span class="o">...</span>
<span class="c"># bootstrap analysis</span>
<span class="k">print</span> <span class="s">&#39;Bootstrap fit results:&#39;</span>
<span class="n">nbootstrap</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c"># number of bootstrap iterations</span>
<span class="n">bs_datalist</span> <span class="o">=</span> <span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dset</span><span class="o">.</span><span class="n">bootstrap_iter</span><span class="p">(</span><span class="n">nbootstrap</span><span class="p">))</span>
<span class="n">bs</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>                   <span class="c"># bootstrap output stored in bs</span>
<span class="k">for</span> <span class="n">bs_fit</span> <span class="ow">in</span> <span class="n">fitter</span><span class="o">.</span><span class="n">bootstrap_iter</span><span class="p">(</span><span class="n">bs_datalist</span><span class="p">):</span> <span class="c"># bs_fit = lsqfit output</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">bs_fit</span><span class="o">.</span><span class="n">pmean</span>    <span class="c"># best fit values for current bootstrap iteration</span>
    <span class="n">bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;loga&#39;</span><span class="p">]))</span>  <span class="c"># collect bootstrap results for a[i]</span>
    <span class="n">bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;logdE&#39;</span><span class="p">]))</span><span class="c"># collect results for dE[i]</span>
    <span class="o">...</span>                             <span class="c"># include other functions of p</span>
    <span class="o">...</span>
<span class="n">bs</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">bstrap</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>   <span class="c"># medians + error estimate</span>
<span class="k">print</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">bs</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span>                  <span class="c"># bootstrap result for &#39;a&#39; amplitudes</span>
<span class="k">print</span> <span class="s">&#39;dE&#39;</span><span class="p">,</span> <span class="n">bs</span><span class="p">[</span><span class="s">&#39;dE&#39;</span><span class="p">]</span>                <span class="c"># bootstrap result for &#39;dE&#39; energies</span>
<span class="o">....</span>
</pre></div>
</div>
<p>This code first prints out the standard fit results for the <tt class="docutils literal"><span class="pre">'a'</span></tt> amplitudes
and <tt class="docutils literal"><span class="pre">'dE'</span></tt> energies. It then makes <tt class="docutils literal"><span class="pre">10</span></tt> bootstrap copies of the original
input data, and fits each using the best-fit parameters from the original fit
as the starting point for the bootstrap fit. The variation in the best-fit
parameters from fit to fit is an indication of the uncertainty in those
parameters. This example uses a <tt class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></tt> object <tt class="docutils literal"><span class="pre">bs</span></tt> to
accumulate the results from each bootstrap fit, which are computed using the
best-fit values of the parameters (ignoring their standard deviations). Other
functions of the fit parameters could be included as well. At the end
<tt class="docutils literal"><span class="pre">avg_data(bs,</span> <span class="pre">bstrap=True)</span></tt> finds median values for each quantity in
<tt class="docutils literal"><span class="pre">bs</span></tt>, as well as a robust estimate of the uncertainty (to within 30% since
<tt class="docutils literal"><span class="pre">nbootstrap</span></tt> is only <tt class="docutils literal"><span class="pre">10</span></tt>).</p>
<p>The list of bootstrap data sets <tt class="docutils literal"><span class="pre">bs_datalist</span></tt> can be omitted in this example
in situations where the input data has high statistics. Then the bootstrap
copies are generated internally by <tt class="xref py py-func docutils literal"><span class="pre">fitter.bootstrap_iter()</span></tt> from the
means and covariance matrix of the input data (assuming gaussian statistics).</p>
</div>
<div class="section" id="new-models">
<h2>New Models<a class="headerlink" href="#new-models" title="Permalink to this headline">¶</a></h2>
<p>Classes to describe new models are usually derived from <a class="reference internal" href="#corrfitter.BaseModel" title="corrfitter.BaseModel"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.BaseModel</span></tt></a>. These
can be for fitting new types of correlators. They can also be used in other
ways &#8212; for example, to add constraints. Imagine a situation where one
wants to constrain the third energy (<tt class="docutils literal"><span class="pre">E2</span></tt>) in a fit to be <tt class="docutils literal"><span class="pre">0.60(1)</span></tt>.
This can be accomplished by adding <tt class="docutils literal"><span class="pre">E2_Constraint()</span></tt> to the list of
models in <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">gvar</span>
<span class="kn">import</span> <span class="nn">corrfitter</span>

<span class="k">class</span> <span class="nc">E2_Constraint</span><span class="p">(</span><span class="n">corrfitter</span><span class="o">.</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">E2_Constraint</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="s">&#39;E2-constraint&#39;</span><span class="p">)</span> <span class="c"># data tag</span>

    <span class="k">def</span> <span class="nf">fitfcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
        <span class="n">dE</span> <span class="o">=</span> <span class="n">gvar</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="s">&#39;logdE&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dE</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>              <span class="c"># E2 formula in terms of p</span>

    <span class="k">def</span> <span class="nf">builddata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">gvar</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.01</span><span class="p">)</span>      <span class="c"># E2 value</span>

    <span class="k">def</span> <span class="nf">buildprior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">nterm</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>
</pre></div>
</div>
<p>Any number of constraints like this can be added to the list of models.</p>
<p>Note that this constraint could instead be built into the priors for
<tt class="docutils literal"><span class="pre">logdE</span></tt> by introducing correlations between different parameters.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> allows models to specify how many exponentials to include in the
fit function (using parameters <tt class="docutils literal"><span class="pre">nterm</span></tt>, <tt class="docutils literal"><span class="pre">nterma</span></tt> and <tt class="docutils literal"><span class="pre">ntermb</span></tt>). If that
number is less than the number of exponentials specified by the prior, the
extra terms are incorporated into the fit data before fitting. The default
procedure is to multiply the data by <tt class="docutils literal"><span class="pre">G(t,p,N)/G(t,p,max(N,Nmax))</span></tt> where:
<tt class="docutils literal"><span class="pre">G(p,t,N)</span></tt> is the fit function with <tt class="docutils literal"><span class="pre">N</span></tt> terms for parameters <tt class="docutils literal"><span class="pre">p</span></tt> and
time <tt class="docutils literal"><span class="pre">t</span></tt>; <tt class="docutils literal"><span class="pre">N</span></tt> is the number of exponentials specified in the models;
<tt class="docutils literal"><span class="pre">Nmax</span></tt> is the number of exponentials specified in the prior; and here
parameters <tt class="docutils literal"><span class="pre">p</span></tt> are set equal to their values in the prior (correlated
<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s).</p>
<p>An alternative implementation for the data correction is to add
<tt class="docutils literal"><span class="pre">G(t,p,N)-G(t,p,max(N,Nmax))</span></tt> to the data. This implementation is selected
when parameter <tt class="docutils literal"><span class="pre">ratio</span></tt> in <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> is set to <tt class="docutils literal"><span class="pre">False</span></tt>. Results are
similar to the other implementation, though perhaps a little less robust.</p>
<p>Background information on the some of the fitting strategies used by
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> can be found by doing web searches for &#8220;hep-lat/0110175&#8221; and
&#8220;arXiv:1111.1363&#8221;. These are two papers by G.P. Lepage and collaborators
whose published versions are: G.P. Lepage et al, Nucl.Phys.Proc.Suppl.
106 (2002) 12-20; and K. Hornbostel et al, Phys.Rev. D85 (2012) 031504.</p>
</div>
<div class="section" id="correlator-model-objects">
<h2>Correlator Model Objects<a class="headerlink" href="#correlator-model-objects" title="Permalink to this headline">¶</a></h2>
<p>Correlator objects describe theoretical models that are fit to
correlator data by varying the models&#8217; parameters.</p>
<p>A model object&#8217;s parameters are specified through priors for the fit. A
model assigns labels to each of its parameters (or arrays of related
parameters), and these labels are used to identify the corresponding
parameters in the prior. Parameters can be shared by more than one model
object.</p>
<p>A model object also specifies the data that it is to model. The data is
identified by the data tag that labels it in the input file or <tt class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></tt>.</p>
<dl class="class">
<dt id="corrfitter.Corr2">
<em class="property">class </em><tt class="descclassname">corrfitter.</tt><tt class="descname">Corr2</tt><big>(</big><em>datatag</em>, <em>tdata</em>, <em>tfit</em>, <em>a</em>, <em>b</em>, <em>dE</em>, <em>s=1.0</em>, <em>tp=None</em>, <em>othertags=None</em><big>)</big><a class="headerlink" href="#corrfitter.Corr2" title="Permalink to this definition">¶</a></dt>
<dd><p>Two-point correlators <tt class="docutils literal"><span class="pre">Gab(t)</span> <span class="pre">=</span> <span class="pre">&lt;b(t)</span> <span class="pre">a(0)&gt;</span></tt>.</p>
<p><a class="reference internal" href="#corrfitter.Corr2" title="corrfitter.Corr2"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr2</span></tt></a> models the <tt class="docutils literal"><span class="pre">t</span></tt> dependence of a 2-point correlator <tt class="docutils literal"><span class="pre">Gab(t)</span></tt>
using</p>
<div class="highlight-python"><pre>Gab(t) = sn * sum_i an[i]*bn[i] * fn(En[i], t)
       + so * sum_i ao[i]*bo[i] * fo(Eo[i], t)</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">sn</span></tt> and <tt class="docutils literal"><span class="pre">so</span></tt> are typically <tt class="docutils literal"><span class="pre">-1</span></tt>, <tt class="docutils literal"><span class="pre">0</span></tt>, or <tt class="docutils literal"><span class="pre">1</span></tt> and</p>
<div class="highlight-python"><pre>fn(E, t) =  exp(-E*t) + exp(-E*(tp-t)) # tp&gt;0 -- periodic
       or   exp(-E*t) - exp(-E*(-tp-t))# tp&lt;0 -- anti-periodic
       or   exp(-E*t)                  # if tp is None (nonperiodic)

fo(E, t) = (-1)**t * fn(E, t)</pre>
</div>
<p>The fit parameters for the non-oscillating piece of <tt class="docutils literal"><span class="pre">Gab</span></tt> (first term)
are <tt class="docutils literal"><span class="pre">an[i]</span></tt>, <tt class="docutils literal"><span class="pre">bn[i]</span></tt>, and <tt class="docutils literal"><span class="pre">dEn[i]</span></tt> where:</p>
<div class="highlight-python"><pre>dEn[0] = En[0] &gt; 0
dEn[i] = En[i]-En[i-1] &gt; 0     (for i&gt;0)</pre>
</div>
<p>and therefore <tt class="docutils literal"><span class="pre">En[i]</span> <span class="pre">=</span> <span class="pre">sum_j=0..i</span> <span class="pre">dEn[j]</span></tt>. The fit parameters for
the oscillating pied are defined analogously: <tt class="docutils literal"><span class="pre">ao[i]</span></tt>, <tt class="docutils literal"><span class="pre">bo[i]</span></tt>,
and <tt class="docutils literal"><span class="pre">dEo[i]</span></tt>.</p>
<p>The fit parameters are specified by the keys corresponding to these
parameters in a dictionary of priors supplied by <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>. The keys
are strings and are also used to access fit results. Any key that
begins with &#8220;log&#8221; is assumed to refer to the logarithm of the parameter
in question (that is, the exponential of the fit-parameter is used in
the formula for <tt class="docutils literal"><span class="pre">Gab(t)</span></tt>.) This is useful for forcing <tt class="docutils literal"><span class="pre">an</span></tt>, <tt class="docutils literal"><span class="pre">bn</span></tt>
and/or <tt class="docutils literal"><span class="pre">dE</span></tt> to be positive.</p>
<p>When <tt class="docutils literal"><span class="pre">tp</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></tt> and positive, the correlator is assumed to be
symmetrical about <tt class="docutils literal"><span class="pre">tp/2</span></tt>, with <tt class="docutils literal"><span class="pre">Gab(t)=Gab(tp-t)</span></tt>. Data from
<tt class="docutils literal"><span class="pre">t&gt;tp/2</span></tt> is averaged with the corresponding data from <tt class="docutils literal"><span class="pre">t&lt;tp/2</span></tt>
before fitting. When <tt class="docutils literal"><span class="pre">tp</span></tt> is negative, the correlator is assumed to
be anti-symetrical about <tt class="docutils literal"><span class="pre">-tp/2</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datatag</strong> (<em>string</em>) &#8211; Key used to access correlator data in the input data 
dictionary (see <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>). <tt class="docutils literal"><span class="pre">data[self.datatag]</span></tt> is (1-d) 
array containing the correlator values (<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s) if <tt class="docutils literal"><span class="pre">data</span></tt> is the 
input data.</li>
<li><strong>a</strong> (string, or two-tuple of strings and/or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Key identifying the fit parameters for the source amplitudes
<tt class="docutils literal"><span class="pre">an</span></tt> in the dictionary of priors provided by <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>; or a
two-tuple of keys for the source amplitudes <tt class="docutils literal"><span class="pre">(an,</span> <span class="pre">ao)</span></tt>. The
corresponding values in the dictionary of priors are (1-d) arrays
of prior values with one term for each <tt class="docutils literal"><span class="pre">an[i]</span></tt> or <tt class="docutils literal"><span class="pre">ao[i]</span></tt>.
Replacing either key by <tt class="docutils literal"><span class="pre">None</span></tt> causes the corresponding term to
be dropped from the fit function. These keys are used to label the
corresponding parameter arrays in the fit results as well as in the
prior.</li>
<li><strong>b</strong> (string, or two-tuple of strings and/or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Same as <tt class="docutils literal"><span class="pre">self.a</span></tt> but for the sinks <tt class="docutils literal"><span class="pre">(bn,</span> <span class="pre">bo)</span></tt> instead of
the sources <tt class="docutils literal"><span class="pre">(an,</span> <span class="pre">ao)</span></tt>.</li>
<li><strong>dE</strong> (string, or two-tuple of strings and/or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Key identifying the fit parameters for the energy 
differences <tt class="docutils literal"><span class="pre">dEn</span></tt> in the dictionary of priors provided by
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>; or a two-tuple of keys for the energy differences
<tt class="docutils literal"><span class="pre">(dEn,</span> <span class="pre">dEo)</span></tt>. The corresponding values in the dictionary of priors
are (1-d) arrays of prior values with one term for each <tt class="docutils literal"><span class="pre">dEn[i]</span></tt>
or <tt class="docutils literal"><span class="pre">dEo[i]</span></tt>. Replacing either key by <tt class="docutils literal"><span class="pre">None</span></tt> causes the
corresponding term to be dropped from the fit function. These keys
are used to label the corresponding parameter arrays in the fit
results as well as in the prior.</li>
<li><strong>s</strong> (<em>number or two-tuple of numbers</em>) &#8211; Overall factor <tt class="docutils literal"><span class="pre">sn</span></tt>, or two-tuple of overall factors 
<tt class="docutils literal"><span class="pre">(sn,</span> <span class="pre">so)</span></tt>.</li>
<li><strong>tdata</strong> (<em>list of integers</em>) &#8211; The <tt class="docutils literal"><span class="pre">t</span></tt>s corresponding to data entries in the input
data. Note that <tt class="docutils literal"><span class="pre">len(self.tdata)</span> <span class="pre">==</span> <span class="pre">len(data[self.datatag])</span></tt> is
required if <tt class="docutils literal"><span class="pre">data</span></tt> is the input data dictionary.</li>
<li><strong>tfit</strong> (<em>list of integers</em>) &#8211; List of <tt class="docutils literal"><span class="pre">t</span></tt>s to use in the fit. Only data with these
<tt class="docutils literal"><span class="pre">t</span></tt>s (all of which should be in <tt class="docutils literal"><span class="pre">tdata</span></tt>) is used in the fit.</li>
<li><strong>tp</strong> (integer or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; If not <tt class="docutils literal"><span class="pre">None</span></tt> and positive, the correlator is assumed to 
be periodic with <tt class="docutils literal"><span class="pre">Gab(t)=Gab(tp-t)</span></tt>. If negative, the correlator
is assumed to be anti-periodic with <tt class="docutils literal"><span class="pre">Gab(t)=-Gab(-tp-t)</span></tt>. Setting
<tt class="docutils literal"><span class="pre">tp=None</span></tt> implies that the correlator is not periodic, but rather
continues to fall exponentially as <tt class="docutils literal"><span class="pre">t</span></tt> is increased indefinitely.</li>
<li><strong>othertags</strong> (<em>sequence of strings</em>) &#8211; List of additional data tags for data to be
averaged with the <tt class="docutils literal"><span class="pre">self.datatag</span></tt> data before fitting.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="corrfitter.Corr2.builddata">
<tt class="descname">builddata</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#corrfitter.Corr2.builddata" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble fit data from dictionary <tt class="docutils literal"><span class="pre">data</span></tt>.</p>
<p>Extracts parts of array <tt class="docutils literal"><span class="pre">data[self.datatag]</span></tt> that are needed for
the fit, as specified by <tt class="docutils literal"><span class="pre">self.tp</span></tt> and <tt class="docutils literal"><span class="pre">self.tfit</span></tt>. The entries
in the (1-D) array <tt class="docutils literal"><span class="pre">data[self.datatag]</span></tt> are assumed to be
<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s and correspond to the <tt class="docutils literal"><span class="pre">t``s</span> <span class="pre">in</span> <span class="pre">``self.tdata</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.Corr2.buildprior">
<tt class="descname">buildprior</tt><big>(</big><em>prior</em>, <em>nterm</em><big>)</big><a class="headerlink" href="#corrfitter.Corr2.buildprior" title="Permalink to this definition">¶</a></dt>
<dd><p>Create fit prior by extracting relevant pieces of <tt class="docutils literal"><span class="pre">prior</span></tt>.</p>
<p>Priors for the fit parameters, as specificied by <tt class="docutils literal"><span class="pre">self.a</span></tt> etc., 
are copied from <tt class="docutils literal"><span class="pre">prior</span></tt> into a new dictionary for use by the
fitter. If a key <tt class="docutils literal"><span class="pre">&quot;XX&quot;</span></tt> cannot be found in <tt class="docutils literal"><span class="pre">prior</span></tt>, the
<tt class="docutils literal"><span class="pre">buildprior</span></tt> looks for one of <tt class="docutils literal"><span class="pre">&quot;logXX&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;log(XX)&quot;</span></tt>, 
<tt class="docutils literal"><span class="pre">&quot;sqrtXX&quot;</span></tt>, or <tt class="docutils literal"><span class="pre">&quot;sqrt(XX)&quot;</span></tt> and includes the corresponding
prior instead.</p>
<p>The number of terms kept in each part of the fit can be 
specified using <tt class="docutils literal"><span class="pre">nterm</span> <span class="pre">=</span> <span class="pre">(n,</span> <span class="pre">no)</span></tt> where <tt class="docutils literal"><span class="pre">n</span></tt> is the 
number of non-oscillating terms and <tt class="docutils literal"><span class="pre">no</span></tt> is the number 
of oscillating terms. Setting <tt class="docutils literal"><span class="pre">nterm</span> <span class="pre">=</span> <span class="pre">None</span></tt> keeps 
all terms.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.Corr2.fitfcn">
<tt class="descname">fitfcn</tt><big>(</big><em>p</em>, <em>nterm=None</em>, <em>t=None</em><big>)</big><a class="headerlink" href="#corrfitter.Corr2.fitfcn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fit function for parameters <tt class="docutils literal"><span class="pre">p</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="corrfitter.Corr3">
<em class="property">class </em><tt class="descclassname">corrfitter.</tt><tt class="descname">Corr3</tt><big>(</big><em>datatag</em>, <em>T</em>, <em>tdata</em>, <em>tfit</em>, <em>Vnn</em>, <em>a</em>, <em>b</em>, <em>dEa</em>, <em>dEb</em>, <em>sa=1.0</em>, <em>sb=1.0</em>, <em>Vno=None</em>, <em>Von=None</em>, <em>Voo=None</em>, <em>transpose_V=False</em>, <em>symmetric_V=False</em>, <em>tpa=None</em>, <em>tpb=None</em>, <em>othertags=None</em><big>)</big><a class="headerlink" href="#corrfitter.Corr3" title="Permalink to this definition">¶</a></dt>
<dd><p>Three-point correlators <tt class="docutils literal"><span class="pre">Gavb(t,</span> <span class="pre">T)</span> <span class="pre">=</span> <span class="pre">&lt;b(T)</span> <span class="pre">V(t)</span> <span class="pre">a(0)&gt;</span></tt>.</p>
<p><a class="reference internal" href="#corrfitter.Corr3" title="corrfitter.Corr3"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.Corr3</span></tt></a> models the <tt class="docutils literal"><span class="pre">t</span></tt> dependence of a 3-point correlator
<tt class="docutils literal"><span class="pre">Gavb(t,</span> <span class="pre">T)</span></tt> using</p>
<div class="highlight-python"><pre>Gavb(t, T) = 
 sum_i,j san*an[i]*fn(Ean[i],t)*Vnn[i,j]*sbn*bn[j]*fn(Ebn[j],T-t)
+sum_i,j san*an[i]*fn(Ean[i],t)*Vno[i,j]*sbo*bo[j]*fo(Ebo[j],T-t)
+sum_i,j sao*ao[i]*fo(Eao[i],t)*Von[i,j]*sbn*bn[j]*fn(Ebn[j],T-t)
+sum_i,j sao*ao[i]*fo(Eao[i],t)*Voo[i,j]*sbo*bo[j]*fo(Ebo[j],T-t)</pre>
</div>
<p>where</p>
<div class="highlight-python"><pre>fn(E, t) =  exp(-E*t) + exp(-E*(tp-t)) # tp&gt;0 -- periodic
       or   exp(-E*t) - exp(-E*(-tp-t))# tp&lt;0 -- anti-periodic
       or   exp(-E*t)                  # if tp is None (nonperiodic)

fo(E, t) = (-1)**t * fn(E, t)</pre>
</div>
<p>The fit parameters for the non-oscillating piece of <tt class="docutils literal"><span class="pre">Gavb</span></tt> (first term)
are <tt class="docutils literal"><span class="pre">Vnn[i,j]</span></tt>, <tt class="docutils literal"><span class="pre">an[i]</span></tt>, <tt class="docutils literal"><span class="pre">bn[j]</span></tt>, <tt class="docutils literal"><span class="pre">dEan[i]</span></tt> and <tt class="docutils literal"><span class="pre">dEbn[j]</span></tt> where,
for example:</p>
<div class="highlight-python"><pre>dEan[0] = Ean[0] &gt; 0
dEan[i] = Ean[i]-Ean[i-1] &gt; 0     (for i&gt;0)</pre>
</div>
<p>and therefore <tt class="docutils literal"><span class="pre">Ean[i]</span> <span class="pre">=</span> <span class="pre">sum_j=0..i</span> <span class="pre">dEan[j]</span></tt>. The parameters for the
other terms are similarly defined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datatag</strong> (<em>string</em>) &#8211; Tag used to label correlator in the input <tt class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></tt>.</li>
<li><strong>a</strong> (string, or two-tuple of strings or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Key identifying the fit parameters for the source amplitudes
<tt class="docutils literal"><span class="pre">an</span></tt>, for <tt class="docutils literal"><span class="pre">a-&gt;V</span></tt>, in the dictionary of priors provided by
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>; or a two-tuple of keys for the source amplitudes
<tt class="docutils literal"><span class="pre">(an,</span> <span class="pre">ao)</span></tt>. The corresponding values in the dictionary of priors
are (1-d) arrays of prior values with one term for each <tt class="docutils literal"><span class="pre">an[i]</span></tt>
or <tt class="docutils literal"><span class="pre">ao[i]</span></tt>. Replacing either key by <tt class="docutils literal"><span class="pre">None</span></tt> causes the
corresponding term to be dropped from the fit function. These keys
are used to label the corresponding parameter arrays in the fit
results as well as in the prior.</li>
<li><strong>b</strong> (string, or two-tuple of strings or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Same as <tt class="docutils literal"><span class="pre">self.a</span></tt> except for sink amplitudes <tt class="docutils literal"><span class="pre">(bn,</span> <span class="pre">bo)</span></tt> 
for <tt class="docutils literal"><span class="pre">V-&gt;b</span></tt> rather than for <tt class="docutils literal"><span class="pre">(an,</span> <span class="pre">ao)</span></tt>.</li>
<li><strong>dEa</strong> (string, or two-tuple of strings or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Fit-parameter label for <tt class="docutils literal"><span class="pre">a-&gt;V</span></tt> intermediate-state energy 
differences <tt class="docutils literal"><span class="pre">dEan</span></tt>, or two-tuple of labels for the differences
<tt class="docutils literal"><span class="pre">(dEan,dEao)</span></tt>. Each label represents an array of energy differences.
Replacing either label by <tt class="docutils literal"><span class="pre">None</span></tt> causes the corresponding term in
the correlator function to be dropped. These keys
are used to label the corresponding parameter arrays in the fit
results as well as in the prior.</li>
<li><strong>dEb</strong> (string, or two-tuple of strings or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Fit-parameter label for <tt class="docutils literal"><span class="pre">V-&gt;b</span></tt> intermediate-state energy 
differences <tt class="docutils literal"><span class="pre">dEbn</span></tt>, or two-tuple of labels for the differences
<tt class="docutils literal"><span class="pre">(dEbn,dEbo)</span></tt>. Each label represents an array of energy differences.
Replacing either label by <tt class="docutils literal"><span class="pre">None</span></tt> causes the corresponding term in
the correlator function to be dropped. These keys
are used to label the corresponding parameter arrays in the fit
results as well as in the prior.</li>
<li><strong>sa</strong> (<em>number, or two-tuple of numbers</em>) &#8211; Overall factor <tt class="docutils literal"><span class="pre">san</span></tt> for the non-oscillating <tt class="docutils literal"><span class="pre">a-&gt;V</span></tt> terms 
in the correlator, or two-tuple containing the overall factors
<tt class="docutils literal"><span class="pre">(san,sao)</span></tt> for the non-oscillating and oscillating terms.</li>
<li><strong>sb</strong> (<em>number, or two-tuple of numbers</em>) &#8211; Overall factor <tt class="docutils literal"><span class="pre">sbn</span></tt> for the non-oscillating <tt class="docutils literal"><span class="pre">V-&gt;b</span></tt> terms 
in the correlator, or two-tuple containing the overall factors
<tt class="docutils literal"><span class="pre">(sbn,sbo)</span></tt> for the non-oscillating and oscillating terms.</li>
<li><strong>Vnn</strong> (string or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Fit-parameter label for the matrix of current matrix 
elements <tt class="docutils literal"><span class="pre">Vnn[i,j]</span></tt> connecting non-oscillating states. Labels that
begin with &#8220;log&#8221; indicate that the corresponding matrix elements are
replaced by their exponentials; these parameters are logarithms of the
corresponding matrix elements, which must then be positive.</li>
<li><strong>Vno</strong> (string or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Fit-parameter label for the matrix of current matrix 
elements <tt class="docutils literal"><span class="pre">Vno[i,j]</span></tt> connecting non-oscillating to oscillating
states. Labels that begin with &#8220;log&#8221; indicate that the corresponding
matrix elements are replaced by their exponentials; these parameters
are logarithms of the corresponding matrix elements, which must then
be positive.</li>
<li><strong>Von</strong> (string or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Fit-parameter label for the matrix of current matrix 
elements <tt class="docutils literal"><span class="pre">Von[i,j]</span></tt> connecting oscillating to non-oscillating 
states. Labels that begin with &#8220;log&#8221; indicate that the corresponding
matrix elements are replaced by their exponentials; these parameters
are logarithms of the corresponding matrix elements, which must then
be positive.</li>
<li><strong>Voo</strong> (string or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Fit-parameter label for the matrix of current matrix 
elements <tt class="docutils literal"><span class="pre">Voo[i,j]</span></tt> connecting oscillating states. Labels that begin
with &#8220;log&#8221; indicate that the corresponding matrix elements are
replaced by their exponentials; these parameters are logarithms of the
corresponding matrix elements, which must then be positive.</li>
<li><strong>transpose_V</strong> (<em>boolean</em>) &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, the transpose <tt class="docutils literal"><span class="pre">V[j,i]</span></tt> is used in
place of <tt class="docutils literal"><span class="pre">V[i,j]</span></tt> for each current matrix element in the fit 
function. This is useful for doing simultaneous fits to 
<tt class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></tt> and <tt class="docutils literal"><span class="pre">b-&gt;V-&gt;a</span></tt>, where the current matrix elements
for one are the transposes of those for the other. Default value 
is <tt class="docutils literal"><span class="pre">False</span></tt>.</li>
<li><strong>symmetric_V</strong> (<em>boolean</em>) &#8211; <p>If <tt class="docutils literal"><span class="pre">True</span></tt>, the fit function for <tt class="docutils literal"><span class="pre">a-&gt;V-&gt;b</span></tt> is 
unchanged (symmetrical) under the the interchange of <tt class="docutils literal"><span class="pre">a</span></tt> and
<tt class="docutils literal"><span class="pre">b</span></tt>. Then <tt class="docutils literal"><span class="pre">Vnn</span></tt> and <tt class="docutils literal"><span class="pre">Voo</span></tt> are square, symmetric matrices
with <tt class="docutils literal"><span class="pre">V[i,j]=V[j,i]</span></tt> and their priors are one-dimensional arrays
containing only elements <tt class="docutils literal"><span class="pre">V[i,j]</span></tt> with <tt class="docutils literal"><span class="pre">j&gt;=i</span></tt> in the following
layout:</p>
<div class="highlight-python"><pre>[V[0,0],V[0,1],V[0,2]...V[0,N],
        V[1,1],V[1,2]...V[1,N],
               V[2,2]...V[2,N],
                     .
                      .
                       .
                        V[N,N]]</pre>
</div>
<p>Furthermore the matrix specified for <tt class="docutils literal"><span class="pre">Von</span></tt> is transposed before
being used by the fitter; normally the matrix specified for <tt class="docutils literal"><span class="pre">Von</span></tt>
is the same as the matrix specified for <tt class="docutils literal"><span class="pre">Vno</span></tt> when the amplitude
is symmetrical. Default value is <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
</li>
<li><strong>tdata</strong> (<em>list of integers</em>) &#8211; The <tt class="docutils literal"><span class="pre">t</span></tt>s corresponding to data entries in the input
<tt class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></tt>.</li>
<li><strong>tfit</strong> (<em>list of integers</em>) &#8211; List of <tt class="docutils literal"><span class="pre">t</span></tt>s to use in the fit. Only data with these
<tt class="docutils literal"><span class="pre">t</span></tt>s (all of which should be in <tt class="docutils literal"><span class="pre">tdata</span></tt>) is used in the fit.</li>
<li><strong>tpa</strong> (integer or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; If not <tt class="docutils literal"><span class="pre">None</span></tt> and positive, the <tt class="docutils literal"><span class="pre">a-&gt;V</span></tt> correlator is 
assumed to be periodic with period <tt class="docutils literal"><span class="pre">tpa</span></tt>. If negative, the
correlator is anti-periodic with period <tt class="docutils literal"><span class="pre">-tpa</span></tt>. Setting
<tt class="docutils literal"><span class="pre">tpa=None</span></tt> implies that the correlators are not periodic.</li>
<li><strong>tpb</strong> (integer or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; If not <tt class="docutils literal"><span class="pre">None</span></tt> and positive, the <tt class="docutils literal"><span class="pre">V-&gt;b</span></tt> correlator is 
assumed to be periodic with period <tt class="docutils literal"><span class="pre">tpb</span></tt>. If negative, the
correlator is periodic with period <tt class="docutils literal"><span class="pre">-tpb</span></tt>. Setting <tt class="docutils literal"><span class="pre">tpb=None</span></tt>
implies that the correlators are not periodic.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="corrfitter.Corr3.builddata">
<tt class="descname">builddata</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#corrfitter.Corr3.builddata" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble fit data from dictionary <tt class="docutils literal"><span class="pre">data</span></tt>.</p>
<p>Extracts parts of array <tt class="docutils literal"><span class="pre">data[self.datatag]</span></tt> that are needed for
the fit, as specified by <tt class="docutils literal"><span class="pre">self.tfit</span></tt>. The entries in the (1-D)
array <tt class="docutils literal"><span class="pre">data[self.datatag]</span></tt> are assumed to be <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s and
correspond to the <tt class="docutils literal"><span class="pre">t``s</span> <span class="pre">in</span> <span class="pre">``self.tdata</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.Corr3.buildprior">
<tt class="descname">buildprior</tt><big>(</big><em>prior</em>, <em>nterm</em><big>)</big><a class="headerlink" href="#corrfitter.Corr3.buildprior" title="Permalink to this definition">¶</a></dt>
<dd><p>Create fit prior by extracting relevant pieces of <tt class="docutils literal"><span class="pre">prior</span></tt>.</p>
<p>Priors for the fit parameters, as specificied by <tt class="docutils literal"><span class="pre">self.a</span></tt> etc., 
are copied from <tt class="docutils literal"><span class="pre">prior</span></tt> into a new dictionary for use by the
fitter. If a key <tt class="docutils literal"><span class="pre">&quot;XX&quot;</span></tt> cannot be found in <tt class="docutils literal"><span class="pre">prior</span></tt>, the
<tt class="docutils literal"><span class="pre">buildprior</span></tt> looks for one of <tt class="docutils literal"><span class="pre">&quot;logXX&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;log(XX)&quot;</span></tt>, 
<tt class="docutils literal"><span class="pre">&quot;sqrtXX&quot;</span></tt>, or <tt class="docutils literal"><span class="pre">&quot;sqrt(XX)&quot;</span></tt> and includes the corresponding
prior instead.</p>
<p>The number of terms kept in each part of the fit can be 
specified using <tt class="docutils literal"><span class="pre">nterm</span> <span class="pre">=</span> <span class="pre">(n,</span> <span class="pre">no)</span></tt> where <tt class="docutils literal"><span class="pre">n</span></tt> is the 
number of non-oscillating terms and <tt class="docutils literal"><span class="pre">no</span></tt> is the number 
of oscillating terms. Setting <tt class="docutils literal"><span class="pre">nterm</span> <span class="pre">=</span> <span class="pre">None</span></tt> keeps 
all terms.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.Corr3.fitfcn">
<tt class="descname">fitfcn</tt><big>(</big><em>p</em>, <em>nterm=None</em>, <em>t=None</em><big>)</big><a class="headerlink" href="#corrfitter.Corr3.fitfcn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fit function for parameters <tt class="docutils literal"><span class="pre">p</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="corrfitter.BaseModel">
<em class="property">class </em><tt class="descclassname">corrfitter.</tt><tt class="descname">BaseModel</tt><big>(</big><em>datatag</em><big>)</big><a class="headerlink" href="#corrfitter.BaseModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for correlator models.</p>
<p>Derived classes must define methods <tt class="docutils literal"><span class="pre">fitfcn</span></tt>, <tt class="docutils literal"><span class="pre">buildprior</span></tt>, and 
<tt class="docutils literal"><span class="pre">builddata</span></tt>, all of which are described below. In addition they
can have attributes:</p>
<dl class="attribute">
<dt id="BaseModel.datatag">
<tt class="descname">datatag</tt><a class="headerlink" href="#BaseModel.datatag" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> builds fit data for the correlator by extracting the
data in an input <tt class="xref py py-class docutils literal"><span class="pre">gvar.dataset.Dataset</span></tt> labelled by string <tt class="docutils literal"><span class="pre">datatag</span></tt>. This
label is stored in the <tt class="docutils literal"><span class="pre">BaseModel</span></tt> and must be passed to its
constructor.</div></blockquote>
<dl class="attribute">
<dt id="BaseModel._abscissa">
<tt class="descname">_abscissa</tt><a class="headerlink" href="#BaseModel._abscissa" title="Permalink to this definition">¶</a></dt>
<dd><p>(Optional) Array of abscissa values used in plots of the data and
fit corresponding to the model. Plots are not made for a model that
doesn&#8217;t specify this attribute.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="corrfitter.BaseModel.builddata">
<tt class="descname">builddata</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#corrfitter.BaseModel.builddata" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct fit data.</p>
<p>Format of output must be same as format for fitfcn output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>dictionary</em>) &#8211; Dataset containing correlator data 
(see <tt class="docutils literal"><span class="pre">gvar.dataset</span></tt>).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="corrfitter.BaseModel.buildprior">
<tt class="descname">buildprior</tt><big>(</big><em>prior</em>, <em>nterm=None</em><big>)</big><a class="headerlink" href="#corrfitter.BaseModel.buildprior" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract fit prior from <tt class="docutils literal"><span class="pre">prior</span></tt>; resizing as needed.</p>
<p>If <tt class="docutils literal"><span class="pre">nterm</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt>, the sizes of the priors may need
adjusting so that they correspond to the values specified in 
<tt class="docutils literal"><span class="pre">nterm</span></tt> (for normal and oscillating pieces).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>prior</strong> (<em>dictionary</em>) &#8211; Dictionary containing <em>a priori</em> estimates of the 
fit parameters.</li>
<li><strong>nterm</strong> (tuple of <tt class="docutils literal"><span class="pre">None</span></tt> or integers) &#8211; Restricts the number of non-oscillating terms in the
fit function to <tt class="docutils literal"><span class="pre">nterm[0]</span></tt> and oscillating terms to
<tt class="docutils literal"><span class="pre">nterm[1]</span></tt>. Setting either (or both) to <tt class="docutils literal"><span class="pre">None</span></tt> implies that
all terms in the prior are used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="corrfitter.BaseModel.fitfcn">
<tt class="descname">fitfcn</tt><big>(</big><em>p</em>, <em>nterm=None</em><big>)</big><a class="headerlink" href="#corrfitter.BaseModel.fitfcn" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute fit function fit parameters <tt class="docutils literal"><span class="pre">p</span></tt> using <tt class="docutils literal"><span class="pre">nterm</span></tt> terms. &#8220;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> (<em>dictionary</em>) &#8211; Dictionary of parameter values.</li>
<li><strong>nterm</strong> (tuple of <tt class="docutils literal"><span class="pre">None</span></tt> or integers) &#8211; Restricts the number of non-oscillating terms in the
fit function to <tt class="docutils literal"><span class="pre">nterm[0]</span></tt> and oscillating terms to
<tt class="docutils literal"><span class="pre">nterm[1]</span></tt>. Setting either (or both) to <tt class="docutils literal"><span class="pre">None</span></tt> implies that
all terms in the prior are used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="corrfitter-objects">
<h2><a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> Objects<a class="headerlink" href="#corrfitter-objects" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> objects are wrappers for <tt class="xref py py-func docutils literal"><span class="pre">lsqfit.nonlinear_fit()</span></tt> which
is used to fit a collection of models to a collection of Monte Carlo data.</p>
<dl class="class">
<dt id="corrfitter.CorrFitter">
<em class="property">class </em><tt class="descclassname">corrfitter.</tt><tt class="descname">CorrFitter</tt><big>(</big><em>models</em>, <em>svdcut=(1e-15</em>, <em>1e-15)</em>, <em>svdnum=None</em>, <em>tol=1e-10</em>, <em>maxit=500</em>, <em>nterm=None</em>, <em>ratio=True</em><big>)</big><a class="headerlink" href="#corrfitter.CorrFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Nonlinear least-squares fitter for a collection of correlators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>models</strong> (<em>list of correlator models or a single model</em>) &#8211; Correlator models used to fit statistical input data.</li>
<li><strong>svdcut</strong> (number or <tt class="docutils literal"><span class="pre">None</span></tt> or 2-tuple) &#8211; If <tt class="docutils literal"><span class="pre">svdcut</span></tt> is positive, eigenvalues <tt class="docutils literal"><span class="pre">ev[i]</span></tt> of the 
(rescaled) data covariance matrix that are smaller than
<tt class="docutils literal"><span class="pre">svdcut*max(ev)</span></tt> are replaced by <tt class="docutils literal"><span class="pre">svdcut*max(ev)</span></tt> in the
covariance matrix. If <tt class="docutils literal"><span class="pre">svdcut</span></tt> is negative, eigenvalues less than
<tt class="docutils literal"><span class="pre">|svdcut|*max(ev)</span></tt> are set to zero in the covariance matrix. The
covariance matrix is left unchanged if <tt class="docutils literal"><span class="pre">svdcut</span></tt> is set equal to
<tt class="docutils literal"><span class="pre">None</span></tt> (default). If <tt class="docutils literal"><span class="pre">svdcut</span></tt> is a 2-tuple, <em>svd</em> cuts are applied
to both the correlator data (<tt class="docutils literal"><span class="pre">svdcut[0]</span></tt>) and to the prior
(<tt class="docutils literal"><span class="pre">svdcut[1]</span></tt>).</li>
<li><strong>svdnum</strong> (integer or <tt class="docutils literal"><span class="pre">None</span></tt> or 2-tuple) &#8211; At most <tt class="docutils literal"><span class="pre">svdnum</span></tt> eigenmodes are retained in the 
(rescaled) data covariance matrix; the modes with the smallest
eigenvalues are discarded. <tt class="docutils literal"><span class="pre">svdnum</span></tt> is ignored if it is set to
<tt class="docutils literal"><span class="pre">None</span></tt>. If <tt class="docutils literal"><span class="pre">svdnum</span></tt> is a 2-tuple, <em>svd</em> cuts are applied to both
the correlator data (<tt class="docutils literal"><span class="pre">svdnum[0]</span></tt>) and to the prior (<tt class="docutils literal"><span class="pre">svdnum[1]</span></tt>).</li>
<li><strong>tol</strong> (<em>positive number less than 1</em>) &#8211; Tolerance used in <tt class="xref py py-func docutils literal"><span class="pre">lsqfit.nonlinear_fit()</span></tt> for the 
least-squares fits (default=1e-10).</li>
<li><strong>maxit</strong> (<em>integer</em>) &#8211; Maximum number of iterations to use in least-squares fit 
(default=500).</li>
<li><strong>nterm</strong> (number or <tt class="docutils literal"><span class="pre">None</span></tt>; or two-tuple of numbers or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Number of terms fit in the non-oscillating parts of fit 
functions; or two-tuple of numbers indicating how many terms to fit
for each of the non-oscillating and oscillating pieces in fits. If set
to <tt class="docutils literal"><span class="pre">None</span></tt>, the number is specified by the number of parameters in
the prior.</li>
<li><strong>ratio</strong> (<em>boolean</em>) &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt> (the default), use ratio corrections for fit 
data when the prior specifies more terms than are used in the fit. If
<tt class="docutils literal"><span class="pre">False</span></tt>, use difference corrections (see implementation notes,
above).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="corrfitter.CorrFitter.bootstrap_iter">
<tt class="descname">bootstrap_iter</tt><big>(</big><em>datalist=None</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#corrfitter.CorrFitter.bootstrap_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that creates bootstrap copies of a <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> fit using 
bootstrap data from list <tt class="docutils literal"><span class="pre">data_list</span></tt>.</p>
<p>A bootstrap analysis is a robust technique for estimating means and
standard deviations of arbitrary functions of the fit parameters.
This method creates an interator that implements such an analysis
of list (or iterator) <tt class="docutils literal"><span class="pre">datalist</span></tt>, which contains bootstrap
copies of the original data set. Each <tt class="docutils literal"><span class="pre">data_list[i]</span></tt> is a different
<tt class="docutils literal"><span class="pre">data</span></tt> input for <tt class="docutils literal"><span class="pre">self.lsqfit()</span></tt> (that is, a dictionary containing
fit data). The iterator works its way through the data sets in
<tt class="docutils literal"><span class="pre">data_list</span></tt>, fitting the next data set on each iteration and
returning the resulting <tt class="xref py py-class docutils literal"><span class="pre">lsqfit.LSQFit</span></tt> fit object. Typical
usage, for an <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> object named <tt class="docutils literal"><span class="pre">fitter</span></tt>, would be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">fit</span> <span class="ow">in</span> <span class="n">fitter</span><span class="o">.</span><span class="n">bootstrap_iter</span><span class="p">(</span><span class="n">datalist</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">analyze</span> <span class="n">fit</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span> <span class="o">...</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_list</strong> (sequence or iterator or <tt class="docutils literal"><span class="pre">None</span></tt>) &#8211; Collection of bootstrap <tt class="docutils literal"><span class="pre">data</span></tt> sets for fitter. If
<tt class="docutils literal"><span class="pre">None</span></tt>, the data_list is generated internally using the 
means and standard deviations of the fit data (assuming
gaussian statistics).</li>
<li><strong>n</strong> (<em>integer</em>) &#8211; Maximum number of iterations if <tt class="docutils literal"><span class="pre">n</span></tt> is not <tt class="docutils literal"><span class="pre">None</span></tt>;
otherwise there is no maximum.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Iterator that returns a <tt class="xref py py-class docutils literal"><span class="pre">lsqfit.LSQFit</span></tt> object 
containing results from the fit to the next data set in
<tt class="docutils literal"><span class="pre">data_list</span></tt>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="corrfitter.CorrFitter.builddata">
<tt class="descname">builddata</tt><big>(</big><em>data</em>, <em>prior</em>, <em>nterm=None</em><big>)</big><a class="headerlink" href="#corrfitter.CorrFitter.builddata" title="Permalink to this definition">¶</a></dt>
<dd><p>Build fit data, corrected for marginalized terms.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.CorrFitter.buildfitfcn">
<tt class="descname">buildfitfcn</tt><big>(</big><em>priorkeys</em><big>)</big><a class="headerlink" href="#corrfitter.CorrFitter.buildfitfcn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create fit function, with support for log-normal,... priors.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.CorrFitter.buildprior">
<tt class="descname">buildprior</tt><big>(</big><em>prior</em>, <em>nterm=None</em><big>)</big><a class="headerlink" href="#corrfitter.CorrFitter.buildprior" title="Permalink to this definition">¶</a></dt>
<dd><p>Build correctly sized prior for fit.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.CorrFitter.chained_lsqfit">
<tt class="descname">chained_lsqfit</tt><big>(</big><em>data</em>, <em>prior</em>, <em>p0=None</em>, <em>print_fit=True</em>, <em>nterm=None</em>, <em>svdcut=None</em>, <em>svdnum=None</em>, <em>tol=None</em>, <em>maxit=None</em>, <em>aux_param={}</em>, <em>**args</em><big>)</big><a class="headerlink" href="#corrfitter.CorrFitter.chained_lsqfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute chained least-squares fit of the correlator models to data.</p>
<p>A <em>chained</em> fit fits data for each model sequentially, using the
best-fit parameters of one fit as priors for fit parameters in the 
next fit. Results from the individual fits can be found in dictionary
<tt class="docutils literal"><span class="pre">self.chained_fits</span></tt>, which is indexed by the <tt class="docutils literal"><span class="pre">m.datatag</span></tt>s for 
the models <tt class="docutils literal"><span class="pre">m</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>dictionary</em>) &#8211; Input data. The <tt class="docutils literal"><span class="pre">datatag</span></tt>s from the 
correlator models are used as data labels, with 
<tt class="docutils literal"><span class="pre">data[datatag]</span></tt> being a 1-d array of <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s 
corresponding to correlator values.</li>
<li><strong>prior</strong> (<em>dictionary</em>) &#8211; Bayesian prior for the fit parameters used in the 
correlator models.</li>
<li><strong>p0</strong> &#8211; A dictionary, indexed by parameter labels, containing 
initial values for the parameters in the fit. Setting
<tt class="docutils literal"><span class="pre">p0=None</span></tt> implies that initial values are extracted from the
prior. Setting <tt class="docutils literal"><span class="pre">p0=&quot;filename&quot;</span></tt> causes the fitter to look in
the file with name <tt class="docutils literal"><span class="pre">&quot;filename&quot;</span></tt> for initial values and to
write out best-fit parameter values after the fit (for the next
call to <tt class="docutils literal"><span class="pre">self.lsqfit()</span></tt>).</li>
<li><strong>print_fit</strong> &#8211; Print fit information to standard output if 
<tt class="docutils literal"><span class="pre">True</span></tt>; otherwise print nothing.</li>
<li><strong>aux_param</strong> (<em>dictionary</em>) &#8211; A dictionary containing priors for 
additional (auxilary) fit parameters. Where <tt class="docutils literal"><span class="pre">aux_param</span></tt>
and <tt class="docutils literal"><span class="pre">prior</span></tt> share keys, the entry in <tt class="docutils literal"><span class="pre">aux_param</span></tt> is
used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following parameters overwrite the values specified in the
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> constructor when set to anything other than <tt class="docutils literal"><span class="pre">None</span></tt>:
<tt class="docutils literal"><span class="pre">nterm</span></tt>, <tt class="docutils literal"><span class="pre">svdcut</span></tt>, <tt class="docutils literal"><span class="pre">svdnum</span></tt>, <tt class="docutils literal"><span class="pre">tol</span></tt>, and <tt class="docutils literal"><span class="pre">maxit</span></tt>. Any
further keyword arguments are passed on to
<tt class="xref py py-func docutils literal"><span class="pre">lsqfit.nonlinear_fit()</span></tt>, which does the fit.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.CorrFitter.collect_fitresults">
<tt class="descname">collect_fitresults</tt><big>(</big><big>)</big><a class="headerlink" href="#corrfitter.CorrFitter.collect_fitresults" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect results from last fit for plots, tables etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dictionary with one entry per correlator model,
containing <tt class="docutils literal"><span class="pre">(t,G,dG,Gth,dGth)</span></tt> &#8212; arrays containing:<div class="highlight-python"><pre>t       = times
G(t)    = data averages for correlator at times t
dG(t)   = uncertainties in G(t)
Gth(t)  = fit function for G(t) with best-fit parameters
dGth(t) = uncertainties in Gth(t)</pre>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="corrfitter.CorrFitter.display_plots">
<tt class="descname">display_plots</tt><big>(</big><big>)</big><a class="headerlink" href="#corrfitter.CorrFitter.display_plots" title="Permalink to this definition">¶</a></dt>
<dd><p>Show plots of data/fit-function for each correlator.</p>
<p>Assumes <tt class="xref py py-mod docutils literal"><span class="pre">matplotlib</span></tt> is installed (to make the plots). Plots
are shown for one correlator at a time. Press key <tt class="docutils literal"><span class="pre">n</span></tt> to see the
next correlator; press key <tt class="docutils literal"><span class="pre">p</span></tt> to see the previous one; press key
<tt class="docutils literal"><span class="pre">q</span></tt> to quit the plot and return control to the calling program;
press a digit to go directly to one of the first ten plots. Zoom,
pan and save using the window controls.</p>
</dd></dl>

<dl class="method">
<dt id="corrfitter.CorrFitter.lsqfit">
<tt class="descname">lsqfit</tt><big>(</big><em>data</em>, <em>prior</em>, <em>p0=None</em>, <em>print_fit=True</em>, <em>nterm=None</em>, <em>svdcut=None</em>, <em>svdnum=None</em>, <em>tol=None</em>, <em>maxit=None</em>, <em>aux_param={}</em>, <em>**args</em><big>)</big><a class="headerlink" href="#corrfitter.CorrFitter.lsqfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute least-squares fit of the correlator models to data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>dictionary</em>) &#8211; Input data. The <tt class="docutils literal"><span class="pre">datatag</span></tt>s from the 
correlator models are used as data labels, with 
<tt class="docutils literal"><span class="pre">data[datatag]</span></tt> being a 1-d array of <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s 
corresponding to correlator values.</li>
<li><strong>prior</strong> (<em>dictionary</em>) &#8211; Bayesian prior for the fit parameters used in the 
correlator models.</li>
<li><strong>p0</strong> &#8211; A dictionary, indexed by parameter labels, containing 
initial values for the parameters in the fit. Setting
<tt class="docutils literal"><span class="pre">p0=None</span></tt> implies that initial values are extracted from the
prior. Setting <tt class="docutils literal"><span class="pre">p0=&quot;filename&quot;</span></tt> causes the fitter to look in
the file with name <tt class="docutils literal"><span class="pre">&quot;filename&quot;</span></tt> for initial values and to
write out best-fit parameter values after the fit (for the next
call to <tt class="docutils literal"><span class="pre">self.lsqfit()</span></tt>).</li>
<li><strong>print_fit</strong> &#8211; Print fit information to standard output if 
<tt class="docutils literal"><span class="pre">True</span></tt>; otherwise print nothing.</li>
<li><strong>aux_param</strong> (<em>dictionary</em>) &#8211; A dictionary containing priors for 
additional (auxilary) fit parameters. Where <tt class="docutils literal"><span class="pre">aux_param</span></tt>
and <tt class="docutils literal"><span class="pre">prior</span></tt> share keys, the entry in <tt class="docutils literal"><span class="pre">aux_param</span></tt> is
used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The following parameters overwrite the values specified in the
<a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> constructor when set to anything other than <tt class="docutils literal"><span class="pre">None</span></tt>:
<tt class="docutils literal"><span class="pre">nterm</span></tt>, <tt class="docutils literal"><span class="pre">svdcut</span></tt>, <tt class="docutils literal"><span class="pre">svdnum</span></tt>, <tt class="docutils literal"><span class="pre">tol</span></tt>, and <tt class="docutils literal"><span class="pre">maxit</span></tt>. Any
further keyword arguments are passed on to
<tt class="xref py py-func docutils literal"><span class="pre">lsqfit.nonlinear_fit()</span></tt>, which does the fit.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="fast-fit-objects">
<h2>Fast Fit Objects<a class="headerlink" href="#fast-fit-objects" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="corrfitter.fastfit">
<em class="property">class </em><tt class="descclassname">corrfitter.</tt><tt class="descname">fastfit</tt><big>(</big><em>data</em>, <em>prior</em>, <em>model</em>, <em>svdcut=None</em>, <em>svdnum=None</em>, <em>ratio=True</em>, <em>osc=False</em><big>)</big><a class="headerlink" href="#corrfitter.fastfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast fit for the leading component of a <tt class="xref py py-mod docutils literal"><span class="pre">Corr2</span></tt>.</p>
<p>This function class estimates <tt class="docutils literal"><span class="pre">En[0]</span></tt> and <tt class="docutils literal"><span class="pre">an[0]*bn[0]</span></tt> in a two-point 
correlator:</p>
<div class="highlight-python"><pre>Gab(t) = sn * sum_i an[i]*bn[i] * fn(En[i], t)
       + so * sum_i ao[i]*bo[i] * fo(Eo[i], t)</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">sn</span></tt> and <tt class="docutils literal"><span class="pre">so</span></tt> are typically <tt class="docutils literal"><span class="pre">-1</span></tt>, <tt class="docutils literal"><span class="pre">0</span></tt>, or <tt class="docutils literal"><span class="pre">1</span></tt> and</p>
<div class="highlight-python"><pre>fn(E, t) =  exp(-E*t) + exp(-E*(tp-t)) # tp&gt;0 -- periodic
       or   exp(-E*t) - exp(-E*(-tp-t))# tp&lt;0 -- anti-periodic
       or   exp(-E*t)                  # if tp is None (nonperiodic)

fo(E, t) = (-1)**t * fn(E, t)</pre>
</div>
<p>The correlator is specified by <tt class="docutils literal"><span class="pre">model</span></tt>, and <tt class="docutils literal"><span class="pre">prior</span></tt> is used to 
remove (marginalize) all terms other than the <tt class="docutils literal"><span class="pre">En[0]</span></tt> term
from the data. This gives a <em>corrected</em> correlator <tt class="docutils literal"><span class="pre">Gc(t)</span></tt> that 
includes uncertainties due to the terms removed. Estimates of <tt class="docutils literal"><span class="pre">En[0]</span></tt> 
are given by:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Eeff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">arccosh</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">Gc</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">Gc</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">Gc</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
</pre></div>
</div>
<p>The final estimate is the weighted average <tt class="docutils literal"><span class="pre">Eeff_avg</span></tt> of the
<tt class="docutils literal"><span class="pre">Eeff(t)</span></tt>s for different <tt class="docutils literal"><span class="pre">t</span></tt>s. Similarly, an estimate for the
product of amplitutes, <tt class="docutils literal"><span class="pre">an[0]*bn[0]</span></tt> is obtained from the weighted
average of</p>
<div class="highlight-python"><pre>Aeff(t) = Gc(t)/fn(Eeff_avg, t). </pre>
</div>
<p>If <tt class="docutils literal"><span class="pre">osc=True</span></tt>, an estimate is returned for <tt class="docutils literal"><span class="pre">Eo[0]</span></tt> rather
than <tt class="docutils literal"><span class="pre">En[0]</span></tt>, and <tt class="docutils literal"><span class="pre">ao[0]*bo[0]</span></tt> rather than <tt class="docutils literal"><span class="pre">an[0]*bn[0]</span></tt>. 
These estimates are most reliable when <tt class="docutils literal"><span class="pre">Eo[0]</span></tt> is smaller than
<tt class="docutils literal"><span class="pre">En[0]</span></tt> (and so dominates at large <tt class="docutils literal"><span class="pre">t</span></tt>).</p>
<p>The results of the fast fit are stored and returned in an object of type 
<a class="reference internal" href="#corrfitter.fastfit" title="corrfitter.fastfit"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.fastfit</span></tt></a> with the following attributies:</p>
<dl class="attribute">
<dt id="fastfit.E">
<tt class="descname">E</tt><a class="headerlink" href="#fastfit.E" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate of <tt class="docutils literal"><span class="pre">En[0]</span></tt> (or <tt class="docutils literal"><span class="pre">Eo[0]</span></tt> if <tt class="docutils literal"><span class="pre">osc==True</span></tt>) computed
from the weighted average of <tt class="docutils literal"><span class="pre">Eeff(t)</span></tt> for <tt class="docutils literal"><span class="pre">t</span></tt>s in
<tt class="docutils literal"><span class="pre">model.tfit</span></tt>. The prior is also included in the weighted average.</p>
</dd></dl>

<dl class="attribute">
<dt id="fastfit.ampl">
<tt class="descname">ampl</tt><a class="headerlink" href="#fastfit.ampl" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate of <tt class="docutils literal"><span class="pre">an[0]*bn[0]</span></tt> (or <tt class="docutils literal"><span class="pre">ao[0]*bo[0]</span></tt> if <tt class="docutils literal"><span class="pre">osc==True</span></tt>)
computed from the weighted average of <tt class="docutils literal"><span class="pre">Aeff(t)</span></tt> for <tt class="docutils literal"><span class="pre">t</span></tt>s in
<tt class="docutils literal"><span class="pre">model.tfit[1:-1]</span></tt>. The prior is also included in the weighted 
average.</p>
</dd></dl>

<dl class="attribute">
<dt id="fastfit.chi2">
<tt class="descname">chi2</tt><a class="headerlink" href="#fastfit.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">chi[0]</span></tt> is the <tt class="docutils literal"><span class="pre">chi**2</span></tt> for the weighted average of
<tt class="docutils literal"><span class="pre">Eeff(t)</span></tt>s; <tt class="docutils literal"><span class="pre">chi[1]</span></tt> is the same for the <tt class="docutils literal"><span class="pre">Aeff(t)</span></tt>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="fastfit.dof">
<tt class="descname">dof</tt><a class="headerlink" href="#fastfit.dof" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">dof[0]</span></tt> is the effective number of degrees of freedom in the
weighted average of <tt class="docutils literal"><span class="pre">Eeff(t)</span></tt>s; <tt class="docutils literal"><span class="pre">dof[1]</span></tt> is the same for the
<tt class="docutils literal"><span class="pre">Aeff(t)</span></tt>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="fastfit.Q">
<tt class="descname">Q</tt><a class="headerlink" href="#fastfit.Q" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">Q[0]</span></tt> is the quality factor <cite>Q</cite> for the weighted average of
<tt class="docutils literal"><span class="pre">Eeff(t)</span></tt>s; <tt class="docutils literal"><span class="pre">Q[1]</span></tt> is the same for the <tt class="docutils literal"><span class="pre">Aeff(t)</span></tt>s.</p>
</dd></dl>

<dl class="attribute">
<dt id="fastfit.Elist">
<tt class="descname">Elist</tt><a class="headerlink" href="#fastfit.Elist" title="Permalink to this definition">¶</a></dt>
<dd><p>List of <tt class="docutils literal"><span class="pre">Eeff(t)</span></tt>s used in the weighted average to estimate
<tt class="docutils literal"><span class="pre">E</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="fastfit.ampllist">
<tt class="descname">ampllist</tt><a class="headerlink" href="#fastfit.ampllist" title="Permalink to this definition">¶</a></dt>
<dd><p>List of <tt class="docutils literal"><span class="pre">Aeff(t)</span></tt>s used in the weighted average to estimate
<tt class="docutils literal"><span class="pre">ampl</span></tt>.</p>
</dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>dictionary</em>) &#8211; Input data. The <tt class="docutils literal"><span class="pre">datatag</span></tt> from the correlator model is
used as a data key, with <tt class="docutils literal"><span class="pre">data[datatag]</span></tt> being a 1-d array of
<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s corresponding to the correlator values.</li>
<li><strong>prior</strong> (<em>dictionary</em>) &#8211; Bayesian prior for the fit parameters in the 
correlator model.</li>
<li><strong>model</strong> (<em>Corr2</em>) &#8211; Correlator model for correlator of interest. The <tt class="docutils literal"><span class="pre">t</span></tt>s
in <tt class="docutils literal"><span class="pre">model.tfit</span></tt> must be consecutive.</li>
<li><strong>osc</strong> (<em>Bool</em>) &#8211; If <tt class="docutils literal"><span class="pre">True</span></tt>, extract results for the leading oscillating
term in the correlator (<tt class="docutils literal"><span class="pre">Eo[0]</span></tt>); otherwise ignore.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>In addition an <em>svd</em> cut can be specified, as in <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>, using
parameters <tt class="docutils literal"><span class="pre">svdcut</span></tt> and <tt class="docutils literal"><span class="pre">svdnum</span></tt>. Also the type of marginalization
use can be specified with parameter <tt class="docutils literal"><span class="pre">ratio</span></tt> (see <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>).</p>
</dd></dl>

</div>
<div class="section" id="annotated-example">
<span id="id2"></span><h2>Annotated Example<a class="headerlink" href="#annotated-example" title="Permalink to this headline">¶</a></h2>
<p>In this section we describe a complete script that uses <tt class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></tt> to
extract energies, amplitudes, and transition matrix elements for  the
<img class="math" src="_images/math/3b0d0f0c8e85c32385cfdcaa002db15b76af05fd.png" alt="\eta_s"/> and <img class="math" src="_images/math/222b27b474c84d3c9b9914914eefff12e57397fe.png" alt="D_s"/> mesons. The source code (<tt class="docutils literal"><span class="pre">example.py</span></tt>) and
data file (<tt class="docutils literal"><span class="pre">example.data</span></tt>) are included with the <tt class="xref py py-mod docutils literal"><span class="pre">corrfitter</span></tt>
distribution, in the <tt class="docutils literal"><span class="pre">examples/</span></tt> directory.</p>
<p>The <tt class="docutils literal"><span class="pre">main</span></tt> method follows the pattern described in <a class="reference internal" href="#faster-fits"><em>Faster Fits</em></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>   <span class="c"># makes this work for python2 and 3</span>

<span class="kn">import</span> <span class="nn">gvar</span> <span class="kn">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">corrfitter</span> <span class="kn">import</span> <span class="n">CorrFitter</span><span class="p">,</span> <span class="n">Corr2</span><span class="p">,</span> <span class="n">Corr3</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;example.data&#39;</span><span class="p">)</span>
    <span class="n">fitter</span> <span class="o">=</span> <span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">make_models</span><span class="p">())</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="s">&#39;nterm =&#39;</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">pmean</span>
    <span class="n">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">fitter</span><span class="o">.</span><span class="n">display_plots</span><span class="p">()</span>
</pre></div>
</div>
<p>The raw Monte Carlo data is in a file named <tt class="docutils literal"><span class="pre">'example.data'</span></tt>. We are doing
four fits, with 1, 2, 3, and 4 terms in the fit function. Each fit starts its
minimization at point <tt class="docutils literal"><span class="pre">p0</span></tt>, which is set equal to the mean values of the
best-fit parameters from the previous fit (<tt class="docutils literal"><span class="pre">p0</span> <span class="pre">=</span> <span class="pre">fit.pmean</span></tt>). This reduces
the  number of iterations needed for convergence in the <tt class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">4</span></tt> fit, for
example, from 110 to 12. It also makes multi-term fits more stable.</p>
<p>The last line displays plots of the fit data divided by the fit, provided
<tt class="xref py py-mod docutils literal"><span class="pre">matplotlib</span></tt> is installed. A plot is made for each correlator, and the
ratios should equal one to within errors. To
move from one plot to the next press &#8220;n&#8221; on the keyboard; to move to a
previous plot press &#8220;p&#8221;; to quit the plots press &#8220;q&#8221;.</p>
<p>We now look at each other major routine in turn.</p>
<div class="section" id="id3">
<h3>a) make_data<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Method <tt class="docutils literal"><span class="pre">make_data('example.data')</span></tt> reads in the Monte Carlo data, averages
it, and formats it for use by <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>. The data file (<tt class="docutils literal"><span class="pre">'example.data'</span></tt>)
contains 2260 lines,  each with 64 numbers on it, of the form:</p>
<div class="highlight-python"><pre>etas    0.3045088594E+00    0.7846334531E-01    0.3307295938E-01 ...
etas    0.3058093438E+00    0.7949004688E-01    0.3344648906E-01 ...
...</pre>
</div>
<p>Each of these lines is a single Monte Carlo estimate for the <img class="math" src="_images/math/3b0d0f0c8e85c32385cfdcaa002db15b76af05fd.png" alt="\eta_s"/>
correlator on a lattice with 64 lattice points in the <tt class="docutils literal"><span class="pre">t</span></tt> direction;
there are 2260 Monte Carlo estimates in all. The same file also contains
2260 lines describing the <img class="math" src="_images/math/222b27b474c84d3c9b9914914eefff12e57397fe.png" alt="D_s"/> meson correlator:</p>
<div class="highlight-python"><pre>Ds    0.2303351094E+00    0.4445243750E-01    0.8941437344E-02 ...
Ds    0.2306766563E+00    0.4460026875E-01    0.8991960781E-02 ...
...</pre>
</div>
<p>And it contains 2260 lines each giving the 3-point amplitude for
<img class="math" src="_images/math/7c4689735e55bf91d7969585abb5d3f62d41947b.png" alt="\eta_s \to D_s"/>
where the source and sink are separated by 15 and 16 time steps on the
lattice:</p>
<div class="highlight-python"><pre>3ptT15    0.4679643906E-09    0.1079643844E-08    0.2422032031E-08 ...
3ptT15    0.4927106406E-09    0.1162639109E-08    0.2596277812E-08 ...
...

3ptT16     0.1420718453E-09    0.3205214219E-09    0.7382921875E-09 ...
3ptT16     0.1501385469E-09    0.3478552344E-09    0.8107883594E-09 ...
...</pre>
</div>
<p>The first, second, third, <em>etc.</em> lines for each label come from the first,
second, third, <em>etc.</em> Monte Carlo iterations, respectively; this allows
the code to compute correlations between different
types of data.</p>
<p>We use the tools in <tt class="xref py py-mod docutils literal"><span class="pre">gvar.dataset</span></tt> designed for reading files in this
format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">make_data</span><span class="p">(</span><span class="n">datafile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Read data from datafile and average it. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">datafile</span><span class="p">))</span>
</pre></div>
</div>
<p>This routine returns a dictionary whose keys are the strings used to label the
individual lines in <tt class="docutils literal"><span class="pre">example.data</span></tt>: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;example.data&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;Ds&#39;</span><span class="p">])</span>
<span class="go">[0.230715 +- 5.21002e-06 0.0446524 +- 2.60723e-06 0.00899239 +- 1.02701e-06</span>
<span class="go"> ...</span>
<span class="go"> 0.0446529 +- 2.57709e-06]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;3ptT16&#39;</span><span class="p">])</span>
<span class="go">[1.45834e-10 +- 1.71924e-13 3.36366e-10 +- 3.75092e-13</span>
<span class="go"> ...</span>
<span class="go"> 2.31545e-05 +- 2.52032e-08]</span>
</pre></div>
</div>
<p>Here each entry in <tt class="docutils literal"><span class="pre">data</span></tt> is an array of <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s representing the Monte
Carlo estimates (mean and covariance) for the corresponding correlator. This
is the format needed by <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a>.</p>
</div>
<div class="section" id="id4">
<h3>b) make_models<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Method <tt class="docutils literal"><span class="pre">make_models()</span></tt> specifies the theoretical models that will be used
to fit the data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">make_models</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Create models to fit data. &quot;&quot;&quot;</span>
    <span class="n">tmin</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">tp</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">Corr2</span><span class="p">(</span>
            <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;etas&#39;</span><span class="p">,</span>
            <span class="n">tp</span><span class="o">=</span><span class="n">tp</span><span class="p">,</span>  <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">tmin</span><span class="p">),</span>  <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tp</span><span class="o">-</span><span class="n">tmin</span><span class="p">),</span>
            <span class="n">a</span><span class="o">=</span><span class="s">&#39;etas:a&#39;</span><span class="p">,</span>  <span class="n">b</span><span class="o">=</span><span class="s">&#39;etas:a&#39;</span><span class="p">,</span>  <span class="n">dE</span><span class="o">=</span><span class="s">&#39;etas:dE&#39;</span>
            <span class="p">),</span>

        <span class="n">Corr2</span><span class="p">(</span>
            <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;Ds&#39;</span><span class="p">,</span>
            <span class="n">tp</span><span class="o">=</span><span class="n">tp</span><span class="p">,</span>  <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">tmin</span><span class="p">),</span>  <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tp</span><span class="o">-</span><span class="n">tmin</span><span class="p">),</span>
            <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;Ds:a&#39;</span><span class="p">,</span> <span class="s">&#39;Ds:ao&#39;</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;Ds:a&#39;</span><span class="p">,</span> <span class="s">&#39;Ds:ao&#39;</span><span class="p">),</span>
            <span class="n">dE</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;Ds:dE&#39;</span><span class="p">,</span> <span class="s">&#39;Ds:dEo&#39;</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
            <span class="p">),</span>

        <span class="n">Corr3</span><span class="p">(</span>
            <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;3ptT15&#39;</span><span class="p">,</span>
            <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">T</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="mi">16</span><span class="o">-</span><span class="n">tmin</span><span class="p">),</span>
            <span class="n">a</span><span class="o">=</span><span class="s">&#39;etas:a&#39;</span><span class="p">,</span> <span class="n">dEa</span><span class="o">=</span><span class="s">&#39;etas:dE&#39;</span><span class="p">,</span> <span class="n">tpa</span><span class="o">=</span><span class="n">tp</span><span class="p">,</span>
            <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;Ds:a&#39;</span><span class="p">,</span> <span class="s">&#39;Ds:ao&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;Ds:dE&#39;</span><span class="p">,</span> <span class="s">&#39;Ds:dEo&#39;</span><span class="p">),</span> <span class="n">tpb</span><span class="o">=</span><span class="n">tp</span><span class="p">,</span> <span class="n">sb</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">),</span>
            <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span>
            <span class="p">),</span>

        <span class="n">Corr3</span><span class="p">(</span>
            <span class="n">datatag</span><span class="o">=</span><span class="s">&#39;3ptT16&#39;</span><span class="p">,</span>
            <span class="n">tdata</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">17</span><span class="p">),</span> <span class="n">T</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">tfit</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">tmin</span><span class="p">,</span> <span class="mi">17</span><span class="o">-</span><span class="n">tmin</span><span class="p">),</span>
            <span class="n">a</span><span class="o">=</span><span class="s">&#39;etas:a&#39;</span><span class="p">,</span> <span class="n">dEa</span><span class="o">=</span><span class="s">&#39;etas:dE&#39;</span><span class="p">,</span> <span class="n">tpa</span><span class="o">=</span><span class="n">tp</span><span class="p">,</span>
            <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;Ds:a&#39;</span><span class="p">,</span> <span class="s">&#39;Ds:ao&#39;</span><span class="p">),</span> <span class="n">dEb</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;Ds:dE&#39;</span><span class="p">,</span> <span class="s">&#39;Ds:dEo&#39;</span><span class="p">),</span> <span class="n">tpb</span><span class="o">=</span><span class="n">tp</span><span class="p">,</span> <span class="n">sb</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">),</span>
            <span class="n">Vnn</span><span class="o">=</span><span class="s">&#39;Vnn&#39;</span><span class="p">,</span> <span class="n">Vno</span><span class="o">=</span><span class="s">&#39;Vno&#39;</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">models</span>
</pre></div>
</div>
<p>Four models are specified, one for each correlator to be fit. The first two
are for the <img class="math" src="_images/math/3b0d0f0c8e85c32385cfdcaa002db15b76af05fd.png" alt="\eta_s"/> and <img class="math" src="_images/math/222b27b474c84d3c9b9914914eefff12e57397fe.png" alt="D_s"/> two-point correlators, corresponding to
entries in the data dictionary with keys <tt class="docutils literal"><span class="pre">'etas'</span></tt> and <tt class="docutils literal"><span class="pre">'Ds'</span></tt>,
respectively. These are periodic propagators, with period 64 (<tt class="docutils literal"><span class="pre">tp</span></tt>), and we want to
omit the first and last 5 (<tt class="docutils literal"><span class="pre">tmin</span></tt>) time steps in the correlator. The
<tt class="docutils literal"><span class="pre">t</span></tt>s to be fit are listed in <tt class="docutils literal"><span class="pre">tfit</span></tt>, while the <tt class="docutils literal"><span class="pre">t</span></tt>s contained in the
data are in <tt class="docutils literal"><span class="pre">tdata</span></tt>. Labels for the fit parameters corresponding to the
sources (and sinks) are specified for each, <tt class="docutils literal"><span class="pre">'etas:a'</span></tt> and <tt class="docutils literal"><span class="pre">'Ds:a'</span></tt>, as
are labels for the energy differences, <tt class="docutils literal"><span class="pre">'etas:dE'</span></tt> and <tt class="docutils literal"><span class="pre">'Ds:dE'</span></tt>.  The
<img class="math" src="_images/math/222b27b474c84d3c9b9914914eefff12e57397fe.png" alt="D_s"/> propagator also has an oscillating piece because this data comes from
a staggered-quark analysis. Sources/sinks and energy differences are
specified for these as well: <tt class="docutils literal"><span class="pre">'Ds:ao'</span></tt> and <tt class="docutils literal"><span class="pre">'Ds:dEo'</span></tt>.</p>
<p>Finally three-point models are specifies for the data corresponding to
data-dictionary keys <tt class="docutils literal"><span class="pre">'3ptT15'</span></tt> and <tt class="docutils literal"><span class="pre">'3ptT16'</span></tt>. These share several
parameters with the two-point correlators, but introduce new parameters
for the transition elements: <tt class="docutils literal"><span class="pre">'Vnn'</span></tt> connecting normal states, and
<tt class="docutils literal"><span class="pre">'Vno'</span></tt> connecting normal states with oscillating states.</p>
</div>
<div class="section" id="id5">
<h3>c) make_prior<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>Method <tt class="docutils literal"><span class="pre">make_prior(N)</span></tt> creates <em>a priori</em> estimates for each fit
parameter, to be used as priors in the fitter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">make_prior</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create priors for fit parameters. &quot;&quot;&quot;</span>
    <span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
    <span class="c"># etas</span>
    <span class="n">metas</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="s">&#39;0.4(2)&#39;</span><span class="p">)</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(etas:a)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.3(3)&#39;</span><span class="p">]))</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(etas:dE)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.5(5)&#39;</span><span class="p">]))</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(etas:dE)&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">metas</span><span class="p">)</span>

    <span class="c"># Ds</span>
    <span class="n">mDs</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="s">&#39;1.2(2)&#39;</span><span class="p">)</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(Ds:a)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.3(3)&#39;</span><span class="p">]))</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(Ds:dE)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.5(5)&#39;</span><span class="p">]))</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(Ds:dE)&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mDs</span><span class="p">)</span>

    <span class="c"># Ds -- oscillating part</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(Ds:ao)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.1(1)&#39;</span><span class="p">]))</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(Ds:dEo)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0.5(5)&#39;</span><span class="p">]))</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;log(Ds:dEo)&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mDs</span> <span class="o">+</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="s">&#39;0.3(3)&#39;</span><span class="p">))</span>

    <span class="c"># V</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;Vnn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0(1)&#39;</span><span class="p">]])</span>
    <span class="n">prior</span><span class="p">[</span><span class="s">&#39;Vno&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;0(1)&#39;</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">prior</span>
</pre></div>
</div>
<p>Parameter <tt class="docutils literal"><span class="pre">N</span></tt> specifies how many terms are kept in the fit functions. The
priors are specified in a dictionary <tt class="docutils literal"><span class="pre">prior</span></tt>. Each entry is an array, of
length <tt class="docutils literal"><span class="pre">N</span></tt>, with one entry for each term. Each entry is a gaussian random
variable, specified by an object of type  <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>. Here we use the fact that
<tt class="docutils literal"><span class="pre">gvar.gvar()</span></tt> can make a list of <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s from a list of strings of the form
<tt class="docutils literal"><span class="pre">'0.1(1)'</span></tt>: for example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="s">&#39;1(2)&#39;</span><span class="p">,</span> <span class="s">&#39;3(2)&#39;</span><span class="p">]))</span>
<span class="go">[1 +- 2 3 +- 2]</span>
</pre></div>
</div>
<p>In this particular fit, we can assume that all the sinks/sources
are positive, and we can require that the energy differences be positive. To
force positivity, we use log-normal distributions for these parameters by
defining priors for <tt class="docutils literal"><span class="pre">'log(etas:a)'</span></tt>, <tt class="docutils literal"><span class="pre">'log(etas:dE)'</span></tt>,... rather than
<tt class="docutils literal"><span class="pre">'etas:a'</span></tt>,  <tt class="docutils literal"><span class="pre">'etas:dE'</span></tt>,... (see <a class="reference internal" href="#positive-parameters"><em>Faster Fits &#8212; Postive Parameters</em></a>). The <em>a
priori</em> values for these fit parameters are the logarithms of the values for
the parameters themselves: for example, each <tt class="docutils literal"><span class="pre">etas:a'</span></tt> has prior <tt class="docutils literal"><span class="pre">0.3(3)</span></tt>,
while the actual fit parameters, <tt class="docutils literal"><span class="pre">log(etas:a)</span></tt>, have priors
<tt class="docutils literal"><span class="pre">log(0.3(3))</span> <span class="pre">=</span> <span class="pre">-1.2(1.0)</span></tt>.</p>
<p>We override the default priors for the ground-state energies in each case.
This is not unusual since <tt class="docutils literal"><span class="pre">dE[0]</span></tt>, unlike the other <tt class="docutils literal"><span class="pre">dE</span></tt>s,  is an energy,
not an energy difference. For the oscillating <img class="math" src="_images/math/222b27b474c84d3c9b9914914eefff12e57397fe.png" alt="D_s"/> state, we require
that its mass be <tt class="docutils literal"><span class="pre">0.3(3)</span></tt> larger than the <img class="math" src="_images/math/222b27b474c84d3c9b9914914eefff12e57397fe.png" alt="D_s"/> mass. One could  put
more precise information into the priors if that made sense given the goals
of the simulation. For example, if the main objective is a value for <tt class="docutils literal"><span class="pre">Vnn</span></tt>,
one might include fairly exact information about the <img class="math" src="_images/math/222b27b474c84d3c9b9914914eefff12e57397fe.png" alt="D_s"/> and
<img class="math" src="_images/math/3b0d0f0c8e85c32385cfdcaa002db15b76af05fd.png" alt="\eta_s"/> masses in the prior, using results from experiment or from
earlier simulations. This would make no sense, however, if the goal is to
verify that simulations gives correct masses.</p>
<p>Note, finally, that a statement like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prior</span><span class="p">[</span><span class="s">&#39;Vnn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="n">N</span><span class="o">*</span> <span class="p">[</span><span class="s">&#39;0(1)&#39;</span><span class="p">]])</span>       <span class="c"># correct</span>
</pre></div>
</div>
<p>is <em>not</em> the same as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prior</span><span class="p">[</span><span class="s">&#39;Vnn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="s">&#39;0(1)&#39;</span><span class="p">)]]</span>      <span class="c"># wrong</span>
</pre></div>
</div>
<p>The former creates <tt class="docutils literal"><span class="pre">N</span> <span class="pre">**</span> <span class="pre">2</span></tt> independent <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s, with one for each element
of <tt class="docutils literal"><span class="pre">Vnn</span></tt>; it is one of the most succinct ways of creating a large number of
<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s. The latter creates only a single <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt> and uses it repeatedly for
every element <tt class="docutils literal"><span class="pre">Vnn</span></tt>, thereby forcing every element of <tt class="docutils literal"><span class="pre">Vnn</span></tt>  to be equal
to every other element in the fit (since the difference between any two of
their priors is <tt class="docutils literal"><span class="pre">0</span> <span class="pre">+-</span> <span class="pre">0</span></tt>); it is almost certainly not what is desired.
Usually one wants to create the array of strings first, and then convert it to
<tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s using <tt class="docutils literal"><span class="pre">gvar.gvar()</span></tt>.</p>
</div>
<div class="section" id="id6">
<h3>d) print_results<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Method <tt class="docutils literal"><span class="pre">print_results(fit,</span> <span class="pre">prior,</span> <span class="pre">data)</span></tt> reports on the best-fit values
for the fit parameters from the last fit:</p>
<div class="highlight-python"><pre>def print_results(fit, prior, data):
    print('Fit results:')
    p = fit.transformed_p                   # best-fit parameterss

    # etas
    E_etas = np.cumsum(p['etas:dE'])
    a_etas = p['etas:a'])
    print('  Eetas:', ' '.join(gv.fmt(E_etas[:3])))
    print('  aetas:', ' '.join(gv.fmt(a_etas[:3])))

    # Ds
    E_Ds = np.cumsum(p['Ds:dE'])
    a_Ds = p['Ds:a'])
    print('\n  EDs:', ' '.join(gv.fmt(E_Ds[:3])))
    print(  '  aDs:', ' '.join(gv.fmt(a_Ds[:3])))

    # Dso -- oscillating piece
    E_Dso = np.cumsum(p['Ds:dEo'])
    a_Dso = p['Ds:ao']
    print('\n  EDso:', ' '.join(gv.fmt(E_Dso[:3])))
    print(  '  aDso:', ' '.join(gv.fmt(a_Dso[:3])))

    # V
    Vnn = p['Vnn']
    Vno = p['Vno']
    print('\n  etas-&gt;V-&gt;Ds:', Vnn[0, 0].fmt())
    print('  etas-&gt;V-&gt;Dso:', Vno[0, 0].fmt())

    # error budget
    outputs = gv.BufferDict()
    outputs['metas'] = E_etas[0]
    outputs['mDs'] = E_Ds[0]
    outputs['mDso-mDs'] = E_Dso[0] - E_Ds[0]
    outputs['Vnn'] = Vnn[0, 0]
    outputs['Vno'] = Vno[0, 0]

    inputs = collections.OrderedDict()
    inputs['statistics'] = data             # statistical errors in data
    inputs.update(prior)                    # all entries in prior
    inputs['svd'] = fit.svdcorrection       # svd cut (if present)

    print('\n' + gv.fmt_values(outputs))
    print(gv.fmt_errorbudget(outputs, inputs))

    print('\n')</pre>
</div>
<p>The best-fit parameter values are stored in dictionary <tt class="docutils literal"><span class="pre">p=fit.transformed_p</span></tt>,
as are the exponentials of the log-normal parameters.
We also turn energy differences into energies using <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt>&#8216;s cummulative
sum function <tt class="xref py py-func docutils literal"><span class="pre">numpy.cumsum()</span></tt>. We use <tt class="xref py py-func docutils literal"><span class="pre">gvar.fmt()</span></tt> to convert arrays
of <tt class="xref py py-class docutils literal"><span class="pre">gvar.GVar</span></tt>s into arrays of strings representing those gaussian variables
with the format, for example, <tt class="docutils literal"><span class="pre">1.55(41)</span></tt>; and we use <tt class="xref py py-func docutils literal"><span class="pre">join()</span></tt> to join
these into a single output string. The final output is:</p>
<div class="highlight-python"><pre>Fit results:
  Eetas: 0.416221(81) 1.055(62) 1.55(41)
  aetas: 0.21841(11) 0.205(55) 0.30(17)

  EDs: 1.20171(13) 1.707(21) 2.22(22)
  aDs: 0.21477(18) 0.275(26) 0.44(18)

  EDso: 1.446(14) 1.68(12) 2.17(44)
  aDso: 0.0660(77) 0.083(33) 0.117(93)

  etas-&gt;V-&gt;Ds  = 0.76744(90)
  etas-&gt;V-&gt;Dso = -0.777(75)</pre>
</div>
<p>Finally we  create an error budget for the <img class="math" src="_images/math/3b0d0f0c8e85c32385cfdcaa002db15b76af05fd.png" alt="\eta_s"/>
and <img class="math" src="_images/math/222b27b474c84d3c9b9914914eefff12e57397fe.png" alt="D_s"/> masses, for the mass difference between the <img class="math" src="_images/math/222b27b474c84d3c9b9914914eefff12e57397fe.png" alt="D_s"/> and its
opposite-parity partner, and for the ground-state transition amplitudes
<tt class="docutils literal"><span class="pre">Vnn</span></tt> and <tt class="docutils literal"><span class="pre">Vno</span></tt>. The quantities of interest are specified in dictionary
<tt class="docutils literal"><span class="pre">outputs</span></tt>. For the error budget, we need another dictionary, <tt class="docutils literal"><span class="pre">inputs</span></tt>,
specifying various inputs to the calculation: the Monte Carlo data, the
priors, and the results from any <em>svd</em> cuts (none here). Each of these inputs
contributes to the errors in the final results, as detailed in the
error budget:</p>
<div class="highlight-python"><pre>Values:
              metas: 0.416221(81)
                mDs: 1.20171(13)
           mDso-mDs: 0.244(14)
                Vnn: 0.76744(90)
                Vno: -0.777(75)

Partial % Errors:
                         metas       mDs  mDso-mDs       Vnn       Vno
----------------------------------------------------------------------
         statistics:      0.02      0.01      4.03      0.11      7.01
        log(etas:a):      0.00      0.00      0.06      0.00      0.05
       log(etas:dE):      0.00      0.00      0.03      0.00      0.06
          log(Ds:a):      0.00      0.00      0.65      0.02      0.47
         log(Ds:dE):      0.00      0.00      0.66      0.02      0.25
         log(Ds:ao):      0.00      0.00      1.11      0.01      3.88
        log(Ds:dEo):      0.00      0.00      1.21      0.01      4.47
                Vnn:      0.00      0.00      0.80      0.03      1.01
                Vno:      0.00      0.00      3.70      0.01      2.70
                svd:      0.00      0.00      0.00      0.00      0.00
----------------------------------------------------------------------
              total:      0.02      0.01      5.84      0.12      9.63</pre>
</div>
<p>The error budget shows, for example, that the largest sources of uncertainty
in every quantity are the statistical errors in the input data.</p>
</div>
<div class="section" id="e-final-results">
<h3>e) Final Results<a class="headerlink" href="#e-final-results" title="Permalink to this headline">¶</a></h3>
<p>The output from running this code is as follows:</p>
<div class="highlight-python"><pre>============================== nterm = 1
Least Square Fit:
  chi2/dof [dof] = 6.3e+03 [69]    Q = 0    logGBF = -2.1405e+05    itns = 18

Parameters:
  log(etas:a) 0   -1.41467 (24)      [ -1.2 (1.0) ]
 log(etas:dE) 0   -0.81108 (14)      [ -0.92 (50) ]
    log(Ds:a) 0   -1.37608 (18)      [ -1.2 (1.0) ]
   log(Ds:dE) 0   0.214374 (56)      [  0.18 (17) ]
   log(Ds:ao) 0    -1.9192 (14)      [ -2.3 (1.0) ]
  log(Ds:dEo) 0    0.48264 (34)      [  0.41 (24) ]
        Vnn 0,0    0.72035 (40)      [  0.0 (1.0) ]
        Vno 0,0    -0.8100 (14)      [  0.0 (1.0) ]

Settings:
  svdcut = (None,None)   svdnum = (None,None)    reltol/abstol = 1e-10/1e-10

============================== nterm = 2
Least Square Fit:
  chi2/dof [dof] = 2.1 [69]    Q = 3.4e-07    logGBF = 1562.3    itns = 45

Parameters:
  log(etas:a) 0   -1.52073 (44)      [ -1.2 (1.0) ]
              1     -1.287 (15)      [ -1.2 (1.0) ]
 log(etas:dE) 0   -0.87641 (19)      [ -0.92 (50) ]
              1     -0.322 (10)      [ -0.7 (1.0) ]
    log(Ds:a) 0   -1.53867 (57)      [ -1.2 (1.0) ]
              1    -1.0814 (73)      [ -1.2 (1.0) ]
   log(Ds:dE) 0   0.183585 (89)      [  0.18 (17) ]
              1    -0.5882 (58)      [ -0.7 (1.0) ]
   log(Ds:ao) 0    -2.5911 (77)      [ -2.3 (1.0) ]
              1     -1.195 (85)      [ -2.3 (1.0) ]
  log(Ds:dEo) 0     0.3749 (14)      [  0.41 (24) ]
              1     -0.285 (44)      [ -0.7 (1.0) ]
        Vnn 0,0    0.76402 (44)      [  0.0 (1.0) ]
            0,1    -0.4608 (56)      [  0.0 (1.0) ]
            1,0     0.0754 (79)      [  0.0 (1.0) ]
            1,1      -0.81 (85)      [  0.0 (1.0) ]
        Vno 0,0    -0.6842 (77)      [  0.0 (1.0) ]
            0,1      1.091 (81)      [  0.0 (1.0) ]
            1,0      -1.07 (14)      [  0.0 (1.0) ]
            1,1       0.0 (1.0)      [  0.0 (1.0) ]

Settings:
  svdcut = (None,None)   svdnum = (None,None)    reltol/abstol = 1e-10/1e-10

============================== nterm = 3
Least Square Fit:
  chi2/dof [dof] = 0.6 [69]    Q = 1    logGBF = 1605.4    itns = 54

Parameters:
  log(etas:a) 0   -1.52138 (50)      [ -1.2 (1.0) ]
              1      -1.61 (33)      [ -1.2 (1.0) ]
              2      -1.12 (37)      [ -1.2 (1.0) ]
 log(etas:dE) 0   -0.87654 (20)      [ -0.92 (50) ]
              1      -0.46 (12)      [ -0.7 (1.0) ]
              2      -0.70 (69)      [ -0.7 (1.0) ]
    log(Ds:a) 0   -1.53823 (85)      [ -1.2 (1.0) ]
              1     -1.290 (94)      [ -1.2 (1.0) ]
              2      -0.74 (32)      [ -1.2 (1.0) ]
   log(Ds:dE) 0    0.18374 (11)      [  0.18 (17) ]
              1     -0.684 (41)      [ -0.7 (1.0) ]
              2      -0.62 (35)      [ -0.7 (1.0) ]
   log(Ds:ao) 0      -2.72 (12)      [ -2.3 (1.0) ]
              1      -2.49 (41)      [ -2.3 (1.0) ]
              2      -2.10 (77)      [ -2.3 (1.0) ]
  log(Ds:dEo) 0      0.369 (10)      [  0.41 (24) ]
              1      -1.44 (51)      [ -0.7 (1.0) ]
              2      -0.71 (80)      [ -0.7 (1.0) ]
        Vnn 0,0    0.76744 (90)      [  0.0 (1.0) ]
            0,1     -0.505 (39)      [  0.0 (1.0) ]
            0,2       0.46 (50)      [  0.0 (1.0) ]
            1,0      0.043 (44)      [  0.0 (1.0) ]
            1,1       0.22 (80)      [  0.0 (1.0) ]
            1,2       0.0 (1.0)      [  0.0 (1.0) ]
            2,0      -0.07 (25)      [  0.0 (1.0) ]
            2,1       0.0 (1.0)      [  0.0 (1.0) ]
            2,2       0.0 (1.0)      [  0.0 (1.0) ]
        Vno 0,0     -0.776 (75)      [  0.0 (1.0) ]
            0,1       0.30 (34)      [  0.0 (1.0) ]
            0,2      -0.01 (87)      [  0.0 (1.0) ]
            1,0       0.22 (45)      [  0.0 (1.0) ]
            1,1       0.07 (98)      [  0.0 (1.0) ]
            1,2       0.0 (1.0)      [  0.0 (1.0) ]
            2,0      -0.05 (97)      [  0.0 (1.0) ]
            2,1       0.0 (1.0)      [  0.0 (1.0) ]
            2,2       0.0 (1.0)      [  0.0 (1.0) ]

Settings:
  svdcut = (None,None)   svdnum = (None,None)    reltol/abstol = 1e-10/1e-10

============================== nterm = 4
Least Square Fit:
  chi2/dof [dof] = 0.6 [69]    Q = 1    logGBF = 1605.9    itns = 12

Parameters:
  log(etas:a) 0   -1.52137 (50)      [ -1.2 (1.0) ]
              1      -1.58 (27)      [ -1.2 (1.0) ]
              2      -1.21 (57)      [ -1.2 (1.0) ]
              3      -1.24 (97)      [ -1.2 (1.0) ]
 log(etas:dE) 0   -0.87654 (20)      [ -0.92 (50) ]
              1     -0.449 (96)      [ -0.7 (1.0) ]
              2      -0.71 (74)      [ -0.7 (1.0) ]
              3      -0.68 (98)      [ -0.7 (1.0) ]
    log(Ds:a) 0   -1.53821 (85)      [ -1.2 (1.0) ]
              1     -1.289 (94)      [ -1.2 (1.0) ]
              2      -0.81 (40)      [ -1.2 (1.0) ]
              3      -1.13 (99)      [ -1.2 (1.0) ]
   log(Ds:dE) 0    0.18374 (11)      [  0.18 (17) ]
              1     -0.683 (41)      [ -0.7 (1.0) ]
              2      -0.66 (39)      [ -0.7 (1.0) ]
              3      -0.75 (99)      [ -0.7 (1.0) ]
   log(Ds:ao) 0      -2.72 (12)      [ -2.3 (1.0) ]
              1      -2.49 (40)      [ -2.3 (1.0) ]
              2      -2.15 (79)      [ -2.3 (1.0) ]
              3      -2.3 (1.0)      [ -2.3 (1.0) ]
  log(Ds:dEo) 0     0.3686 (99)      [  0.41 (24) ]
              1      -1.45 (50)      [ -0.7 (1.0) ]
              2      -0.72 (79)      [ -0.7 (1.0) ]
              3      -0.7 (1.0)      [ -0.7 (1.0) ]
        Vnn 0,0    0.76744 (90)      [  0.0 (1.0) ]
            0,1     -0.508 (41)      [  0.0 (1.0) ]
            0,2       0.45 (51)      [  0.0 (1.0) ]
            0,3       0.07 (99)      [  0.0 (1.0) ]
            1,0      0.043 (45)      [  0.0 (1.0) ]
            1,1       0.22 (80)      [  0.0 (1.0) ]
            1,2       0.0 (1.0)      [  0.0 (1.0) ]
            1,3       0.0 (1.0)      [  0.0 (1.0) ]
            2,0      -0.08 (30)      [  0.0 (1.0) ]
            2,1       0.0 (1.0)      [  0.0 (1.0) ]
            2,2       0.0 (1.0)      [  0.0 (1.0) ]
            2,3       0.0 (1.0)      [  0.0 (1.0) ]
            3,0      -0.06 (99)      [  0.0 (1.0) ]
            3,1       0.0 (1.0)      [  0.0 (1.0) ]
            3,2       0.0 (1.0)      [  0.0 (1.0) ]
            3,3       0.0 (1.0)      [  0.0 (1.0) ]
        Vno 0,0     -0.777 (75)      [  0.0 (1.0) ]
            0,1       0.30 (34)      [  0.0 (1.0) ]
            0,2       0.00 (87)      [  0.0 (1.0) ]
            0,3       0.0 (1.0)      [  0.0 (1.0) ]
            1,0       0.21 (45)      [  0.0 (1.0) ]
            1,1       0.07 (98)      [  0.0 (1.0) ]
            1,2       0.0 (1.0)      [  0.0 (1.0) ]
            1,3       0.0 (1.0)      [  0.0 (1.0) ]
            2,0      -0.05 (97)      [  0.0 (1.0) ]
            2,1       0.0 (1.0)      [  0.0 (1.0) ]
            2,2       0.0 (1.0)      [  0.0 (1.0) ]
            2,3       0.0 (1.0)      [  0.0 (1.0) ]
            3,0      -0.0 (1.0)      [  0.0 (1.0) ]
            3,1       0.0 (1.0)      [  0.0 (1.0) ]
            3,2       0.0 (1.0)      [  0.0 (1.0) ]
            3,3       0.0 (1.0)      [  0.0 (1.0) ]

Settings:
  svdcut = (None,None)   svdnum = (None,None)    reltol/abstol = 1e-10/1e-10

Fit results:
  Eetas: 0.416221(81) 1.055(62) 1.55(41)
  aetas: 0.21841(11) 0.205(55) 0.30(17)

  EDs: 1.20171(13) 1.707(21) 2.22(22)
  aDs: 0.21477(18) 0.275(26) 0.44(18)

  EDso: 1.446(14) 1.68(12) 2.17(44)
  aDso: 0.0660(77) 0.083(33) 0.117(93)

  etas-&gt;V-&gt;Ds  = 0.76744(90)
  etas-&gt;V-&gt;Dso = -0.777(75)

Values:
              metas: 0.416221(81)        
                mDs: 1.20171(13)         
           mDso-mDs: 0.244(14)           
                Vnn: 0.76744(90)         
                Vno: -0.777(75)          

Partial % Errors:
                         metas       mDs  mDso-mDs       Vnn       Vno
----------------------------------------------------------------------
         statistics:      0.02      0.01      4.03      0.11      7.01
        log(etas:a):      0.00      0.00      0.06      0.00      0.05
       log(etas:dE):      0.00      0.00      0.03      0.00      0.06
          log(Ds:a):      0.00      0.00      0.65      0.02      0.47
         log(Ds:dE):      0.00      0.00      0.66      0.02      0.25
         log(Ds:ao):      0.00      0.00      1.11      0.01      3.88
        log(Ds:dEo):      0.00      0.00      1.21      0.01      4.47
                Vnn:      0.00      0.00      0.80      0.03      1.01
                Vno:      0.00      0.00      3.70      0.01      2.70
                svd:      0.00      0.00      0.00      0.00      0.00
----------------------------------------------------------------------
              total:      0.02      0.01      5.84      0.12      9.63



</pre>
</div>
<p>Note:</p>
<ul>
<li><p class="first">This is a relatively simple fit, taking only a couple of seconds on a
laptop.</p>
</li>
<li><p class="first">Fits with only one or two terms in the fit function are poor, with
<tt class="docutils literal"><span class="pre">chi2/dof</span></tt>s that are significantly larger than one.</p>
</li>
<li><p class="first">Fits with three terms work well, and adding futher terms has almost no
impact. The <tt class="docutils literal"><span class="pre">chi**2</span></tt> does not improve and parameters for the
added terms differ little from their prior values (since the data are
not sufficiently accurate to add new information).</p>
</li>
<li><p class="first">Chained fits (see <a class="reference internal" href="#chained-fits"><em>Faster Fits &#8212; Chained Fits</em></a>) are used if <tt class="docutils literal"><span class="pre">fitter.lsqfit(...)</span></tt>
is replaced by <tt class="docutils literal"><span class="pre">fitter.chained_lsqfit(...)</span></tt> in <tt class="docutils literal"><span class="pre">main()</span></tt>. The results
are about the same, though slightly more accurate: for example,</p>
<div class="highlight-python"><pre>Values:
              metas: 0.416199(81)
                mDs: 1.20164(14)
           mDso-mDs: 0.2595(51)
                Vnn: 0.76782(92)
                Vno: -0.755(25)</pre>
</div>
<p>We obtain essentially the same results,</p>
<div class="highlight-python"><pre>Values:
              metas: 0.416206(81)
                mDs: 1.20166(14)
           mDso-mDs: 0.2579(48)
                Vnn: 0.76760(83)
                Vno: -0.754(25)</pre>
</div>
<p>if we polish the final results from the chained fit using
a final call to <tt class="docutils literal"><span class="pre">fitter.lsqfit</span></tt> (see <a class="reference internal" href="#chained-fits"><em>Faster Fits &#8212; Chained Fits</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">chained_lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">svdcut</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Marginalization (see <a class="reference internal" href="#marginalized-fits"><em>Faster Fits &#8212; Marginalization</em></a>) can speed up fits like
this one. To use an 8-term fit function, while tuning parameters for only
<tt class="docutils literal"><span class="pre">N</span></tt> terms, we change only four lines in the main program:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">make_data</span><span class="p">(</span><span class="s">&#39;example.data&#39;</span><span class="p">)</span>
    <span class="n">models</span> <span class="o">=</span> <span class="n">make_models</span><span class="p">()</span>
    <span class="n">fitter</span> <span class="o">=</span> <span class="n">CorrFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">make_models</span><span class="p">(),</span> <span class="n">ratio</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>                  <span class="c">#1</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>                                                        <span class="c">#2</span>
        <span class="k">print</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="s">&#39;nterm =&#39;</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="n">prior</span> <span class="o">=</span> <span class="n">make_prior</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>                                               <span class="c">#3</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">nterm</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>    <span class="c">#4</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">pmean</span>
    <span class="n">print_results</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">fitter</span><span class="o">.</span><span class="n">display_plots</span><span class="p">()</span>
</pre></div>
</div>
<p>The first modification (<tt class="docutils literal"><span class="pre">#1</span></tt>) is in the definition of <tt class="docutils literal"><span class="pre">fitter</span></tt>, where we add
an extra argument to tell <a class="reference internal" href="#corrfitter.CorrFitter" title="corrfitter.CorrFitter"><tt class="xref py py-class docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt></a> what kind of marginalization
to use (that is, not the ratio method). The second modification (<tt class="docutils literal"><span class="pre">#2</span></tt>)
limits the
fits to <tt class="docutils literal"><span class="pre">N=1,2</span></tt>, because that is all that will be needed to get good
values for the leading term.
The third modification (<tt class="docutils literal"><span class="pre">#3</span></tt>) sets the prior to eight terms, no matter what value
<tt class="docutils literal"><span class="pre">N</span></tt> has. The last (<tt class="docutils literal"><span class="pre">#4</span></tt>) tells <tt class="docutils literal"><span class="pre">fitter.lsqfit</span></tt> to fit parameters from
only the first <tt class="docutils literal"><span class="pre">N</span></tt> terms in the fit function; parts of the prior that are
not being fit are incorporated (<em>marginalized</em>) into the fit data. The output
shows that
results for the leading term have converged by <tt class="docutils literal"><span class="pre">N=2</span></tt> (and even <tt class="docutils literal"><span class="pre">N=1</span></tt> isn&#8217;t
so bad):</p>
<div class="highlight-python"><pre>============================== nterm = 1
Least Square Fit (input data correlated with prior):
  chi2/dof [dof] = 0.76 [69]    Q = 0.93    logGBF = 1593.4    itns = 8

Parameters:
  log(etas:a) 0   -1.52138 (57)      [ -1.2 (1.0) ]
 log(etas:dE) 0   -0.87655 (20)      [ -0.92 (50) ]
    log(Ds:a) 0    -1.5379 (10)      [ -1.2 (1.0) ]
   log(Ds:dE) 0    0.18378 (12)      [  0.18 (17) ]
   log(Ds:ao) 0     -2.611 (30)      [ -2.3 (1.0) ]
  log(Ds:dEo) 0     0.3758 (37)      [  0.41 (24) ]
        Vnn 0,0    0.76574 (80)      [  0.0 (1.0) ]
        Vno 0,0     -0.712 (12)      [  0.0 (1.0) ]

Settings:
  svdcut = (1e-15,1e-15)   svdnum = (None,None)    reltol/abstol = 1e-10/1e-10

============================== nterm = 2
Least Square Fit (input data correlated with prior):
  chi2/dof [dof] = 0.61 [69]    Q = 1    logGBF = 1605.3    itns = 13

Parameters:
  log(etas:a) 0   -1.52138 (50)      [ -1.2 (1.0) ]
              1      -1.50 (56)      [ -1.2 (1.0) ]
 log(etas:dE) 0   -0.87654 (20)      [ -0.92 (50) ]
              1      -0.43 (15)      [ -0.7 (1.0) ]
    log(Ds:a) 0   -1.53849 (81)      [ -1.2 (1.0) ]
              1     -1.344 (82)      [ -1.2 (1.0) ]
   log(Ds:dE) 0    0.18372 (11)      [  0.18 (17) ]
              1     -0.707 (37)      [ -0.7 (1.0) ]
   log(Ds:ao) 0     -2.702 (76)      [ -2.3 (1.0) ]
              1      -2.37 (13)      [ -2.3 (1.0) ]
  log(Ds:dEo) 0     0.3692 (68)      [  0.41 (24) ]
              1      -1.30 (23)      [ -0.7 (1.0) ]
        Vnn 0,0    0.76759 (90)      [  0.0 (1.0) ]
            0,1     -0.490 (37)      [  0.0 (1.0) ]
            1,0      0.043 (72)      [  0.0 (1.0) ]
            1,1       0.44 (83)      [  0.0 (1.0) ]
        Vno 0,0     -0.761 (35)      [  0.0 (1.0) ]
            0,1       0.31 (17)      [  0.0 (1.0) ]
            1,0       0.12 (45)      [  0.0 (1.0) ]
            1,1       0.13 (98)      [  0.0 (1.0) ]

Settings:
  svdcut = (1e-15,1e-15)   svdnum = (None,None)    reltol/abstol = 1e-10/1e-10

Fit results:
  Eetas: 0.416219(81) 1.07(10)
  aetas: 0.21841(11) 0.22(13)

  EDs: 1.20168(13) 1.695(18)
  aDs: 0.21471(17) 0.261(21)

  EDso: 1.4466(98) 1.720(69)
  aDso: 0.0671(51) 0.093(12)

  etas-&gt;V-&gt;Ds  = 0.76759(90)
  etas-&gt;V-&gt;Dso = -0.761(35)

Values:
              metas: 0.416219(81)        
                mDs: 1.20168(13)         
           mDso-mDs: 0.2449(98)          
                Vnn: 0.76759(90)         
                Vno: -0.761(35)          

Partial % Errors:
                         metas       mDs  mDso-mDs       Vnn       Vno
----------------------------------------------------------------------
         statistics:      0.02      0.01      3.24      0.11      4.04
        log(etas:a):      0.00      0.00      0.04      0.00      0.14
       log(etas:dE):      0.00      0.00      0.03      0.00      0.10
          log(Ds:a):      0.00      0.00      0.31      0.01      0.56
         log(Ds:dE):      0.00      0.00      0.46      0.02      0.55
         log(Ds:ao):      0.00      0.00      0.33      0.00      1.10
        log(Ds:dEo):      0.00      0.00      0.52      0.01      1.48
                Vnn:      0.00      0.00      1.19      0.03      0.17
                Vno:      0.00      0.00      1.85      0.02      1.00
                svd:      0.00      0.00      0.00      0.00      0.00
----------------------------------------------------------------------
              total:      0.02      0.01      4.01      0.12      4.63



</pre>
</div>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">corrfitter</span></tt> - Least-Squares Fit to Correlators</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#basic-fits">Basic Fits</a><ul>
<li><a class="reference internal" href="#a-make-data">a) make_data</a></li>
<li><a class="reference internal" href="#b-make-models">b) make_models</a></li>
<li><a class="reference internal" href="#c-make-prior">c) make_prior</a></li>
<li><a class="reference internal" href="#d-print-results">d) print_results</a></li>
</ul>
</li>
<li><a class="reference internal" href="#faster-fits">Faster Fits</a></li>
<li><a class="reference internal" href="#faster-fits-postive-parameters">Faster Fits &#8212; Postive Parameters</a></li>
<li><a class="reference internal" href="#faster-fits-chained-fits">Faster Fits &#8212; Chained Fits</a></li>
<li><a class="reference internal" href="#faster-fits-marginalization">Faster Fits &#8212; Marginalization</a></li>
<li><a class="reference internal" href="#variations">Variations</a></li>
<li><a class="reference internal" href="#very-fast-but-limited-fits">Very Fast (But Limited) Fits</a></li>
<li><a class="reference internal" href="#point-correlators">3-Point Correlators</a></li>
<li><a class="reference internal" href="#bootstrap-analyses">Bootstrap Analyses</a></li>
<li><a class="reference internal" href="#new-models">New Models</a></li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#correlator-model-objects">Correlator Model Objects</a></li>
<li><a class="reference internal" href="#corrfitter-objects"><tt class="docutils literal"><span class="pre">corrfitter.CorrFitter</span></tt> Objects</a></li>
<li><a class="reference internal" href="#fast-fit-objects">Fast Fit Objects</a></li>
<li><a class="reference internal" href="#annotated-example">Annotated Example</a><ul>
<li><a class="reference internal" href="#id3">a) make_data</a></li>
<li><a class="reference internal" href="#id4">b) make_models</a></li>
<li><a class="reference internal" href="#id5">c) make_prior</a></li>
<li><a class="reference internal" href="#id6">d) print_results</a></li>
<li><a class="reference internal" href="#e-final-results">e) Final Results</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">corrfitter Documentation</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="index.html" title="corrfitter Documentation"
             >previous</a> |</li>
        <li><a href="index.html">corrfitter 3.4.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-12, G.P. Lepage.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>